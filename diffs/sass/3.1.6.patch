From 04781d7fe0c680045ceba5e00ef659484dfe7e64 Mon Sep 17 00:00:00 2001
From: Patrick Kettner <patrickkettner@gmail.com>
Date: Mon, 12 Dec 2016 21:33:17 -0800
Subject: [PATCH] .

---
 lib/sass/engine.rb                      |  69 +++++++++-----------
 lib/sass/environment.rb                 |  14 ++---
 lib/sass/error.rb                       |  11 +++-
 lib/sass/importers/filesystem.rb        |   7 ---
 lib/sass/less.rb                        |   2 +-
 lib/sass/plugin/compiler.rb             |  75 ----------------------
 lib/sass/script.rb                      |   5 +-
 lib/sass/script/interpolation.rb        |  24 +++----
 lib/sass/script/lexer.rb                |  29 ++++++---
 lib/sass/script/number.rb               |   4 +-
 lib/sass/script/parser.rb               |   3 +-
 lib/sass/script/string_interpolation.rb |  28 ++++-----
 lib/sass/scss/css_parser.rb             |   2 +-
 lib/sass/scss/parser.rb                 |  34 +++++-----
 lib/sass/scss/rx.rb                     |  79 ++++++++++++-----------
 lib/sass/scss/static_parser.rb          |   2 +-
 lib/sass/selector.rb                    |   4 ++
 lib/sass/selector/sequence.rb           |   9 ++-
 lib/sass/selector/simple_sequence.rb    |   2 +-
 lib/sass/shared.rb                      |   2 +-
 lib/sass/tree/comment_node.rb           |   6 +-
 lib/sass/tree/import_node.rb            |   4 +-
 lib/sass/tree/rule_node.rb              |   5 +-
 lib/sass/tree/visitors/base.rb          |   2 +-
 lib/sass/tree/visitors/convert.rb       |  34 +++++-----
 lib/sass/tree/visitors/perform.rb       |   8 +--
 lib/sass/tree/visitors/to_css.rb        |  72 ++++++++++-----------
 lib/sass/util.rb                        |  56 ++---------------
 lib/sass/version.rb                     | 107 +-------------------------------
 29 files changed, 245 insertions(+), 454 deletions(-)

diff --git a/lib/sass/engine.rb b/lib/sass/engine.rb
index 3f66aa2..95a7d1e 100644
--- a/lib/sass/engine.rb
+++ b/lib/sass/engine.rb
@@ -1,6 +1,5 @@
 require 'strscan'
 require 'set'
-require 'digest/sha1'
 require 'sass/cache_stores'
 require 'sass/tree/node'
 require 'sass/tree/root_node'
@@ -146,6 +145,7 @@ module Sass
     # @return [{Symbol => Object}] The normalized options hash.
     # @private
     def self.normalize_options(options)
+      options[:syntax] = options[:syntax].to_sym
       options = DEFAULT_OPTIONS.merge(options.reject {|k, v| v.nil?})
 
       # If the `:filename` option is passed in without an importer,
@@ -293,29 +293,13 @@ module Sass
       rendered = _to_tree.render
       return rendered if ruby1_8?
       begin
-        # Try to convert the result to the original encoding,
-        # but if that doesn't work fall back on UTF-8
-        rendered = rendered.encode(source_encoding)
+      rendered
       rescue EncodingError
       end
-      rendered.gsub(Regexp.new('\A@charset "(.*?)"'.encode(source_encoding)),
-        "@charset \"#{source_encoding.name}\"".encode(source_encoding))
+      rendered
     end
 
     def _to_tree
-      if (@options[:cache] || @options[:read_cache]) &&
-          @options[:filename] && @options[:importer]
-        key = sassc_key
-        sha = Digest::SHA1.hexdigest(@template)
-
-        if root = @options[:cache_store].retrieve(key, sha)
-          root.options = @options
-          return root
-        end
-      end
-
-      check_encoding!
-
       if @options[:syntax] == :scss
         root = Sass::SCSS::Parser.new(@template).parse
       else
@@ -324,15 +308,6 @@ module Sass
       end
 
       root.options = @options
-      if @options[:cache] && key && sha
-        begin
-          old_options = root.options
-          root.options = {}
-          @options[:cache_store].store(key, sha, root)
-        ensure
-          root.options = old_options
-        end
-      end
       root
     rescue SyntaxError => e
       e.modify_backtrace(:filename => @options[:filename], :line => @line)
@@ -360,7 +335,7 @@ module Sass
       string.gsub(/\r|\n|\r\n|\r\n/, "\n").scan(/^[^\n]*?$/).each_with_index do |line, index|
         index += (@options[:line] || 1)
         if line.strip.empty?
-          lines.last.text << "\n" if lines.last && lines.last.comment?
+	  lines.last.text += "\n" if lines.last && lines.last.comment?
           next
         end
 
@@ -420,7 +395,7 @@ but this line was indented by #{Sass::Shared.human_indentation line[/^\s*/]}.
 MSG
       end
 
-      last.text << "\n" << $1
+      last.text += "\n" + $1
       true
     end
 
@@ -487,7 +462,7 @@ MSG
           if continued_comment &&
               child.line == continued_comment.line +
               continued_comment.value.count("\n") + 1
-            continued_comment.value << "\n" << child.value
+	    continued_comment.value += "\n" + child.value
             next
           end
 
@@ -611,7 +586,11 @@ WARNING
     end
 
     def parse_directive(parent, line, root)
-      directive, whitespace, value = line.text[1..-1].split(/(\s+)/, 2)
+      txt = line.text[1..-1]
+      re = /\s+/
+      directive, value = txt.split(re, 2)
+      whitespace = txt.match(re)
+      whitespace = whitespace.to_s unless whitespace.nil?
       offset = directive.size + whitespace.size + 1 if whitespace
 
       # If value begins with url( or ",
@@ -661,7 +640,7 @@ WARNING
         offset = line.offset + line.text.index(value).to_i
         Tree::ReturnNode.new(parse_script(value, :offset => offset))
       elsif directive == "charset"
-        name = value && value[/\A(["'])(.*)\1\Z/, 2] #"
+	name = value && value[/\^(["'])(.*)\1\$/, 2] #"
         raise SyntaxError.new("Invalid charset directive '@charset': expected string.") unless name
         raise SyntaxError.new("Illegal nesting: Nothing may be nested beneath charset directives.",
           :line => @line + 1) unless line.children.empty?
@@ -768,7 +747,7 @@ WARNING
       end
     end
 
-    MIXIN_DEF_RE = /^(?:=|@mixin)\s*(#{Sass::SCSS::RX::IDENT})(.*)$/
+    MIXIN_DEF_RE = /^(?:=|@mixin)\s*(#{Sass::SCSS::RX::IDENT.source})(.*)$/
     def parse_mixin_definition(line)
       name, arg_string = line.text.scan(MIXIN_DEF_RE).first
       raise SyntaxError.new("Invalid mixin \"#{line.text[1..-1]}\".") if name.nil?
@@ -779,7 +758,7 @@ WARNING
       Tree::MixinDefNode.new(name, args)
     end
 
-    MIXIN_INCLUDE_RE = /^(?:\+|@include)\s*(#{Sass::SCSS::RX::IDENT})(.*)$/
+    MIXIN_INCLUDE_RE = /^(?:\+|@include)\s*(#{Sass::SCSS::RX::IDENT.source})(.*)$/
     def parse_mixin_include(line, root)
       name, arg_string = line.text.scan(MIXIN_INCLUDE_RE).first
       raise SyntaxError.new("Invalid mixin include \"#{line.text}\".") if name.nil?
@@ -792,7 +771,7 @@ WARNING
       Tree::MixinNode.new(name, args, keywords)
     end
 
-    FUNCTION_RE = /^@function\s*(#{Sass::SCSS::RX::IDENT})(.*)$/
+    FUNCTION_RE = /^@function\s*(#{Sass::SCSS::RX::IDENT.source})(.*)$/
     def parse_function(line, root)
       name, arg_string = line.text.scan(FUNCTION_RE).first
       raise SyntaxError.new("Invalid function definition \"#{line.text}\".") if name.nil?
@@ -818,15 +797,23 @@ WARNING
       end
 
       return silent ? "//" : "/* */" if content.empty?
-      content.last.gsub!(%r{ ?\*/ *$}, '')
-      content.map! {|l| l.gsub!(/^\*( ?)/, '\1') || (l.empty? ? "" : " ") + l}
-      content.first.gsub!(/^ /, '') unless removed_first
+      content[-1] = content.last.gsub(%r{ ?\*/ *$}, '')
+      content = content.map {|l|
+	old_val = l
+	l = l.gsub(/^\*( ?)/, '\1')
+	l = (l.empty? ? "" : " ") + l if l == old_val
+	l
+      }
+      content[0] = content.first.gsub(/^ /, '') unless removed_first
       if silent
-        "//" + content.join("\n//")
+	res = "//" + content.join("\n//")
       else
         # The #gsub fixes the case of a trailing */
-        "/*" + content.join("\n *").gsub(/ \*\Z/, '') + " */"
+	res = "/*" + content.join("\n *")
+	res = res[0...-2] if res[-2..-1] == ' *'
+	res += " */"
       end
+      res
     end
 
     def parse_interp(text, offset = 0)
diff --git a/lib/sass/environment.rb b/lib/sass/environment.rb
index 1e2b652..e195b87 100644
--- a/lib/sass/environment.rb
+++ b/lib/sass/environment.rb
@@ -97,8 +97,8 @@ module Sass
       trace = []
       stack.reverse.each_with_index do |entry, i|
         msg = "#{i == 0 ? "on" : "from"} line #{entry[:line]}"
-        msg << " of #{entry[:filename] || "an unknown file"}"
-        msg << ", in `#{entry[:mixin]}'" if entry[:mixin]
+        msg += " of #{entry[:filename] || "an unknown file"}"
+        msg += ", in `#{entry[:mixin]}'" if entry[:mixin]
         trace << msg
       end
       trace
@@ -111,15 +111,15 @@ module Sass
     end
 
     class << self
-      private
-      UNDERSCORE, DASH = '_', '-'
+      UNDERSCORE = '_'
+      DASH = '-'
 
       # Note: when updating this,
       # update sass/yard/inherited_hash.rb as well.
       def inherited_hash(name)
         class_eval <<RUBY, __FILE__, __LINE__ + 1
           def #{name}(name)
-            _#{name}(name.tr(UNDERSCORE, DASH))
+	    _#{name}(name.tr("_", "-"))
           end
 
           def _#{name}(name)
@@ -128,7 +128,7 @@ module Sass
           protected :_#{name}
 
           def set_#{name}(name, value)
-            name = name.tr(UNDERSCORE, DASH)
+	    name = name.tr("_", "-")
             @#{name}s[name] = value unless try_set_#{name}(name, value)
           end
 
@@ -147,7 +147,7 @@ module Sass
 
           def set_local_#{name}(name, value)
             @#{name}s ||= {}
-            @#{name}s[name.tr(UNDERSCORE, DASH)] = value
+	    @#{name}s[name.tr("_", "-")] = value
           end
 RUBY
       end
diff --git a/lib/sass/error.rb b/lib/sass/error.rb
index c47c0db..93e1d99 100644
--- a/lib/sass/error.rb
+++ b/lib/sass/error.rb
@@ -103,13 +103,17 @@ module Sass
     #
     # @param attrs [{Symbol => Object}] The information to add to the backtrace entry.
     #   See \{#sass\_backtrace}
+    def reject_if_included(attrs, entry)
+      attrs.reject {|k, v| entry.include?(k)}
+    end
+
     def modify_backtrace(attrs)
       attrs = attrs.reject {|k, v| v.nil?}
       # Move backwards through the backtrace
       (0...sass_backtrace.size).to_a.reverse.each do |i|
         entry = sass_backtrace[i]
         sass_backtrace[i] = attrs.merge(entry)
-        attrs.reject! {|k, v| entry.include?(k)}
+	attrs = reject_if_included(attrs, entry)
         break if attrs.empty?
       end
     end
@@ -119,6 +123,11 @@ module Sass
       @message
     end
 
+    def append_to_err (str)
+      @message += str
+      self
+    end
+
     # Returns the standard exception backtrace,
     # including the Sass backtrace.
     #
diff --git a/lib/sass/importers/filesystem.rb b/lib/sass/importers/filesystem.rb
index d436d77..928f82b 100644
--- a/lib/sass/importers/filesystem.rb
+++ b/lib/sass/importers/filesystem.rb
@@ -107,13 +107,6 @@ module Sass
       # @param name [String] The filename to search for.
       # @return [(String, Symbol)] A filename-syntax pair.
       def find_real_file(dir, name)
-        for (f,s) in possible_files(remove_root(name))
-          path = (dir == ".") ? f : "#{dir}/#{f}"
-          if full_path = Dir[path].first
-            full_path.gsub!(REDUNDANT_DIRECTORY,File::SEPARATOR)
-            return full_path, s
-          end
-        end
         nil
       end
 
diff --git a/lib/sass/less.rb b/lib/sass/less.rb
index 66f2027..a5dea0b 100755
--- a/lib/sass/less.rb
+++ b/lib/sass/less.rb
@@ -171,7 +171,7 @@ WARNING
           end
           last_el = el
           comma_sel = comma_sel.join(' ').gsub(' :', ':')
-          comma_sel.gsub!(/^:/, '&:') unless parent.root?
+	  comma_sel = comma_sel.gsub(/^:/, '&:') unless parent.root?
           comma_sel
         end.join(', ')
 
diff --git a/lib/sass/plugin/compiler.rb b/lib/sass/plugin/compiler.rb
index f7b511a..d351dad 100644
--- a/lib/sass/plugin/compiler.rb
+++ b/lib/sass/plugin/compiler.rb
@@ -211,81 +211,6 @@ module Sass::Plugin
     #   The first string in each pair is the location of the Sass/SCSS file,
     #   the second is the location of the CSS file that it should be compiled to.
     def watch(individual_files = [])
-      update_stylesheets(individual_files)
-
-      begin
-        require 'fssm'
-      rescue LoadError => e
-        dir = Sass::Util.scope("vendor/fssm/lib")
-        if $LOAD_PATH.include?(dir)
-          e.message << "\n" <<
-            if File.exists?(scope(".git"))
-              'Run "git submodule update --init" to get the recommended version.'
-            else
-              'Run "gem install fssm" to get it.'
-            end
-          raise e
-        else
-          $LOAD_PATH.unshift dir
-          retry
-        end
-      end
-
-      unless individual_files.empty? && FSSM::Backends::Default.name == "FSSM::Backends::FSEvents"
-        # As of FSSM 0.1.4, it doesn't support FSevents on individual files,
-        # but it also isn't smart enough to switch to polling itself.
-        require 'fssm/backends/polling'
-        Sass::Util.silence_warnings do
-          FSSM::Backends.const_set(:Default, FSSM::Backends::Polling)
-        end
-      end
-
-      # TODO: Keep better track of what depends on what
-      # so we don't have to run a global update every time anything changes.
-      FSSM.monitor do |mon|
-        template_location_array.each do |template_location, css_location|
-          mon.path template_location do |path|
-            path.glob '**/*.s[ac]ss'
-
-            path.update do |base, relative|
-              run_template_modified File.join(base, relative)
-              update_stylesheets(individual_files)
-            end
-
-            path.create do |base, relative|
-              run_template_created File.join(base, relative)
-              update_stylesheets(individual_files)
-            end
-
-            path.delete do |base, relative|
-              run_template_deleted File.join(base, relative)
-              css = File.join(css_location, relative.gsub(/\.s[ac]ss$/, '.css'))
-              try_delete_css css
-              update_stylesheets(individual_files)
-            end
-          end
-        end
-
-        individual_files.each do |template, css|
-          mon.file template do |path|
-            path.update do
-              run_template_modified template
-              update_stylesheets(individual_files)
-            end
-
-            path.create do
-              run_template_created template
-              update_stylesheets(individual_files)
-            end
-
-            path.delete do
-              run_template_deleted template
-              try_delete_css css
-              update_stylesheets(individual_files)
-            end
-          end
-        end
-      end
     end
 
     # Non-destructively modifies \{#options} so that default values are properly set,
diff --git a/lib/sass/script.rb b/lib/sass/script.rb
index 78ca2a8..2cc39f6 100644
--- a/lib/sass/script.rb
+++ b/lib/sass/script.rb
@@ -13,10 +13,11 @@ module Sass
   # This module contains code that handles the parsing and evaluation of SassScript.
   module Script
     # The regular expression used to parse variables.
-    MATCH = /^\$(#{Sass::SCSS::RX::IDENT})\s*:\s*(.+?)(!(?i:default))?$/
+
+    MATCH = /^\$(#{Sass::SCSS::RX::IDENT.source})\s*:\s*(.+?)(!(?:[dD][eE][fF][aA][uU][lL][tT]))?$/
 
     # The regular expression used to validate variables without matching.
-    VALIDATE = /^\$#{Sass::SCSS::RX::IDENT}$/
+    VALIDATE = /^\$#{Sass::SCSS::RX::IDENT.source}$/
 
     # Parses a string of SassScript
     #
diff --git a/lib/sass/script/interpolation.rb b/lib/sass/script/interpolation.rb
index 53902b1..5d3395e 100644
--- a/lib/sass/script/interpolation.rb
+++ b/lib/sass/script/interpolation.rb
@@ -31,13 +31,13 @@ module Sass::Script
     # @see Node#to_sass
     def to_sass(opts = {})
       res = ""
-      res << @before.to_sass(opts) if @before
-      res << ' ' if @before && @whitespace_before
-      res << '#{' unless @originally_text
-      res << @mid.to_sass(opts)
-      res << '}' unless @originally_text
-      res << ' ' if @after && @whitespace_after
-      res << @after.to_sass(opts) if @after
+      res += @before.to_sass(opts) if @before
+      res += ' ' if @before && @whitespace_before
+      res += '#{' unless @originally_text
+      res += @mid.to_sass(opts)
+      res += '}' unless @originally_text
+      res += ' ' if @after && @whitespace_after
+      res += @after.to_sass(opts) if @after
       res
     end
 
@@ -67,12 +67,12 @@ module Sass::Script
     # @return [Sass::Script::String] The SassScript string that is the value of the interpolation
     def _perform(environment)
       res = ""
-      res << @before.perform(environment).to_s if @before
-      res << " " if @before && @whitespace_before
+      res += @before.perform(environment).to_s if @before
+      res += " " if @before && @whitespace_before
       val = @mid.perform(environment)
-      res << (val.is_a?(Sass::Script::String) ? val.value : val.to_s)
-      res << " " if @after && @whitespace_after
-      res << @after.perform(environment).to_s if @after
+      res += (val.is_a?(Sass::Script::String) ? val.value : val.to_s)
+      res += " " if @after && @whitespace_after
+      res += @after.perform(environment).to_s if @after
       opts(Sass::Script::String.new(res))
     end
   end
diff --git a/lib/sass/script/lexer.rb b/lib/sass/script/lexer.rb
index c264f81..af78075 100644
--- a/lib/sass/script/lexer.rb
+++ b/lib/sass/script/lexer.rb
@@ -87,12 +87,13 @@ module Sass
         :whitespace => /\s+/,
         :comment => COMMENT,
         :single_line_comment => SINGLE_LINE_COMMENT,
-        :variable => /(\$)(#{IDENT})/,
-        :ident => /(#{IDENT})(\()?/,
+	:variable => /(\$)(#{IDENT.source})/,
+	:ident => /(#{IDENT.source})(\()?/,
         :number => /(-)?(?:(\d*\.\d+)|(\d+))([a-zA-Z%]+)?/,
         :color => HEXCOLOR,
         :bool => /(true|false)\b/,
-        :ident_op => %r{(#{Regexp.union(*IDENT_OP_NAMES.map{|s| Regexp.new(Regexp.escape(s) + "(?!#{NMCHAR}|\Z)")})})},
+	:ident_op => %r{(#{Regexp.union(*IDENT_OP_NAMES.map{|s| Regexp.new(Regexp.escape(s) + "(?!#{NMCHAR.source}|\Z)")})})},
+	:ident_op_pre => /#{IDENT_OP_NAMES.join('|')}/,
         :op => %r{(#{Regexp.union(*OP_NAMES)})},
       }
 
@@ -114,8 +115,8 @@ module Sass
         [:single, false] => string_re("'", "'"),
         [:double, true] => string_re('', '"'),
         [:single, true] => string_re('', "'"),
-        [:uri, false] => /url\(#{W}(#{URLCHAR}*?)(#{W}\)|#\{)/,
-        [:uri, true] => /(#{URLCHAR}*?)(#{W}\)|#\{)/,
+	[:uri, false] => /url\(#{W.source}((#{URLCHAR.source})*?)(#{W.source}\)|#\{)/,
+	[:uri, true] => /((#{URLCHAR.source})*?)(#{W.source}\)|#\{)/,
       }
 
       # @param str [String, StringScanner] The source text to lex
@@ -149,10 +150,10 @@ module Sass
       # @return [Boolean]
       def whitespace?(tok = @tok)
         if tok
-          @scanner.string[0...tok.pos] =~ /\s\Z/
+	  @scanner.string[0...tok.pos] =~ /\s$/
         else
           @scanner.string[@scanner.pos, 1] =~ /^\s/ ||
-            @scanner.string[@scanner.pos - 1, 1] =~ /\s\Z/
+	    @scanner.string[@scanner.pos - 1, 1] =~ /\s$/
         end
       end
 
@@ -211,7 +212,7 @@ module Sass
         return if done?
         return unless value = token
         type, val, size = value
-        size ||= @scanner.matched_size
+	size ||= @scanner.matched && @scanner.matched.length
 
         val.line = @line if val.is_a?(Script::Node)
         Token.new(type, val, @line,
@@ -308,7 +309,17 @@ MESSAGE
       end
 
       def ident_op
-        return unless op = scan(REGULAR_EXPRESSIONS[:ident_op])
+	# have to rewrite this entirely because of JS's support of \Z in order
+	# to get the fix in 67a662e3 working
+	return unless op = @scanner.check(REGULAR_EXPRESSIONS[:ident_op_pre])
+
+	orig_position = @scanner.pos
+	@scanner.pos += op.size
+	negative_check = @scanner.check(%r{(?!#{NMCHAR.source})}) != ""
+	@scanner.pos = orig_position
+
+	return if @scanner.eos? or negative_check
+	op = scan(REGULAR_EXPRESSIONS[:ident_op_pre])
         [OPERATORS[op]]
       end
 
diff --git a/lib/sass/script/number.rb b/lib/sass/script/number.rb
index ae27cb9..560f5fa 100644
--- a/lib/sass/script/number.rb
+++ b/lib/sass/script/number.rb
@@ -322,8 +322,8 @@ module Sass::Script
     def unit_str
       rv = @numerator_units.sort.join("*")
       if @denominator_units.any?
-        rv << "/"
-        rv << @denominator_units.sort.join("*")
+	rv += "/"
+	rv += @denominator_units.sort.join("*")
       end
       rv
     end
diff --git a/lib/sass/script/parser.rb b/lib/sass/script/parser.rb
index e38e5b6..6582d4f 100644
--- a/lib/sass/script/parser.rb
+++ b/lib/sass/script/parser.rb
@@ -263,7 +263,8 @@ RUBY
 
       def space
         line = @lexer.line
-        return unless e = or_expr
+	e = or_expr
+	return unless e
         arr = [e]
         while e = or_expr
           arr << e
diff --git a/lib/sass/script/string_interpolation.rb b/lib/sass/script/string_interpolation.rb
index 6baba12..2c76d9e 100644
--- a/lib/sass/script/string_interpolation.rb
+++ b/lib/sass/script/string_interpolation.rb
@@ -31,23 +31,23 @@ module Sass::Script
         (!before_quote_char && after_quote_char && !before_str.empty?)
       quote_char =
         if before_quote_char && after_quote_char && before_quote_char != after_quote_char
-          before_str.gsub!("\\'", "'")
-          before_str.gsub!('"', "\\\"")
-          after_str.gsub!("\\'", "'")
-          after_str.gsub!('"', "\\\"")
+	  before_str = before_str.gsub("\\'", "'")
+	  before_str = before_str.gsub('"', "\\\"")
+	  after_str = after_str.gsub("\\'", "'")
+	  after_str = after_str.gsub('"', "\\\"")
           '"'
         else
           before_quote_char || after_quote_char
         end
 
       res = ""
-      res << 'unquote(' if unquote
-      res << quote_char if quote_char
-      res << before_str
-      res << '#{' << @mid.to_sass(opts) << '}'
-      res << after_str
-      res << quote_char if quote_char
-      res << ')' if unquote
+      res += 'unquote(' if unquote
+      res += quote_char if quote_char
+      res += before_str
+      res += '#{' + @mid.to_sass(opts) + '}'
+      res += after_str
+      res += quote_char if quote_char
+      res += ')' if unquote
       res
     end
 
@@ -78,10 +78,10 @@ module Sass::Script
     def _perform(environment)
       res = ""
       before = @before.perform(environment)
-      res << before.value
+      res += before.value
       mid = @mid.perform(environment)
-      res << (mid.is_a?(Sass::Script::String) ? mid.value : mid.to_s)
-      res << @after.perform(environment).value
+      res += (mid.is_a?(Sass::Script::String) ? mid.value : mid.to_s)
+      res += @after.perform(environment).value
       opts(Sass::Script::String.new(res, before.type))
     end
 
diff --git a/lib/sass/scss/css_parser.rb b/lib/sass/scss/css_parser.rb
index 8964ced..f5c594f 100644
--- a/lib/sass/scss/css_parser.rb
+++ b/lib/sass/scss/css_parser.rb
@@ -12,7 +12,7 @@ module Sass
       # @return [String, nil] The parsed selector, or nil if no selector was parsed
       # @raise [Sass::SyntaxError] if there's a syntax error in the selector
       def parse_selector_string
-        init_scanner!
+	init_scanner
         str {return unless selector}
       end
 
diff --git a/lib/sass/scss/parser.rb b/lib/sass/scss/parser.rb
index a944b59..796692a 100644
--- a/lib/sass/scss/parser.rb
+++ b/lib/sass/scss/parser.rb
@@ -22,7 +22,7 @@ module Sass
       # @return [Sass::Tree::RootNode] The root node of the document tree
       # @raise [Sass::SyntaxError] if there's a syntax error in the document
       def parse
-        init_scanner!
+	@scanner = init_scanner
         root = stylesheet
         expected("selector or at-rule") unless @scanner.eos?
         root
@@ -35,7 +35,7 @@ module Sass
       # @return [Array<String, Sass::Script::Node>, nil]
       #   The interpolated identifier, or nil if none could be parsed
       def parse_interp_ident
-        init_scanner!
+	@scanner = init_scanner
         interp_ident
       end
 
@@ -43,7 +43,7 @@ module Sass
 
       include Sass::SCSS::RX
 
-      def init_scanner!
+      def init_scanner
         @scanner =
           if @template.is_a?(StringScanner)
             @template
@@ -88,10 +88,13 @@ module Sass
 
       def process_comment(text, node)
         single_line = text =~ /^\/\//
-        pre_str = single_line ? "" : @scanner.
-          string[0...@scanner.pos].
-          reverse[/.*?\*\/(.*?)($|\Z)/, 1].
-          reverse.gsub(/[^\s]/, ' ')
+	if single_line
+	  pre_str = ""
+	else
+	  pre_str = @scanner.string[0...@scanner.pos].reverse
+	  pre_str = pre_str[/.*?\*\/(.*?)($|\Z)/m, 1] || ''
+	  pre_str = pre_str.reverse.gsub(/[^\s]/, ' ')
+	end
         text = text.sub(/^\s*\/\//, '/*').gsub(/^\s*\/\//, ' *') + ' */' if single_line
         comment = Sass::Tree::CommentNode.new(pre_str + text, single_line)
         comment.line = @line - text.count("\n")
@@ -451,7 +454,7 @@ module Sass
         selectors = [sel]
         ws = ''
         while tok(/,/)
-          ws << str{ss}
+	  ws += str{ss}
           if sel = _selector
             selectors << sel
             selectors[-1] = Selector::Sequence.new(["\n"] + selectors.last.members) if ws.include?("\n")
@@ -497,7 +500,8 @@ module Sass
           begin
             expected('"{"')
           rescue Sass::SyntaxError => e
-            e.message << "\n\n" << <<MESSAGE
+	    e.append_to_err "\n\n"
+	    e.append_to_err <<MESSAGE
 In Sass 3, the parent selector & can only be used where element names are valid,
 since it could potentially be replaced by an element name.
 MESSAGE
@@ -738,7 +742,7 @@ MESSAGE
         # @scanner[2].empty? means we've started an interpolated section
         while @scanner[2] == '#{'
           @scanner.pos -= 2 # Don't consume the #{
-          res.last.slice!(-2..-1)
+	  res[-1] = res.last.slice(0...-2)
           res << expr!(:interpolation) << tok(mid_re)
         end
         res
@@ -880,17 +884,17 @@ MESSAGE
         after = scanner.string[0...pos]
         # Get rid of whitespace between pos and the last token,
         # but only if there's a newline in there
-        after.gsub!(/\s*\n\s*$/, '')
+	after = after.gsub(/\s*\n\s*$/, '')
         # Also get rid of stuff before the last newline
-        after.gsub!(/.*\n/, '')
+	after = after.gsub(/.*\n/, '')
         after = "..." + after[-15..-1] if after.size > 18
 
         was = scanner.rest.dup
         # Get rid of whitespace between pos and the next token,
         # but only if there's a newline in there
-        was.gsub!(/^\s*\n\s*/, '')
+	was = was.gsub(/^\s*\n\s*/, '')
         # Also get rid of stuff after the next newline
-        was.gsub!(/\n.*/, '')
+	was = was.gsub(/\n.*/, '')
         was = was[0...15] + "..." if was.size > 18
 
         raise Sass::SyntaxError.new(
@@ -908,7 +912,7 @@ MESSAGE
           @line += res.count(NEWLINE)
           @expected = nil
           if !@strs.empty? && rx != COMMENT && rx != SINGLE_LINE_COMMENT
-            @strs.each {|s| s << res}
+	    @strs = @strs.map {|s| s += res}
           end
           res
         end
diff --git a/lib/sass/scss/rx.rb b/lib/sass/scss/rx.rb
index 0dfd4a1..5cc89e8 100644
--- a/lib/sass/scss/rx.rb
+++ b/lib/sass/scss/rx.rb
@@ -15,13 +15,19 @@ module Sass
         return "\\#{str}" if str == '-' || str == '_'
         out = ""
         value = str.dup
-        out << value.slice!(0...1) if value =~ /^[-_]/
+
+	if value =~ /^[-_]/
+	  out += value.slice(0...1)
+	  value = value.slice(1..-1)
+	end
         if value[0...1] =~ NMSTART
-          out << value.slice!(0...1)
+	  out += value.slice(0...1)
+	  value = value.slice(1..-1)
         else
-          out << escape_char(value.slice!(0...1))
+	  out += escape_char(value.slice(0...1))
+	  value = value.slice(1..-1)
         end
-        out << value.gsub(/[^a-zA-Z0-9_-]/) {|c| escape_char c}
+	out += value.gsub(/[^a-zA-Z0-9_-]/) {|c| escape_char c}
         return out
       end
 
@@ -46,33 +52,36 @@ module Sass
         Regexp.new(Regexp.quote(str), flags)
       end
 
+      IS_OPAL = RUBY_PLATFORM.eql? 'opal'
       H        = /[0-9a-fA-F]/
       NL       = /\n|\r\n|\r|\f/
-      UNICODE  = /\\#{H}{1,6}[ \t\r\n\f]?/
+      UNICODE  = /\\#{H.source}{1,6}[ \t\r\n\f]?/
       s = if Sass::Util.ruby1_8?
             '\200-\377'
+	  elsif IS_OPAL
+	    "[\\x80-\\uD7FF\\uDC00-\\uFFFF\]|[\\uD800-\\uDBFF\][\\uDC00-\\uDFFF\]|[\\uD800-\\uDBFF]"
           else
             '\u{80}-\u{D7FF}\u{E000}-\u{FFFD}\u{10000}-\u{10FFFF}'
           end
-      NONASCII = /[#{s}]/
-      ESCAPE   = /#{UNICODE}|\\[ -~#{s}]/
-      NMSTART  = /[_a-zA-Z]|#{NONASCII}|#{ESCAPE}/
-      NMCHAR   = /[a-zA-Z0-9_-]|#{NONASCII}|#{ESCAPE}/
-      STRING1  = /\"((?:[^\n\r\f\\"]|\\#{NL}|#{ESCAPE})*)\"/
-      STRING2  = /\'((?:[^\n\r\f\\']|\\#{NL}|#{ESCAPE})*)\'/
-
-      IDENT    = /-?#{NMSTART}#{NMCHAR}*/
-      NAME     = /#{NMCHAR}+/
+      NONASCII = IS_OPAL ? /#{s}/ : /[#{s}]/
+      ESCAPE   =  IS_OPAL ? /#{UNICODE.source}|\\(?:[ -~]|#{s})/ : /#{UNICODE.source}|\\[ -~#{s}]/
+      NMSTART  = /[_a-zA-Z]|#{NONASCII.source}|#{ESCAPE.source}/
+      NMCHAR   = /[a-zA-Z0-9_-]|#{NONASCII.source}|#{ESCAPE.source}/
+      STRING1  = /\"((?:[^\n\r\f\\"]|\\#{NL.source}|#{ESCAPE.source})*)\"/
+      STRING2  = /\'((?:[^\n\r\f\\']|\\#{NL.source}|#{ESCAPE.source})*)\'/
+
+      IDENT    = /-?(?:#{NMSTART.source})(?:#{NMCHAR.source})*/
+
+      NAME     = /(?:#{NMCHAR.source})+/
       NUM      = /[0-9]+|[0-9]*\.[0-9]+/
-      STRING   = /#{STRING1}|#{STRING2}/
-      URLCHAR  = /[#%&*-~]|#{NONASCII}|#{ESCAPE}/
-      URL      = /(#{URLCHAR}*)/
+      STRING   = /#{STRING1.source}|#{STRING2.source}/
+      URLCHAR  = /[#%&*-~]|#{NONASCII.source}|#{ESCAPE.source}/
+      URL      = /((?:#{URLCHAR.source})*)/
       W        = /[ \t\r\n\f]*/
-      VARIABLE = /(\$)(#{Sass::SCSS::RX::IDENT})/
-
+      VARIABLE = /(\$)(#{Sass::SCSS::RX::IDENT.source})/
       # This is more liberal than the spec's definition,
       # but that definition didn't work well with the greediness rules
-      RANGE    = /(?:#{H}|\?){1,6}/
+      RANGE    = /(?:#{H.source}|\?){1,6}/
 
       ##
 
@@ -89,22 +98,22 @@ module Sass
       SUFFIXMATCH    = quote("$=")
       SUBSTRINGMATCH = quote("*=")
 
-      HASH = /##{NAME}/
+      HASH = /##{NAME.source}/
 
-      IMPORTANT = /!#{W}important/i
-      DEFAULT = /!#{W}default/i
+      IMPORTANT = /!#{W.source}[iI][mM][pP][oO][rR][tT][aA][nN][tT]/
+      DEFAULT = /!#{W.source}[dD][eE][fF][aA][uU][lL][tT]/
 
-      NUMBER = /#{NUM}(?:#{IDENT}|%)?/
+      NUMBER = /(?:#{NUM.source})(?:#{IDENT.source}|%)?/
 
-      URI = /url\(#{W}(?:#{STRING}|#{URL})#{W}\)/i
-      FUNCTION = /#{IDENT}\(/
+      URI = /[uU][rR][lL]\(#{W.source}(?:#{STRING.source}|#{URL.source})#{W.source}\)/
+      FUNCTION = /#{IDENT.source}\(/
 
-      UNICODERANGE = /u\+(?:#{H}{1,6}-#{H}{1,6}|#{RANGE})/i
+      UNICODERANGE = /[uU]\+(?:#{H.source}{1,6}-#{H.source}{1,6}|#{RANGE.source})/
 
       # Defined in http://www.w3.org/TR/css3-selectors/#lex
-      PLUS = /#{W}\+/
-      GREATER = /#{W}>/
-      TILDE = /#{W}~/
+      PLUS = /#{W.source}\+/
+      GREATER = /#{W.source}>/
+      TILDE = /#{W.source}~/
       NOT = quote(":not(", Regexp::IGNORECASE)
 
       # Custom
@@ -112,16 +121,16 @@ module Sass
       INTERP_START = /#\{/
       MOZ_ANY = quote(":-moz-any(", Regexp::IGNORECASE)
 
-      STRING1_NOINTERP = /\"((?:[^\n\r\f\\"#]|#(?!\{)|\\#{NL}|#{ESCAPE})*)\"/
-      STRING2_NOINTERP = /\'((?:[^\n\r\f\\'#]|#(?!\{)|\\#{NL}|#{ESCAPE})*)\'/
-      STRING_NOINTERP = /#{STRING1_NOINTERP}|#{STRING2_NOINTERP}/
+      STRING1_NOINTERP = /\"((?:[^\n\r\f\\"#]|#(?!\{)|\\#{NL.source}|#{ESCAPE.source})*)\"/
+      STRING2_NOINTERP = /\'((?:[^\n\r\f\\'#]|#(?!\{)|\\#{NL.source}|#{ESCAPE.source})*)\'/
+      STRING_NOINTERP = /#{STRING1_NOINTERP.source}|#{STRING2_NOINTERP.source}/
       # Can't use IDENT here, because it seems to take exponential time on 1.8.
       # We could use it for 1.9 only, but I don't want to introduce a cross-version
       # behavior difference.
       # In any case, almost all CSS idents will be matched by this.
-      STATIC_VALUE = /(-?#{NMSTART}|#{STRING_NOINTERP}|\s(?!%)|#[a-f0-9]|[,%]|#{NUM}|\!important)+(?=[;}])/i
+      STATIC_VALUE = /(-?#{NMSTART.source}|#{STRING_NOINTERP.source}|\s(?!%)|#[a-f0-9]|[,%]|#{NUM.source}|\!important)+(?=[;}])/i
 
-      STATIC_SELECTOR = /(#{NMCHAR}|\s|[,>+*]|[:#.]#{NMSTART})+(?=[{])/i
+      STATIC_SELECTOR = /(#{NMCHAR.source}|\s|[,>+*]|[:#.]#{NMSTART.source})+(?=[{])/i
     end
   end
 end
diff --git a/lib/sass/scss/static_parser.rb b/lib/sass/scss/static_parser.rb
index 5074b71..559603c 100644
--- a/lib/sass/scss/static_parser.rb
+++ b/lib/sass/scss/static_parser.rb
@@ -14,7 +14,7 @@ module Sass
       # @return [Selector::CommaSequence] The parsed selector
       # @raise [Sass::SyntaxError] if there's a syntax error in the selector
       def parse_selector(filename)
-        init_scanner!
+	@tscanner = init_scanner
         seq = expr!(:selector_comma_sequence)
         expected("selector") unless @scanner.eos?
         seq.line = @line
diff --git a/lib/sass/selector.rb b/lib/sass/selector.rb
index 8551803..7571798 100644
--- a/lib/sass/selector.rb
+++ b/lib/sass/selector.rb
@@ -127,16 +127,20 @@ module Sass
       #
       # @see Selector#unify
       def unify(sels)
+	should_exit = false
         name =
           case sels.first
           when Universal; :universal
           when Element; sels.first.name
           else
+	    should_exit = true
             return [self] + sels unless namespace.nil? || namespace == ['*']
             return sels unless sels.empty?
             return [self]
           end
 
+	return name if should_exit
+
         ns, accept = unify_namespaces(namespace, sels.first.namespace)
         return unless accept
         [name == :universal ? Universal.new(ns) : Element.new(name, ns)] + sels[1..-1]
diff --git a/lib/sass/selector/sequence.rb b/lib/sass/selector/sequence.rb
index fef8a93..8265f93 100644
--- a/lib/sass/selector/sequence.rb
+++ b/lib/sass/selector/sequence.rb
@@ -194,9 +194,14 @@ module Sass
         tail = seq.dup
         until tail.empty?
           head = []
-          begin
+	  loop do
             head << tail.shift
-          end while !tail.empty? && head.last.is_a?(String) || tail.first.is_a?(String)
+	    if !tail.empty? && head.last.is_a?(String) || tail.first.is_a?(String)
+	      next
+	    else
+	      break
+	    end
+	  end
           newseq << head
         end
         return newseq
diff --git a/lib/sass/selector/simple_sequence.rb b/lib/sass/selector/simple_sequence.rb
index ce88982..a4d2cb8 100644
--- a/lib/sass/selector/simple_sequence.rb
+++ b/lib/sass/selector/simple_sequence.rb
@@ -71,7 +71,7 @@ module Sass
         end.compact.map do |sels, seq|
           seq = Sequence.new(seq)
           seen.include?(sels) ? [] : seq.do_extend(extends, seen + [sels])
-        end.flatten.uniq
+	end.flatten.uniq{|v| v.to_a.sort.join }
       end
 
       # Unifies this selector with another {SimpleSequence}'s {SimpleSequence#members members array},
diff --git a/lib/sass/shared.rb b/lib/sass/shared.rb
index f53c7c6..c33879d 100644
--- a/lib/sass/shared.rb
+++ b/lib/sass/shared.rb
@@ -43,7 +43,7 @@ module Sass
       scanner = StringScanner.new(scanner) unless scanner.is_a? StringScanner
       regexp = Regexp.new("(.*?)[\\#{start.chr}\\#{finish.chr}]", Regexp::MULTILINE)
       while scanner.scan(regexp)
-        str << scanner.matched
+	str += scanner.matched
         count += 1 if scanner.matched[-1] == start
         count -= 1 if scanner.matched[-1] == finish
         return [str.strip, scanner.rest] if count == 0
diff --git a/lib/sass/tree/comment_node.rb b/lib/sass/tree/comment_node.rb
index a58bb8f..f9287d2 100644
--- a/lib/sass/tree/comment_node.rb
+++ b/lib/sass/tree/comment_node.rb
@@ -30,7 +30,7 @@ module Sass::Tree
       @silent = silent
       @value = normalize_indentation value
       @loud = @value =~ %r{^(/[\/\*])?!}
-      @value.sub!("#{$1}!", $1.to_s) if @loud
+      @value = @value.sub("#{$1}!", $1.to_s) if @loud
       super()
     end
 
@@ -65,8 +65,8 @@ module Sass::Tree
     private
 
     def normalize_indentation(str)
-      pre = str.split("\n").inject(str[/^[ \t]*/].split("")) do |pre, line|
-        line[/^[ \t]*/].split("").zip(pre).inject([]) do |arr, (a, b)|
+      pre = str.split("\n").inject(str[/^[ \t]*/].split("")) do |p, line|
+	line[/^[ \t]*/].split("").zip(p).inject([]) do |arr, (a, b)|
           break arr if a != b
           arr + [a]
         end
diff --git a/lib/sass/tree/import_node.rb b/lib/sass/tree/import_node.rb
index 98bcfe1..049e19e 100644
--- a/lib/sass/tree/import_node.rb
+++ b/lib/sass/tree/import_node.rb
@@ -55,9 +55,9 @@ module Sass
 
         message = "File to import not found or unreadable: #{@imported_filename}.\n"
         if paths.size == 1
-          message << "Load path: #{paths.first}"
+	  message += "Load path: #{paths.first}"
         else
-          message << "Load paths:\n  " << paths.join("\n  ")
+	  message += "Load paths:\n  " << paths.join("\n  ")
         end
         raise SyntaxError.new(message)
       rescue SyntaxError => e
diff --git a/lib/sass/tree/rule_node.rb b/lib/sass/tree/rule_node.rb
index dd47669..2eacb08 100644
--- a/lib/sass/tree/rule_node.rb
+++ b/lib/sass/tree/rule_node.rb
@@ -1,5 +1,4 @@
 require 'pathname'
-require 'uri'
 
 module Sass::Tree
   # A static node reprenting a CSS rule.
@@ -118,8 +117,8 @@ module Sass::Tree
     #
     # @return [{#to_s => #to_s}]
     def debug_info
-      {:filename => filename && ("file://" + URI.escape(File.expand_path(filename))),
-       :line => self.line}
+      #{:filename => filename && ("file://" + URI.escape(File.expand_path(filename))),
+       #:line => self.line}
     end
 
     private
diff --git a/lib/sass/tree/visitors/base.rb b/lib/sass/tree/visitors/base.rb
index ebbf5fd..c104bad 100644
--- a/lib/sass/tree/visitors/base.rb
+++ b/lib/sass/tree/visitors/base.rb
@@ -33,7 +33,7 @@ module Sass::Tree::Visitors
     # @return [Object] The return value of the `visit_*` method for this node.
     def visit(node)
       method = "visit_#{node_name node}"
-      if self.respond_to?(method)
+      if self.respond_to?(method, true)
         self.send(method, node) {visit_children(node)}
       else
         visit_children(node)
diff --git a/lib/sass/tree/visitors/convert.rb b/lib/sass/tree/visitors/convert.rb
index 5eac1aa..4cd3f53 100644
--- a/lib/sass/tree/visitors/convert.rb
+++ b/lib/sass/tree/visitors/convert.rb
@@ -51,20 +51,20 @@ class Sass::Tree::Visitors::Convert < Sass::Tree::Visitors::Base
   def visit_comment(node)
     content = if @format == :sass
       content = node.value.gsub(/\*\/$/, '').rstrip
-      if content =~ /\A[ \t]/
+      if content =~ /^[ \t]/
         # Re-indent SCSS comments like this:
         #     /* foo
         #   bar
         #       baz */
-        content.gsub!(/^/, '   ')
-        content.sub!(/\A([ \t]*)\/\*/, '/*\1')
+	content = content.lines.map{|l| l.sub(/^/, '   ')}.join
+	content = content.sub(/^([ \t]*)\/\*/, '/*\1')
       end
 
       content =
         unless content.include?("\n")
           content
         else
-          content.gsub!(/\n( \*|\/\/)/, "\n  ")
+	  content = content.gsub(/\n( \*|\/\/)/, "\n  ")
           spaces = content.scan(/\n( *)/).map {|s| s.first.size}.min
           sep = node.silent ? "\n//" : "\n *"
           if spaces >= 2
@@ -74,8 +74,8 @@ class Sass::Tree::Visitors::Convert < Sass::Tree::Visitors::Base
           end
         end
 
-      content.gsub!(/\A\/\*/, '//') if node.silent
-      content.gsub!(/^/, tab_str)
+      content = content.gsub(/^\/\*/, '//') if node.silent
+      content = content.gsub(/^/, tab_str)
       content.rstrip + "\n"
     else
       spaces = ('  ' * [@tabs - node.value[/^ */].size, 0].max)
@@ -83,12 +83,12 @@ class Sass::Tree::Visitors::Convert < Sass::Tree::Visitors::Base
         node.value.gsub(/^[\/ ]\*/, '//').gsub(/ *\*\/$/, '')
       else
         node.value
-      end.gsub(/^/, spaces) + "\n"
+      end.lines.map{|l| l.sub(/^/, spaces)}.join + "\n"
       content
     end
     if node.loud
       if node.silent
-        content.gsub!(%r{^\s*(//!?)}, '//!')
+	content = content.gsub(%r{^\s*(//!?)}, '//!')
       else
         content.sub!(%r{^\s*(/\*)}, '/*!')
       end
@@ -135,9 +135,9 @@ class Sass::Tree::Visitors::Convert < Sass::Tree::Visitors::Base
       end
     str = "#{tab_str}@#{name}"
     str << " #{node.expr.to_sass(@options)}" if node.expr
-    str << yield
+    str += yield
     @is_else = true
-    str << visit(node.else) if node.else
+    str += visit(node.else) if node.else
     str
   ensure
     @is_else = false
@@ -159,13 +159,13 @@ class Sass::Tree::Visitors::Convert < Sass::Tree::Visitors::Base
       else
         '(' + node.args.map do |v, d|
           if d
-            "#{v.to_sass(@options)}: #{d.to_sass(@options)}"
-          else
-            v.to_sass(@options)
-          end
-        end.join(", ") + ')'
+	    "#{v.to_sass(@options)}: #{d.to_sass(@options)}"
+	  else
+	    v.to_sass(@options)
+	  end
+	end.join(", ") + ')'
       end
-          
+
     "#{tab_str}#{@format == :sass ? '=' : '@mixin '}#{dasherize(node.name)}#{args}#{yield}"
   end
 
@@ -192,7 +192,7 @@ class Sass::Tree::Visitors::Convert < Sass::Tree::Visitors::Base
     if @format == :sass
       name = selector_to_sass(node.rule)
       name = "\\" + name if name[0] == ?:
-      name.gsub(/^/, tab_str) + yield
+      return name.lines.map{|l| l.sub(/^/, tab_str)}.join + yield
     elsif @format == :scss
       name = selector_to_scss(node.rule)
       res = name + yield
diff --git a/lib/sass/tree/visitors/perform.rb b/lib/sass/tree/visitors/perform.rb
index fa6b35a..c6aabeb 100644
--- a/lib/sass/tree/visitors/perform.rb
+++ b/lib/sass/tree/visitors/perform.rb
@@ -54,7 +54,7 @@ class Sass::Tree::Visitors::Perform < Sass::Tree::Visitors::Base
   def visit_comment(node)
     return [] if node.invisible?
     if node.evaluated?
-      node.value.gsub!(/(^|[^\\])\#\{([^}]*)\}/) do |md|
+      node.value = node.value.gsub(/(^|[^\\])\#\{([^}]*)\}/) do |md|
         $1+Sass::Script.parse($2, node.line, 0, node.options).perform(@environment).to_s
       end
       node.value = run_interp([Sass::Script::String.new(node.value)])
@@ -249,8 +249,8 @@ END
     res = node.expr.perform(@environment)
     res = res.value if res.is_a?(Sass::Script::String)
     msg = "WARNING: #{res}\n         "
-    msg << @environment.stack_trace.join("\n         ")
-    msg << "\n"
+    msg += @environment.stack_trace.join("\n         ")
+    msg += "\n"
     Sass::Util.sass_warn msg
     []
   ensure
@@ -294,7 +294,7 @@ END
     end
 
     mixins << node.name
-    msg << "\n" << Sass::Util.enum_cons(mixins, 2).map do |m1, m2|
+    msg += "\n" + Sass::Util.enum_cons(mixins, 2).map do |m1, m2|
       "    #{m1} includes #{m2}"
     end.join("\n")
     raise Sass::SyntaxError.new(msg)
diff --git a/lib/sass/tree/visitors/to_css.rb b/lib/sass/tree/visitors/to_css.rb
index cdca38c..a963af4 100644
--- a/lib/sass/tree/visitors/to_css.rb
+++ b/lib/sass/tree/visitors/to_css.rb
@@ -25,25 +25,15 @@ class Sass::Tree::Visitors::ToCss < Sass::Tree::Visitors::Base
     node.children.each do |child|
       next if child.invisible?
       child_str = visit(child)
-      result << child_str + (node.style == :compressed ? '' : "\n")
+      result += child_str + (node.style == :compressed ? '' : "\n")
     end
-    result.rstrip!
+    result = result.rstrip
     return "" if result.empty?
-    result << "\n"
-    unless Sass::Util.ruby1_8? || result.ascii_only?
-      if node.children.first.is_a?(Sass::Tree::CharsetNode)
-        begin
-          encoding = node.children.first.name
-          # Default to big-endian encoding, because we have to decide somehow
-          encoding << 'BE' if encoding =~ /\Autf-(16|32)\Z/i
-          result = result.encode(Encoding.find(encoding))
-        rescue EncodingError
-        end
-      end
-
-      result = "@charset \"#{result.encoding.name}\";#{
+    result += "\n"
+    unless Sass::Util.ruby1_8? || !(result =~ /[^ -~\n]/)
+      result = "@charset \"UTF-8\";#{
         node.style == :compressed ? '' : "\n"
-      }".encode(result.encoding) + result
+      }" + result
     end
     result
   rescue Sass::SyntaxError => e
@@ -53,13 +43,13 @@ class Sass::Tree::Visitors::ToCss < Sass::Tree::Visitors::Base
 
   def visit_charset(node)
     "@charset \"#{node.name}\";"
-  end 
+  end
 
   def visit_comment(node)
     return if node.invisible?
     spaces = ('  ' * [@tabs - node.value[/^ */].size, 0].max)
 
-    content = node.value.gsub(/^/, spaces).gsub(%r{^(\s*)//(.*)$}) do |md|
+    content = node.value.lines.map{|l| l.sub(/^/, spaces)}.join.gsub(%r{^(\s*)//(.*)$}) do |md|
       "#{$1}/*#{$2} */"
     end
     if content =~ /[^\\]\#\{.*\}/
@@ -70,9 +60,9 @@ Comments will evaluate the contents of interpolations (\#{ ... }) in Sass 3.2.
 Please escape the interpolation by adding a backslash before the hash sign.
 MESSAGE
     elsif content =~ /\\\#\{.*\}/
-      content.gsub!(/\\(\#\{.*\})/, '\1')
+      content = content.gsub(/\\(\#\{.*\})/, '\1')
     end
-    content.gsub!(/\n +(\* *(?!\/))?/, ' ') if (node.style == :compact || node.style == :compressed) && !node.loud
+    content = content.gsub(/\n +(\* *(?!\/))?/, ' ') if (node.style == :compact || node.style == :compressed) && !node.loud
     content
   end
 
@@ -90,20 +80,20 @@ MESSAGE
       next if child.invisible?
       if node.style == :compact
         if child.is_a?(Sass::Tree::PropNode)
-          with_tabs(first || was_prop ? 0 : @tabs + 1) {result << visit(child) << ' '}
+	  with_tabs(first || was_prop ? 0 : @tabs + 1) {result += visit(child) + ' '}
         else
-          result[-1] = "\n" if was_prop
+	  result = result[0...-1] + "\n" if was_prop
           rendered = with_tabs(@tabs + 1) {visit(child).dup}
           rendered = rendered.lstrip if first
-          result << rendered.rstrip + "\n"
+	  result += rendered.rstrip + "\n"
         end
         was_prop = child.is_a?(Sass::Tree::PropNode)
         first = false
       elsif node.style == :compressed
-        result << (was_prop ? ";" : "") << with_tabs(0) {visit(child)}
+	result += (was_prop ? ";" : "") + with_tabs(0) {visit(child)}
         was_prop = child.is_a?(Sass::Tree::PropNode)
       else
-        result << with_tabs(@tabs + 1) {visit(child)} + "\n"
+	result += with_tabs(@tabs + 1) {visit(child)} + "\n"
       end
     end
     result.rstrip + if node.style == :compressed
@@ -115,7 +105,9 @@ MESSAGE
 
   def visit_media(node)
     str = with_tabs(@tabs + node.tabs) {visit_directive(node)}
-    str.gsub!(/\n\Z/, '') unless node.style == :compressed || node.group_end
+    unless node.style == :compressed || node.group_end
+      str = str[0..-2] if str[-1] == "\n"
+    end
     str
   end
 
@@ -142,26 +134,26 @@ MESSAGE
 
       joined_rules = node.resolved_rules.members.map do |seq|
         rule_part = seq.to_a.join
-        rule_part.gsub!(/\s*([^,])\s*\n\s*/m, '\1 ') if node.style == :compressed
+        rule_part = rule_part.gsub(/\s*([^,])\s*\n\s*/m, '\1 ') if node.style == :compressed
         rule_part
       end.join(rule_separator)
 
-      joined_rules.sub!(/\A\s*/, per_rule_indent)
-      joined_rules.gsub!(/\s*\n\s*/, "#{line_separator}#{per_rule_indent}")
-      total_rule = total_indent << joined_rules
+      joined_rules = joined_rules.sub(/^\s*/, per_rule_indent)
+      joined_rules = joined_rules.gsub(/\s*\n\s*/, "#{line_separator}#{per_rule_indent}")
+      total_rule = total_indent += joined_rules
 
       to_return = ''
       old_spaces = '  ' * @tabs
       spaces = '  ' * (@tabs + 1)
       if node.style != :compressed
         if node.options[:debug_info]
-          to_return << visit(debug_info_rule(node.debug_info, node.options)) << "\n"
+          to_return += visit(debug_info_rule(node.debug_info, node.options)) + "\n"
         elsif node.options[:trace_selectors]
-          to_return << "#{old_spaces}/* "
-          to_return << node.stack_trace.join("\n   #{old_spaces}")
-          to_return << " */\n"
+          to_return += "#{old_spaces}/* "
+          to_return += node.stack_trace.join("\n   #{old_spaces}")
+          to_return += " */\n"
         elsif node.options[:line_comments]
-          to_return << "#{old_spaces}/* line #{node.line}"
+          to_return += "#{old_spaces}/* line #{node.line}"
 
           if node.filename
             relative_filename = if node.options[:css_filename]
@@ -173,23 +165,23 @@ MESSAGE
               end
             end
             relative_filename ||= node.filename
-            to_return << ", #{relative_filename}"
+	    to_return += ", #{relative_filename}"
           end
 
-          to_return << " */\n"
+	  to_return += " */\n"
         end
       end
 
       if node.style == :compact
         properties = with_tabs(0) {node.children.map {|a| visit(a)}.join(' ')}
-        to_return << "#{total_rule} { #{properties} }#{"\n" if node.group_end}"
+	to_return += "#{total_rule} { #{properties} }#{"\n" if node.group_end}"
       elsif node.style == :compressed
         properties = with_tabs(0) {node.children.map {|a| visit(a)}.join(';')}
-        to_return << "#{total_rule}{#{properties}}"
+	to_return += "#{total_rule}{#{properties}}"
       else
         properties = with_tabs(@tabs + 1) {node.children.map {|a| visit(a)}.join("\n")}
         end_props = (node.style == :expanded ? "\n" + old_spaces : ' ')
-        to_return << "#{total_rule} {\n#{properties}#{end_props}}#{"\n" if node.group_end}"
+	to_return += "#{total_rule} {\n#{properties}#{end_props}}#{"\n" if node.group_end}"
       end
 
       to_return
diff --git a/lib/sass/util.rb b/lib/sass/util.rb
index 8370d53..2b4cd8d 100644
--- a/lib/sass/util.rb
+++ b/lib/sass/util.rb
@@ -134,7 +134,7 @@ module Sass
       arr.inject([]) do |a, e|
         if e.is_a?(String)
           if a.last.is_a?(String)
-            a.last << e
+	    a[-1] = a.last + e
           else
             a << e.dup
           end
@@ -179,8 +179,8 @@ module Sass
     # @param arr [Array]
     # @return [Array] `arr`
     def strip_string_array(arr)
-      arr.first.lstrip! if arr.first.is_a?(String)
-      arr.last.rstrip! if arr.last.is_a?(String)
+      arr[0] = arr.first.lstrip if arr.first.is_a?(String)
+      arr[-1] = arr.last.rstrip if arr.last.is_a?(String)
       arr
     end
 
@@ -418,29 +418,7 @@ module Sass
     # @yieldparam msg [String] The error message to be raised
     # @return [String] `str`, potentially with encoding gotchas like BOMs removed
     def check_encoding(str)
-      if ruby1_8?
-        return str.gsub(/\A\xEF\xBB\xBF/, '') # Get rid of the UTF-8 BOM
-      elsif str.valid_encoding?
-        # Get rid of the Unicode BOM if possible
-        if str.encoding.name =~ /^UTF-(8|16|32)(BE|LE)?$/
-          return str.gsub(Regexp.new("\\A\uFEFF".encode(str.encoding.name)), '')
-        else
-          return str
-        end
-      end
-
-      encoding = str.encoding
-      newlines = Regexp.new("\r\n|\r|\n".encode(encoding).force_encoding("binary"))
-      str.force_encoding("binary").split(newlines).each_with_index do |line, i|
-        begin
-          line.encode(encoding)
-        rescue Encoding::UndefinedConversionError => e
-          yield <<MSG.rstrip, i + 1
-Invalid #{encoding.name} character #{e.error_char.dump}
-MSG
-        end
-      end
-      return str
+      str
     end
 
     # Like {\#check\_encoding}, but also checks for a `@charset` declaration
@@ -463,29 +441,7 @@ MSG
     #   cannot be converted to UTF-8
     # @raise [ArgumentError] if the document uses an unknown encoding with `@charset`
     def check_sass_encoding(str, &block)
-      return check_encoding(str, &block), nil if ruby1_8?
-      # We allow any printable ASCII characters but double quotes in the charset decl
-      bin = str.dup.force_encoding("BINARY")
-      encoding = Sass::Util::ENCODINGS_TO_CHECK.find do |enc|
-        bin =~ Sass::Util::CHARSET_REGEXPS[enc]
-      end
-      charset, bom = $1, $2
-      if charset
-        charset = charset.force_encoding(encoding).encode("UTF-8")
-        if endianness = encoding[/[BL]E$/]
-          begin
-            Encoding.find(charset + endianness)
-            charset << endianness
-          rescue ArgumentError # Encoding charset + endianness doesn't exist
-          end
-        end
-        str.force_encoding(charset)
-      elsif bom
-        str.force_encoding(encoding)
-      end
-
-      str = check_encoding(str, &block)
-      return str.encode("UTF-8"), str.encoding
+      return str, str.encoding
     end
 
     unless ruby1_8?
@@ -499,7 +455,7 @@ MSG
       # without manually checking that each encoding
       # encodes all ASCII characters properly,
       # which takes long enough to affect the startup time of the CLI.
-      ENCODINGS_TO_CHECK = %w[UTF-8 UTF-16BE UTF-16LE UTF-32BE UTF-32LE]
+      ENCODINGS_TO_CHECK = %w[UTF-8]
 
       CHARSET_REGEXPS = Hash.new do |h, e|
         h[e] =
diff --git a/lib/sass/version.rb b/lib/sass/version.rb
index 3804f5f..4569a2e 100644
--- a/lib/sass/version.rb
+++ b/lib/sass/version.rb
@@ -1,112 +1,7 @@
-# This is necessary for loading Sass when Haml is required in Rails 3.
-# Once the split is complete, we can remove it.
-require File.dirname(__FILE__) + '/../sass'
-require 'sass/util'
-
 module Sass
-  # Handles Sass version-reporting.
-  # Sass not only reports the standard three version numbers,
-  # but its Git revision hash as well,
-  # if it was installed from Git.
   module Version
-    include Sass::Util
-
-    # Returns a hash representing the version of Sass.
-    # The `:major`, `:minor`, and `:teeny` keys have their respective numbers as Fixnums.
-    # The `:name` key has the name of the version.
-    # The `:string` key contains a human-readable string representation of the version.
-    # The `:number` key is the major, minor, and teeny keys separated by periods.
-    # If Sass is checked out from Git, the `:rev` key will have the revision hash.
-    # For example:
-    #
-    #     {
-    #       :string => "2.1.0.9616393",
-    #       :rev    => "9616393b8924ef36639c7e82aa88a51a24d16949",
-    #       :number => "2.1.0",
-    #       :major  => 2, :minor => 1, :teeny => 0
-    #     }
-    #
-    # If a prerelease version of Sass is being used,
-    # the `:string` and `:number` fields will reflect the full version
-    # (e.g. `"2.2.beta.1"`), and the `:teeny` field will be `-1`.
-    # A `:prerelease` key will contain the name of the prerelease (e.g. `"beta"`),
-    # and a `:prerelease_number` key will contain the rerelease number.
-    # For example:
-    #
-    #     {
-    #       :string => "3.0.beta.1",
-    #       :number => "3.0.beta.1",
-    #       :major => 3, :minor => 0, :teeny => -1,
-    #       :prerelease => "beta",
-    #       :prerelease_number => 1
-    #     }
-    #
-    # @return [{Symbol => String/Fixnum}] The version hash
     def version
-      return @@version if defined?(@@version)
-
-      numbers = File.read(scope('VERSION')).strip.split('.').
-        map {|n| n =~ /^[0-9]+$/ ? n.to_i : n}
-      name = File.read(scope('VERSION_NAME')).strip
-      @@version = {
-        :major => numbers[0],
-        :minor => numbers[1],
-        :teeny => numbers[2],
-        :name => name
-      }
-
-      if numbers[3].is_a?(String)
-        @@version[:teeny] = -1
-        @@version[:prerelease] = numbers[3]
-        @@version[:prerelease_number] = numbers[4]
-      end
-
-      @@version[:number] = numbers.join('.')
-      @@version[:string] = @@version[:number].dup
-
-      if rev = revision_number
-        @@version[:rev] = rev
-        unless rev[0] == ?(
-          @@version[:string] << "." << rev[0...7]
-        end
-      end
-
-      @@version[:string] << " (#{name})"
-      @@version
-    end
-
-    private
-
-    def revision_number
-      if File.exists?(scope('REVISION'))
-        rev = File.read(scope('REVISION')).strip
-        return rev unless rev =~ /^([a-f0-9]+|\(.*\))$/ || rev == '(unknown)'
-      end
-
-      return unless File.exists?(scope('.git/HEAD'))
-      rev = File.read(scope('.git/HEAD')).strip
-      return rev unless rev =~ /^ref: (.*)$/
-
-      ref_name = $1
-      ref_file = scope(".git/#{ref_name}")
-      info_file = scope(".git/info/refs")
-      return File.read(ref_file).strip if File.exists?(ref_file)
-      return unless File.exists?(info_file)
-      File.open(info_file) do |f|
-        f.each do |l|
-          sha, ref = l.strip.split("\t", 2)
-          next unless ref == ref_name
-          return sha
-        end
-      end
-      return nil
+      "3.1.6 (Brainy Betty)"
     end
   end
-
-  extend Sass::Version
-
-  # A string representing the version of Sass.
-  # A more fine-grained representation is available from Sass.version.
-  # @api public
-  VERSION = version[:string] unless defined?(Sass::VERSION)
 end
-- 
2.10.0

