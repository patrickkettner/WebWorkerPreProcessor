From 08a1b1debb79c3d1f7d9ea09e9db98c326bdfe7f Mon Sep 17 00:00:00 2001
From: Patrick Kettner <patrickkettner@gmail.com>
Date: Mon, 9 Jan 2017 04:14:11 -0800
Subject: [PATCH] .

---
 lib/sass.rb                                  |   2 -
 lib/sass/engine.rb                           |  98 ++++++--------
 lib/sass/error.rb                            |  13 +-
 lib/sass/exec.rb                             |   2 +-
 lib/sass/importers/filesystem.rb             |  44 +------
 lib/sass/media.rb                            |  10 +-
 lib/sass/plugin/compiler.rb                  |  45 -------
 lib/sass/script.rb                           |   5 +-
 lib/sass/script/functions.rb                 |   7 +-
 lib/sass/script/lexer.rb                     |  44 ++++---
 lib/sass/script/tree/interpolation.rb        |  24 ++--
 lib/sass/script/tree/string_interpolation.rb |  28 ++--
 lib/sass/script/value/helpers.rb             |   8 +-
 lib/sass/script/value/number.rb              |   4 +-
 lib/sass/scss/parser.rb                      |  48 +++----
 lib/sass/scss/rx.rb                          |  90 +++++++------
 lib/sass/scss/static_parser.rb               |   8 +-
 lib/sass/selector.rb                         |   4 +
 lib/sass/selector/comma_sequence.rb          |   2 +-
 lib/sass/selector/sequence.rb                |   9 +-
 lib/sass/selector/simple_sequence.rb         |   4 +-
 lib/sass/shared.rb                           |   4 +-
 lib/sass/tree/css_import_node.rb             |   2 +-
 lib/sass/tree/import_node.rb                 |   4 +-
 lib/sass/tree/rule_node.rb                   |   2 +-
 lib/sass/tree/visitors/convert.rb            |  40 +++---
 lib/sass/tree/visitors/perform.rb            |  12 +-
 lib/sass/tree/visitors/to_css.rb             |  42 +++---
 lib/sass/util.rb                             | 185 ++++++---------------------
 lib/sass/util/multibyte_string_scanner.rb    |  20 ++-
 lib/sass/version.rb                          | 123 +-----------------
 yard/callbacks.rb                            |   2 +-
 yard/inherited_hash.rb                       |   2 +-
 33 files changed, 332 insertions(+), 605 deletions(-)

diff --git a/lib/sass.rb b/lib/sass.rb
index 3ee4f50..94aeebd 100644
--- a/lib/sass.rb
+++ b/lib/sass.rb
@@ -102,6 +102,4 @@ require 'sass/logger'
 require 'sass/util'
 
 require 'sass/engine'
-require 'sass/plugin' if defined?(Merb::Plugins)
-require 'sass/railtie'
 require 'sass/features'
diff --git a/lib/sass/engine.rb b/lib/sass/engine.rb
index 86eece8..f1b2986 100644
--- a/lib/sass/engine.rb
+++ b/lib/sass/engine.rb
@@ -1,6 +1,4 @@
 require 'set'
-require 'digest/sha1'
-require 'sass/cache_stores'
 require 'sass/source/position'
 require 'sass/source/range'
 require 'sass/source/map'
@@ -170,6 +168,7 @@ module Sass
     # @return [{Symbol => Object}] The normalized options hash.
     # @private
     def self.normalize_options(options)
+       options[:syntax] = options[:syntax].to_sym
       options = DEFAULT_OPTIONS.merge(options.reject {|k, v| v.nil?})
 
       # If the `:filename` option is passed in without an importer,
@@ -179,8 +178,6 @@ module Sass
       # Tracks the original filename of the top-level Sass file
       options[:original_filename] ||= options[:filename]
 
-      options[:cache_store] ||= Sass::CacheStores::Chain.new(
-        Sass::CacheStores::Memory.new, Sass::CacheStores::Filesystem.new(options[:cache_location]))
       # Support both, because the docs said one and the other actually worked
       # for quite a long time.
       options[:line_comments] ||= options[:line_numbers]
@@ -373,7 +370,6 @@ ERR
       rendered << "\n" if rendered[-1] != ?\n
       rendered << "\n" unless compressed
       rendered << "/*# sourceMappingURL="
-      rendered << Sass::Util.escape_uri(sourcemap_uri)
       rendered << " */\n"
       rendered = encode_and_set_charset(rendered)
       return rendered, sourcemap
@@ -382,29 +378,13 @@ ERR
     def encode_and_set_charset(rendered)
       return rendered if Sass::Util.ruby1_8?
       begin
-        # Try to convert the result to the original encoding,
-        # but if that doesn't work fall back on UTF-8
-        rendered = rendered.encode(source_encoding)
+	rendered
       rescue EncodingError
       end
-      rendered.gsub(Regexp.new('\A@charset "(.*?)"'.encode(source_encoding)),
-        "@charset \"#{source_encoding.name}\"".encode(source_encoding))
+      rendered
     end
 
     def _to_tree
-      if (@options[:cache] || @options[:read_cache]) &&
-          @options[:filename] && @options[:importer]
-        key = sassc_key
-        sha = Digest::SHA1.hexdigest(@template)
-
-        if (root = @options[:cache_store].retrieve(key, sha))
-          root.options = @options
-          return root
-        end
-      end
-
-      check_encoding!
-
       if @options[:syntax] == :scss
         root = Sass::SCSS::Parser.new(@template, @options[:filename], @options[:importer]).parse
       else
@@ -413,15 +393,6 @@ ERR
       end
 
       root.options = @options
-      if @options[:cache] && key && sha
-        begin
-          old_options = root.options
-          root.options = {}
-          @options[:cache_store].store(key, sha, root)
-        ensure
-          root.options = old_options
-        end
-      end
       root
     rescue SyntaxError => e
       e.modify_backtrace(:filename => @options[:filename], :line => @line)
@@ -429,10 +400,6 @@ ERR
       raise e
     end
 
-    def sassc_key
-      @options[:cache_store].key(*@options[:importer].key(@options[:filename], @options))
-    end
-
     def check_encoding!
       return if @checked_encoding
       @checked_encoding = true
@@ -449,7 +416,7 @@ ERR
       string.gsub(/\r\n|\r|\n/, "\n").scan(/^[^\n]*?$/).each_with_index do |line, index|
         index += (@options[:line] || 1)
         if line.strip.empty?
-          lines.last.text << "\n" if lines.last && lines.last.comment?
+	  lines.last.text += "\n" if lines.last && lines.last.comment?
           next
         end
 
@@ -513,7 +480,7 @@ MSG
       end
 
       last.comment_tab_str ||= comment_tab_str
-      last.text << "\n" << line
+      last.text += "\n" + line
       true
     end
 
@@ -582,8 +549,9 @@ MSG
           if continued_comment &&
               child.line == continued_comment.line +
               continued_comment.lines + 1
-            continued_comment.value.last.sub!(/ \*\/\Z/, '')
-            child.value.first.gsub!(/\A\/\*/, ' *')
+
+	    continued_comment.value[-1] = continued_comment.value.last.sub(/ \*\/$/, '')
+	    continued_comment.value[0] = child.value.first.gsub(/^\/\*/, ' *')
             continued_comment.value += ["\n"] + child.value
             next
           end
@@ -702,9 +670,10 @@ WARNING
       else
         res.pop if comment
 
-        if (trailing = (scanner.scan(/\s*#{Sass::SCSS::RX::COMMENT}/) ||
-                        scanner.scan(/\s*#{Sass::SCSS::RX::SINGLE_LINE_COMMENT}/)))
-          trailing.strip!
+
+	if (trailing = (scanner.scan(/\s*#{Sass::SCSS::RX::COMMENT.source}/) ||
+			scanner.scan(/\s*#{Sass::SCSS::RX::SINGLE_LINE_COMMENT.source}/)))
+	  trailing = trailing.strip
         end
         interp_parsed = parse_interp(scanner.rest)
         selector_range = Sass::Source::Range.new(
@@ -797,7 +766,11 @@ WARNING
     # @comment
     #   rubocop:disable MethodLength
     def parse_directive(parent, line, root)
-      directive, whitespace, value = line.text[1..-1].split(/(\s+)/, 2)
+      txt = line.text[1..-1]
+      re = /\s+/
+      directive, value = txt.split(re, 2)
+      whitespace = txt.match(re)
+      whitespace = whitespace.to_s unless whitespace.nil?
       raise SyntaxError.new("Invalid directive: '@'.") unless directive
       offset = directive.size + whitespace.size + 1 if whitespace
 
@@ -838,7 +811,9 @@ WARNING
       raise SyntaxError.new("Invalid extend directive '@extend': expected expression.") unless value
       raise SyntaxError.new("Illegal nesting: Nothing may be nested beneath extend directives.",
         :line => @line + 1) unless line.children.empty?
-      optional = !!value.gsub!(/\s+#{Sass::SCSS::RX::OPTIONAL}$/, '')
+      orig_value = value
+      value = value.gsub(/\s+#{Sass::SCSS::RX::OPTIONAL.source}$/, '')
+      optional = value == orig_value
       offset = line.offset + line.text.index(value).to_i
       interp_parsed = parse_interp(value, offset)
       selector_range = Sass::Source::Range.new(
@@ -868,7 +843,7 @@ WARNING
     end
 
     def parse_charset_directive(parent, line, root, value, offset)
-      name = value && value[/\A(["'])(.*)\1\Z/, 2] # "
+      name = value && value[/\^(["'])(.*)\1\$/, 2] # "
       raise SyntaxError.new("Invalid charset directive '@charset': expected string.") unless name
       raise SyntaxError.new("Illegal nesting: Nothing may be nested beneath charset directives.",
         :line => @line + 1) unless line.children.empty?
@@ -949,7 +924,7 @@ WARNING
       end
 
       vars = vars.split(',').map do |var|
-        var.strip!
+	var = var.strip
         raise SyntaxError.new("Invalid variable \"#{var}\".") unless var =~ Script::VALIDATE
         var[1..-1]
       end
@@ -1052,7 +1027,7 @@ WARNING
           Sass::Source::Position.new(@line, to_parser_offset(start_offset)),
           Sass::Source::Position.new(@line, media_parser.offset),
           @options[:filename], @options[:importer])
-      elsif val =~ %r{^(https?:)?//}
+      elsif val =~ /^(https?:)?\/\//
         node = Tree::CssImportNode.new("url(#{val})")
         node.source_range = Sass::Source::Range.new(
           Sass::Source::Position.new(@line, to_parser_offset(start_offset)),
@@ -1074,7 +1049,7 @@ WARNING
       parse_mixin_definition(line)
     end
 
-    MIXIN_DEF_RE = /^(?:=|@mixin)\s*(#{Sass::SCSS::RX::IDENT})(.*)$/
+    MIXIN_DEF_RE = /^(?:=|@mixin)\s*(#{Sass::SCSS::RX::IDENT.source})(.*)$/
     def parse_mixin_definition(line)
       name, arg_string = line.text.scan(MIXIN_DEF_RE).first
       raise SyntaxError.new("Invalid mixin \"#{line.text[1..-1]}\".") if name.nil?
@@ -1101,7 +1076,7 @@ WARNING
       parse_mixin_include(line, root)
     end
 
-    MIXIN_INCLUDE_RE = /^(?:\+|@include)\s*(#{Sass::SCSS::RX::IDENT})(.*)$/
+    MIXIN_INCLUDE_RE = /^(?:\+|@include)\s*(#{Sass::SCSS::RX::IDENT.source})(.*)$/
     def parse_mixin_include(line, root)
       name, arg_string = line.text.scan(MIXIN_INCLUDE_RE).first
       raise SyntaxError.new("Invalid mixin include \"#{line.text}\".") if name.nil?
@@ -1113,7 +1088,7 @@ WARNING
       Tree::MixinNode.new(name, args, keywords, splat, kwarg_splat)
     end
 
-    FUNCTION_RE = /^@function\s*(#{Sass::SCSS::RX::IDENT})(.*)$/
+    FUNCTION_RE = /^@function\s*(#{Sass::SCSS::RX::IDENT.source})(.*)$/
     def parse_function_directive(parent, line, root, value, offset)
       name, arg_string = line.text.scan(FUNCTION_RE).first
       raise SyntaxError.new("Invalid function definition \"#{line.text}\".") if name.nil?
@@ -1139,15 +1114,26 @@ WARNING
       end
 
       return "/* */" if content.empty?
-      content.last.gsub!(/ ?\*\/ *$/, '')
-      content.map! {|l| l.gsub!(/^\*( ?)/, '\1') || (l.empty? ? "" : " ") + l}
-      content.first.gsub!(/^ /, '') unless removed_first
+      content[-1] = content.last.gsub(/ ?\*\/ *$/, '')
+      content = content.map {|l|
+	old_val = l
+	l = l.gsub(/^\*( ?)/, '\1')
+	l = (l.empty? ? "" : " ") + l if l == old_val
+	l
+      }
+      content[0] = content.first.gsub(/^ /, '') unless removed_first
+
       if silent
-        "/*" + content.join("\n *") + " */"
+	res = "/*" + content.join("\n *") + " */"
       else
         # The #gsub fixes the case of a trailing */
-        "/*" + content.join("\n *").gsub(/ \*\Z/, '') + " */"
+	res = "/*" + content.join("\n *");
+	if res[-2..-1] == ' *'
+	  res = res[0...-2]
+	end
+	res += " */"
       end
+      res
     end
 
     def parse_interp(text, offset = 0)
diff --git a/lib/sass/error.rb b/lib/sass/error.rb
index 6331846..5cfb240 100644
--- a/lib/sass/error.rb
+++ b/lib/sass/error.rb
@@ -103,13 +103,17 @@ module Sass
     #
     # @param attrs [{Symbol => Object}] The information to add to the backtrace entry.
     #   See \{#sass\_backtrace}
+    def reject_if_included(attrs, entry)
+      attrs.reject {|k, v| entry.include?(k)}
+    end
+
     def modify_backtrace(attrs)
       attrs = attrs.reject {|k, v| v.nil?}
       # Move backwards through the backtrace
       (0...sass_backtrace.size).to_a.reverse.each do |i|
         entry = sass_backtrace[i]
         sass_backtrace[i] = attrs.merge(entry)
-        attrs.reject! {|k, v| entry.include?(k)}
+	attrs = reject_if_included(attrs, entry)
         break if attrs.empty?
       end
     end
@@ -119,6 +123,11 @@ module Sass
       @message
     end
 
+    def append_to_err (str)
+      @message += str
+      self
+    end
+
     # Returns the standard exception backtrace,
     # including the Sass backtrace.
     #
@@ -172,7 +181,7 @@ Backtrace:\n#{e.backtrace.join("\n").gsub("*/", "*\\/")}
 body:before {
   white-space: pre;
   font-family: monospace;
-  content: "#{header.gsub('"', '\"').gsub("\n", '\\A ')}"; }
+  content: "#{header.gsub('"', '\"').gsub("\n", '\^ ')}"; }
 END
       end
 
diff --git a/lib/sass/exec.rb b/lib/sass/exec.rb
index 0acfa97..0f49c95 100644
--- a/lib/sass/exec.rb
+++ b/lib/sass/exec.rb
@@ -518,7 +518,7 @@ MSG
       def split_colon_path(path)
         one, two = path.split(':', 2)
         if one && two && ::Sass::Util.windows? &&
-            one =~ /\A[A-Za-z]\Z/ && two =~ /\A[\/\\]/
+	    one =~ /^[A-Za-z]$/ && two =~ /^[\/\\]/
           # If we're on Windows and we were passed a drive letter path,
           # don't split on that colon.
           one2, two = two.split(':', 2)
diff --git a/lib/sass/importers/filesystem.rb b/lib/sass/importers/filesystem.rb
index d44a850..b031c23 100644
--- a/lib/sass/importers/filesystem.rb
+++ b/lib/sass/importers/filesystem.rb
@@ -139,49 +139,7 @@ module Sass
       # @param name [String] The filename to search for.
       # @return [(String, Symbol)] A filename-syntax pair.
       def find_real_file(dir, name, options)
-        # On windows 'dir' or 'name' can be in native File::ALT_SEPARATOR form.
-        dir = dir.gsub(File::ALT_SEPARATOR, File::SEPARATOR) unless File::ALT_SEPARATOR.nil?
-        name = name.gsub(File::ALT_SEPARATOR, File::SEPARATOR) unless File::ALT_SEPARATOR.nil?
-
-        found = possible_files(remove_root(name)).map do |f, s|
-          path = (dir == "." || Sass::Util.pathname(f).absolute?) ? f :
-            "#{escape_glob_characters(dir)}/#{f}"
-          Dir[path].map do |full_path|
-            full_path.gsub!(REDUNDANT_DIRECTORY, File::SEPARATOR)
-            [Sass::Util.cleanpath(full_path).to_s, s]
-          end
-        end
-        found = Sass::Util.flatten(found, 1)
-        return if found.empty?
-
-        if found.size > 1 && !@same_name_warnings.include?(found.first.first)
-          found.each {|(f, _)| @same_name_warnings << f}
-          relative_to = Sass::Util.pathname(dir)
-          if options[:_from_import_node]
-            # If _line exists, we're here due to an actual import in an
-            # import_node and we want to print a warning for a user writing an
-            # ambiguous import.
-            candidates = found.map do |(f, _)|
-              "  " + Sass::Util.pathname(f).relative_path_from(relative_to).to_s
-            end.join("\n")
-            raise Sass::SyntaxError.new(<<MESSAGE)
-It's not clear which file to import for '@import "#{name}"'.
-Candidates:
-#{candidates}
-Please delete or rename all but one of these files.
-MESSAGE
-          else
-            # Otherwise, we're here via StalenessChecker, and we want to print a
-            # warning for a user running `sass --watch` with two ambiguous files.
-            candidates = found.map {|(f, _)| "    " + File.basename(f)}.join("\n")
-            Sass::Util.sass_warn <<WARNING
-WARNING: In #{File.dirname(name)}:
-  There are multiple files that match the name "#{File.basename(name)}":
-#{candidates}
-WARNING
-          end
-        end
-        found.first
+	nil
       end
 
       # Splits a filename into three parts, a directory part, a basename, and an extension
diff --git a/lib/sass/media.rb b/lib/sass/media.rb
index 5747eb0..9521663 100644
--- a/lib/sass/media.rb
+++ b/lib/sass/media.rb
@@ -148,11 +148,11 @@ module Sass::Media
     # @return [String]
     def to_css
       css = ''
-      css << resolved_modifier
-      css << ' ' unless resolved_modifier.empty?
-      css << resolved_type
-      css << ' and ' unless resolved_type.empty? || expressions.empty?
-      css << expressions.map do |e|
+      css += resolved_modifier
+      css += ' ' unless resolved_modifier.empty?
+      css += resolved_type
+      css += ' and ' unless resolved_type.empty? || expressions.empty?
+      css += expressions.map do |e|
         # It's possible for there to be script nodes in Expressions even when
         # we're converting to CSS in the case where we parsed the document as
         # CSS originally (as in css_test.rb).
diff --git a/lib/sass/plugin/compiler.rb b/lib/sass/plugin/compiler.rb
index 9626435..ee03d05 100644
--- a/lib/sass/plugin/compiler.rb
+++ b/lib/sass/plugin/compiler.rb
@@ -287,51 +287,6 @@ module Sass::Plugin
     # @option options [Boolean] :skip_initial_update
     #   Don't do an initial update when starting the watcher when true
     def watch(individual_files = [], options = {})
-      options, individual_files = individual_files, [] if individual_files.is_a?(Hash)
-      update_stylesheets(individual_files) unless options[:skip_initial_update]
-
-      directories = watched_paths
-      individual_files.each do |(source, _, _)|
-        directories << File.dirname(File.expand_path(source))
-      end
-      directories = remove_redundant_directories(directories)
-
-      # A Listen version prior to 2.0 will write a test file to a directory to
-      # see if a watcher supports watching that directory. That breaks horribly
-      # on read-only directories, so we filter those out.
-      unless Sass::Util.listen_geq_2?
-        directories = directories.select {|d| File.directory?(d) && File.writable?(d)}
-      end
-
-      # TODO: Keep better track of what depends on what
-      # so we don't have to run a global update every time anything changes.
-      # XXX The :additional_watch_paths option exists for Compass to use until
-      # a deprecated feature is removed. It may be removed without warning.
-      listener_args = directories +
-                      Array(options[:additional_watch_paths]) +
-                      [{:relative_paths => false}]
-
-      # The native windows listener is much slower than the polling option, according to
-      # https://github.com/nex3/sass/commit/a3031856b22bc834a5417dedecb038b7be9b9e3e
-      poll = @options[:poll] || Sass::Util.windows?
-      if poll && Sass::Util.listen_geq_2?
-        # In Listen 2.0.0 and on, :force_polling is an option. In earlier
-        # versions, it's a method on the listener (called below).
-        listener_args.last[:force_polling] = true
-      end
-
-      listener = create_listener(*listener_args) do |modified, added, removed|
-        on_file_changed(individual_files, modified, added, removed)
-        yield(modified, added, removed) if block_given?
-      end
-
-      if poll && !Sass::Util.listen_geq_2?
-        # In Listen 2.0.0 and on, :force_polling is an option (set above). In
-        # earlier versions, it's a method on the listener.
-        listener.force_polling(true)
-      end
-
-      listen_to(listener)
     end
 
     # Non-destructively modifies \{#options} so that default values are properly set,
diff --git a/lib/sass/script.rb b/lib/sass/script.rb
index 5ca639d..e59308e 100644
--- a/lib/sass/script.rb
+++ b/lib/sass/script.rb
@@ -7,11 +7,10 @@ module Sass
   # This module contains code that handles the parsing and evaluation of SassScript.
   module Script
     # The regular expression used to parse variables.
-    MATCH = /^\$(#{Sass::SCSS::RX::IDENT})\s*:\s*(.+?)
-      (!#{Sass::SCSS::RX::IDENT}(?:\s+!#{Sass::SCSS::RX::IDENT})*)?$/x
+    MATCH = /^\$(#{Sass::SCSS::RX::IDENT.source})\s*:\s*(.+?)(!#{Sass::SCSS::RX::IDENT.source}(?:\s+!#{Sass::SCSS::RX::IDENT.source})*)?$/
 
     # The regular expression used to validate variables without matching.
-    VALIDATE = /^\$#{Sass::SCSS::RX::IDENT}$/
+    VALIDATE = /^\$#{Sass::SCSS::RX::IDENT.source}$/
 
     # Parses a string of SassScript
     #
diff --git a/lib/sass/script/functions.rb b/lib/sass/script/functions.rb
index e341217..c116006 100644
--- a/lib/sass/script/functions.rb
+++ b/lib/sass/script/functions.rb
@@ -1406,7 +1406,7 @@ module Sass::Script
                         else
                           [index.value, -original.value.size - 1].max
                         end
-      result = original.value.dup.insert(insertion_point, insert.value)
+      result = original.value.dup.split('').insert(insertion_point, insert.value).join()
       Sass::Script::Value::String.new(result, original.type)
     end
     declare :str_insert, [:string, :insert, :index]
@@ -1893,7 +1893,7 @@ module Sass::Script
     # @return [Sass::Script::Value::Number, Sass::Script::Value::Null] The
     #   1-based index of `$value` in `$list`, or `null`
     def index(list, value)
-      index = list.to_a.index {|e| e.eq(value).to_bool}
+      index = list.to_a.index {|e| e.eq(value).to_bool.to_s === "true"}
       return number(index + 1) if index
       Sass::Script::Value::DeprecatedFalse.new(environment)
     end
@@ -2037,7 +2037,8 @@ module Sass::Script
     # @raise [ArgumentError] if `$args` isn't a variable argument list
     def keywords(args)
       assert_type args, :ArgList, :args
-      map(Sass::Util.map_keys(args.keywords.as_stored) {|k| Sass::Script::Value::String.new(k)})
+      a = args.keywords.as_stored
+      map(Sass::Util.map_keys(a) {|k| Sass::Script::Value::String.new(k)})
     end
     declare :keywords, [:args]
 
diff --git a/lib/sass/script/lexer.rb b/lib/sass/script/lexer.rb
index 60c1432..31dfdd9 100644
--- a/lib/sass/script/lexer.rb
+++ b/lib/sass/script/lexer.rb
@@ -87,15 +87,16 @@ module Sass
         :whitespace => /\s+/,
         :comment => COMMENT,
         :single_line_comment => SINGLE_LINE_COMMENT,
-        :variable => /(\$)(#{IDENT})/,
-        :ident => /(#{IDENT})(\()?/,
+	:variable => /(\$)(#{IDENT.source})/,
+	:ident => /(#{IDENT.source})(\()?/,
         :number => /(?:(\d*\.\d+)|(\d+))([a-zA-Z%]+)?/,
         :unary_minus_number => /-(?:(\d*\.\d+)|(\d+))([a-zA-Z%]+)?/,
         :color => HEXCOLOR,
         :ident_op => /(#{Regexp.union(*IDENT_OP_NAMES.map do |s|
-          Regexp.new(Regexp.escape(s) + "(?!#{NMCHAR}|\Z)")
-        end)})/,
-        :op => /(#{Regexp.union(*OP_NAMES)})/,
+	  Regexp.new(Regexp.escape(s) + "(?!#{NMCHAR.source}|\Z)")
+	end).source})/,
+	:ident_op_pre => /#{IDENT_OP_NAMES.join('|')}/,
+	:op => /(#{Regexp.union(*OP_NAMES).source})/,
       }
 
       class << self
@@ -122,18 +123,18 @@ module Sass
           true => string_re('', "'")
         },
         :uri => {
-          false => /url\(#{W}(#{URLCHAR}*?)(#{W}\)|#\{)/,
-          true => /(#{URLCHAR}*?)(#{W}\)|#\{)/
+	  false => /url\(#{W.source}((?:#{URLCHAR.source})*?)(#{W.source}\)|#\{)/,
+	  true => /((?:#{URLCHAR.source})*?)(#{W.source}\)|#\{)/
         },
         # Defined in https://developer.mozilla.org/en/CSS/@-moz-document as a
         # non-standard version of http://www.w3.org/TR/css3-conditional/
         :url_prefix => {
-          false => /url-prefix\(#{W}(#{URLCHAR}*?)(#{W}\)|#\{)/,
-          true => /(#{URLCHAR}*?)(#{W}\)|#\{)/
+	  false => /url-prefix\(#{W.source}((?:#{URLCHAR.source})*?)(#{W.source}\)|#\{)/,
+	  true => /((?:#{URLCHAR.source})*?)(#{W.source}\)|#\{)/
         },
         :domain => {
-          false => /domain\(#{W}(#{URLCHAR}*?)(#{W}\)|#\{)/,
-          true => /(#{URLCHAR}*?)(#{W}\)|#\{)/
+	  false => /domain\(#{W.source}((?:#{URLCHAR.source})*?)(#{W.source}\)|#\{)/,
+	  true => /((?:#{URLCHAR.source})*?)(#{W.source}\)|#\{)/
         }
       }
 
@@ -168,10 +169,10 @@ module Sass
       # @return [Boolean]
       def whitespace?(tok = @tok)
         if tok
-          @scanner.string[0...tok.pos] =~ /\s\Z/
+	  @scanner.string[0...tok.pos] =~ /\s$/
         else
           @scanner.string[@scanner.pos, 1] =~ /^\s/ ||
-            @scanner.string[@scanner.pos - 1, 1] =~ /\s\Z/
+	    @scanner.string[@scanner.pos - 1, 1] =~ /\s$/
         end
       end
 
@@ -341,7 +342,7 @@ MESSAGE
       def special_fun_body(parens, prefix = nil)
         str = prefix || ''
         while (scanned = scan(/.*?([()]|\#{)/m))
-          str << scanned
+          str += scanned
           if scanned[-1] == ?(
             parens += 1
             next
@@ -350,7 +351,7 @@ MESSAGE
             next unless parens == 0
           else
             raise "[BUG] Unreachable" unless @scanner[1] == '#{' # '
-            str.slice!(-2..-1)
+            str = str.slice(0...-2)
             @scanner.pos -= 2 # Don't actually consume the #{
             @offset -= 2
             @interpolation_stack << [:special_fun, parens]
@@ -369,8 +370,17 @@ MESSAGE
       end
 
       def ident_op
-        op = scan(REGULAR_EXPRESSIONS[:ident_op])
-        return unless op
+	# have to rewrite this entirely because of JS's support of \Z in order
+	# to get the fix in 67a662e3 working
+	return unless op = @scanner.check(REGULAR_EXPRESSIONS[:ident_op_pre])
+
+	orig_position = @scanner.pos
+	@scanner.pos += op.size
+	negative_check = @scanner.check(%r{(?!#{NMCHAR.source})}) != ""
+	@scanner.pos = orig_position
+
+	return if @scanner.eos? or negative_check
+	op = scan(REGULAR_EXPRESSIONS[:ident_op_pre])
         [OPERATORS[op]]
       end
 
diff --git a/lib/sass/script/tree/interpolation.rb b/lib/sass/script/tree/interpolation.rb
index f3013e3..f38ff12 100644
--- a/lib/sass/script/tree/interpolation.rb
+++ b/lib/sass/script/tree/interpolation.rb
@@ -51,13 +51,13 @@ module Sass::Script::Tree
     # @see Node#to_sass
     def to_sass(opts = {})
       res = ""
-      res << @before.to_sass(opts) if @before
-      res << ' ' if @before && @whitespace_before
-      res << '#{' unless @originally_text
-      res << @mid.to_sass(opts)
-      res << '}' unless @originally_text
-      res << ' ' if @after && @whitespace_after
-      res << @after.to_sass(opts) if @after
+      res += @before.to_sass(opts) if @before
+      res += ' ' if @before && @whitespace_before
+      res += '#{' unless @originally_text
+      res += @mid.to_sass(opts)
+      res += '}' unless @originally_text
+      res += ' ' if @after && @whitespace_after
+      res += @after.to_sass(opts) if @after
       res
     end
 
@@ -88,12 +88,12 @@ module Sass::Script::Tree
     #   The SassScript string that is the value of the interpolation
     def _perform(environment)
       res = ""
-      res << @before.perform(environment).to_s if @before
-      res << " " if @before && @whitespace_before
+      res += @before.perform(environment).to_s if @before
+      res += " " if @before && @whitespace_before
       val = @mid.perform(environment)
-      res << (val.is_a?(Sass::Script::Value::String) ? val.value : val.to_s)
-      res << " " if @after && @whitespace_after
-      res << @after.perform(environment).to_s if @after
+      res += (val.is_a?(Sass::Script::Value::String) ? val.value : val.to_s)
+      res += " " if @after && @whitespace_after
+      res += @after.perform(environment).to_s if @after
       opts(Sass::Script::Value::String.new(res))
     end
   end
diff --git a/lib/sass/script/tree/string_interpolation.rb b/lib/sass/script/tree/string_interpolation.rb
index 8e3a30b..a2fc99b 100644
--- a/lib/sass/script/tree/string_interpolation.rb
+++ b/lib/sass/script/tree/string_interpolation.rb
@@ -31,23 +31,23 @@ module Sass::Script::Tree
         (!before_quote_char && after_quote_char && !before_str.empty?)
       quote_char =
         if before_quote_char && after_quote_char && before_quote_char != after_quote_char
-          before_str.gsub!("\\'", "'")
-          before_str.gsub!('"', "\\\"")
-          after_str.gsub!("\\'", "'")
-          after_str.gsub!('"', "\\\"")
+	  before_str = before_str.gsub("\\'", "'")
+	  before_str = before_str.gsub('"', "\\\"")
+	  after_str = after_str.gsub("\\'", "'")
+	  after_str = after_str.gsub('"', "\\\"")
           '"'
         else
           before_quote_char || after_quote_char
         end
 
       res = ""
-      res << 'unquote(' if unquote
-      res << quote_char if quote_char
-      res << before_str
-      res << '#{' << @mid.to_sass(opts) << '}'
-      res << after_str
-      res << quote_char if quote_char
-      res << ')' if unquote
+      res += 'unquote(' if unquote
+      res += quote_char if quote_char
+      res += before_str
+      res += '#{' + @mid.to_sass(opts) + '}'
+      res += after_str
+      res += quote_char if quote_char
+      res += ')' if unquote
       res
     end
 
@@ -79,10 +79,10 @@ module Sass::Script::Tree
     def _perform(environment)
       res = ""
       before = @before.perform(environment)
-      res << before.value
+      res += before.value
       mid = @mid.perform(environment)
-      res << (mid.is_a?(Sass::Script::Value::String) ? mid.value : mid.to_s)
-      res << @after.perform(environment).value
+      res += (mid.is_a?(Sass::Script::Value::String) ? mid.value : mid.to_s)
+      res += @after.perform(environment).value
       opts(Sass::Script::Value::String.new(res, before.type))
     end
 
diff --git a/lib/sass/script/value/helpers.rb b/lib/sass/script/value/helpers.rb
index 619c52e..a096217 100644
--- a/lib/sass/script/value/helpers.rb
+++ b/lib/sass/script/value/helpers.rb
@@ -63,7 +63,7 @@ module Sass::Script::Value
     #
     # @return [Sass::Script::Value::Number] The sass number representing the given ruby number.
     def number(number, unit_string = nil)
-      Number.new(number, *parse_unit_string(unit_string))
+      Sass::Script::Value::Number.new(number, *parse_unit_string(unit_string))
     end
 
     # @overload list(*elements, separator)
@@ -109,7 +109,7 @@ module Sass::Script::Value
     # @param str [::String] A ruby string.
     # @return [Sass::Script::Value::String] A quoted string.
     def quoted_string(str)
-      Sass::Script::String.new(str, :string)
+      Sass::Script::Value::String.new(str, :string)
     end
 
     # Create an unquoted string.
@@ -117,14 +117,14 @@ module Sass::Script::Value
     # @param str [::String] A ruby string.
     # @return [Sass::Script::Value::String] An unquoted string.
     def unquoted_string(str)
-      Sass::Script::String.new(str, :identifier)
+      Sass::Script::Value::String.new(str, :identifier)
     end
     alias_method :identifier, :unquoted_string
 
     private
 
     # @private
-    VALID_UNIT = /#{Sass::SCSS::RX::NMSTART}#{Sass::SCSS::RX::NMCHAR}|%*/
+    VALID_UNIT = /#{Sass::SCSS::RX::NMSTART.source}#{Sass::SCSS::RX::NMCHAR.source}|%*/
 
     # @example
     #   parse_unit_string("em*px/in*%") # => [["em", "px], ["in", "%"]]
diff --git a/lib/sass/script/value/number.rb b/lib/sass/script/value/number.rb
index 26279da..a72212f 100644
--- a/lib/sass/script/value/number.rb
+++ b/lib/sass/script/value/number.rb
@@ -367,8 +367,8 @@ module Sass::Script::Value
     def unit_str
       rv = @numerator_units.sort.join("*")
       if @denominator_units.any?
-        rv << "/"
-        rv << @denominator_units.sort.join("*")
+	rv += "/"
+	rv += @denominator_units.sort.join("*")
       end
       rv
     end
diff --git a/lib/sass/scss/parser.rb b/lib/sass/scss/parser.rb
index fb2f3eb..22003f4 100644
--- a/lib/sass/scss/parser.rb
+++ b/lib/sass/scss/parser.rb
@@ -37,7 +37,7 @@ module Sass
       # @return [Sass::Tree::RootNode] The root node of the document tree
       # @raise [Sass::SyntaxError] if there's a syntax error in the document
       def parse
-        init_scanner!
+	@scanner = init_scanner
         root = stylesheet
         expected("selector or at-rule") unless root && @scanner.eos?
         root
@@ -50,7 +50,7 @@ module Sass
       # @return [Array<String, Sass::Script::Tree::Node>, nil]
       #   The interpolated identifier, or nil if none could be parsed
       def parse_interp_ident
-        init_scanner!
+	@scanner = init_scanner
         interp_ident
       end
 
@@ -60,7 +60,7 @@ module Sass
       # @raise [Sass::SyntaxError] if there's a syntax error in the query list,
       #   or if it doesn't take up the entire input string.
       def parse_media_query_list
-        init_scanner!
+	@scanner = init_scanner
         ql = media_query_list
         expected("media query list") unless ql && @scanner.eos?
         ql
@@ -72,7 +72,7 @@ module Sass
       # @raise [Sass::SyntaxError] if there's a syntax error in the query,
       #   or if it doesn't take up the entire input string.
       def parse_at_root_query
-        init_scanner!
+	@scanner = init_scanner
         query = at_root_query
         expected("@at-root query list") unless query && @scanner.eos?
         query
@@ -84,7 +84,7 @@ module Sass
       # @raise [Sass::SyntaxError] if there's a syntax error in the condition,
       #   or if it doesn't take up the entire input string.
       def parse_supports_condition
-        init_scanner!
+	@scanner = init_scanner
         condition = supports_condition
         expected("supports condition") unless condition && @scanner.eos?
         condition
@@ -102,7 +102,7 @@ module Sass
         Sass::Source::Range.new(start_pos, end_pos, @filename, @importer)
       end
 
-      def init_scanner!
+      def init_scanner
         @scanner =
           if @template.is_a?(StringScanner)
             @template
@@ -146,12 +146,12 @@ module Sass
       end
 
       def process_comment(text, node)
-        silent = text =~ %r{\A//}
-        loud = !silent && text =~ %r{\A/[/*]!}
+	silent = text =~ /^\/\//
+	loud = !silent && text =~ /^\/[\/*]!/
         line = @line - text.count("\n")
 
         if silent
-          value = [text.sub(%r{\A\s*//}, '/*').gsub(%r{^\s*//}, ' *') + ' */']
+	  value = [text.sub(/^\s*\/\//, '/*').gsub(/^\s*\/\//, ' *') + ' */']
         else
           value = Sass::Engine.parse_interp(
             text, line, @scanner.pos - text.size, :filename => @filename)
@@ -389,7 +389,7 @@ module Sass
         ss
 
         media = media_query_list
-        if path =~ %r{^(https?:)?//} || media || use_css_import?
+	if path =~ /^(https?:)?\/\// || media || use_css_import?
           return node(Sass::Tree::CssImportNode.new(str, media.to_a), start_pos)
         end
 
@@ -493,7 +493,7 @@ module Sass
       def _moz_document_directive(start_pos)
         res = ["@-moz-document "]
         loop do
-          res << str {ss} << expr!(:moz_document_function)
+	  wtf_opal res
           if (c = tok(/,/))
             res << c
           else
@@ -503,6 +503,10 @@ module Sass
         directive_body(res.flatten, start_pos)
       end
 
+       def wtf_opal(res)
+	 res << str {ss} << expr!(:moz_document_function)
+       end
+
       def moz_document_function
         val = interp_uri || _interp_string(:url_prefix) ||
           _interp_string(:domain) || function(!:allow_var) || interpolation
@@ -713,7 +717,7 @@ module Sass
 
         ws = ''
         while tok(/,/)
-          ws << str {ss}
+	  ws += str {ss}
           if (v = selector)
             rules << ',' << ws
             rules.concat v
@@ -735,7 +739,7 @@ module Sass
         selectors = [sel]
         ws = ''
         while tok(/,/)
-          ws << str {ss}
+	  ws += str {ss}
           if (sel = _selector)
             selectors << sel
             if ws.include?("\n")
@@ -807,7 +811,7 @@ module Sass
             expected('"{"') if res.length == 1 && res[0].is_a?(Selector::Universal)
             throw_error {expected('"{"')}
           rescue Sass::SyntaxError => e
-            e.message << "\n\n\"#{sel}\" may only be used at the beginning of a compound selector."
+	    e.append_to_err "\n\n\"#{sel}\" may only be used at the beginning of a compound selector."
             raise e
           end
         end
@@ -1105,7 +1109,7 @@ MESSAGE
         # @scanner[2].empty? means we've started an interpolated section
         while @scanner[2] == '#{'
           @scanner.pos -= 2 # Don't consume the #{
-          res.last.slice!(-2..-1)
+	  res[-1] = res.last.slice(0...-2)
           res << expr!(:interpolation) << tok(mid_re)
         end
         res
@@ -1176,7 +1180,7 @@ MESSAGE
         unless @strs.empty?
           # Convert to CSS manually so that comments are ignored.
           src = result.to_sass
-          @strs.each {|s| s << src}
+	  @strs = @strs.map {|s| s += src}
         end
         @line = parser.line
         @offset = parser.offset
@@ -1296,17 +1300,17 @@ MESSAGE
         after = scanner.string[0...pos]
         # Get rid of whitespace between pos and the last token,
         # but only if there's a newline in there
-        after.gsub!(/\s*\n\s*$/, '')
+	after = after.gsub(/\s*\n\s*$/, '')
         # Also get rid of stuff before the last newline
-        after.gsub!(/.*\n/, '')
+	after = after.gsub(/.*\n/, '')
         after = "..." + after[-15..-1] if after.size > 18
 
         was = scanner.rest.dup
         # Get rid of whitespace between pos and the next token,
         # but only if there's a newline in there
-        was.gsub!(/^\s*\n\s*/, '')
+	was = was.gsub(/^\s*\n\s*/, '')
         # Also get rid of stuff after the next newline
-        was.gsub!(/\n.*/, '')
+	was = was.gsub(/\n.*/, '')
         was = was[0...15] + "..." if was.size > 18
 
         raise Sass::SyntaxError.new(
@@ -1330,7 +1334,7 @@ MESSAGE
           # matched group will always occur at the end of the match.
           if last_group_lookahead && @scanner[-1]
             @scanner.pos -= @scanner[-1].length
-            res.slice!(-@scanner[-1].length..-1)
+	    res = res.slice(0...-@scanner[-1].length)
           end
 
           newline_count = res.count(NEWLINE)
@@ -1343,7 +1347,7 @@ MESSAGE
 
           @expected = nil
           if !@strs.empty? && rx != COMMENT && rx != SINGLE_LINE_COMMENT
-            @strs.each {|s| s << res}
+	    @strs = @strs.map {|s| s += res}
           end
           res
         end
diff --git a/lib/sass/scss/rx.rb b/lib/sass/scss/rx.rb
index f252314..87edf39 100644
--- a/lib/sass/scss/rx.rb
+++ b/lib/sass/scss/rx.rb
@@ -15,13 +15,18 @@ module Sass
         return "\\#{str}" if str == '-' || str == '_'
         out = ""
         value = str.dup
-        out << value.slice!(0...1) if value =~ /^[-_]/
+	if value =~ /^[-_]/
+	  out += value.slice(0...1)
+	  value = value.slice(1..-1)
+	end
         if value[0...1] =~ NMSTART
-          out << value.slice!(0...1)
+	  out += value.slice(0...1)
+	  value = value.slice(1..-1)
         else
-          out << escape_char(value.slice!(0...1))
+	  out += escape_char(value.slice(0...1))
+	  value = value.slice(1..-1)
         end
-        out << value.gsub(/[^a-zA-Z0-9_-]/) {|c| escape_char c}
+	out += value.gsub(/[^a-zA-Z0-9_-]/) {|c| escape_char c}
         out
       end
 
@@ -46,42 +51,43 @@ module Sass
         Regexp.new(Regexp.quote(str), flags)
       end
 
+      IS_OPAL = RUBY_PLATFORM.eql? 'opal'
       H        = /[0-9a-fA-F]/
       NL       = /\n|\r\n|\r|\f/
-      UNICODE  = /\\#{H}{1,6}[ \t\r\n\f]?/
-      s = if Sass::Util.ruby1_8?
+      UNICODE  = /\\#{H.source}{1,6}[ \t\r\n\f]?/
+      s = if IS_OPAL
+	    "[\\x80-\\uD7FF\\uDC00-\\uFFFF\]|[\\uD800-\\uDBFF\][\\uDC00-\\uDFFF\]|[\\uD800-\\uDBFF]"
+	  elsif Sass::Util.ruby1_8?
             '\200-\377'
-          elsif Sass::Util.macruby?
-            '\u0080-\uD7FF\uE000-\uFFFD\U00010000-\U0010FFFF'
           else
             '\u{80}-\u{D7FF}\u{E000}-\u{FFFD}\u{10000}-\u{10FFFF}'
           end
-      NONASCII = /[#{s}]/
-      ESCAPE   = /#{UNICODE}|\\[ -~#{s}]/
-      NMSTART  = /[_a-zA-Z]|#{NONASCII}|#{ESCAPE}/
-      NMCHAR   = /[a-zA-Z0-9_-]|#{NONASCII}|#{ESCAPE}/
-      STRING1  = /\"((?:[^\n\r\f\\"]|\\#{NL}|#{ESCAPE})*)\"/
-      STRING2  = /\'((?:[^\n\r\f\\']|\\#{NL}|#{ESCAPE})*)\'/
-
-      IDENT    = /-?#{NMSTART}#{NMCHAR}*/
-      NAME     = /#{NMCHAR}+/
+      NONASCII = IS_OPAL ? /#{s}/ : /[#{s}]/
+      ESCAPE   =  IS_OPAL ? /#{UNICODE.source}|\\(?:[ -~]|#{s})/ : /#{UNICODE.source}|\\[ -~#{s}]/
+      NMSTART  = /[_a-zA-Z]|#{NONASCII.source}|#{ESCAPE.source}/
+      NMCHAR   = /[a-zA-Z0-9_-]|#{NONASCII.source}|#{ESCAPE.source}/
+      STRING1  = /\"((?:[^\n\r\f\\"]|\\#{NL.source}|#{ESCAPE.source})*)\"/
+      STRING2  = /\'((?:[^\n\r\f\\']|\\#{NL.source}|#{ESCAPE.source})*)\'/
+
+      IDENT    = /-?(?:#{NMSTART.source})(?:#{NMCHAR.source})*/
+      NAME     = /(?:#{NMCHAR.source})+/
       NUM      = /[0-9]+|[0-9]*\.[0-9]+/
-      STRING   = /#{STRING1}|#{STRING2}/
-      URLCHAR  = /[#%&*-~]|#{NONASCII}|#{ESCAPE}/
-      URL      = /(#{URLCHAR}*)/
+      STRING   = /#{STRING1.source}|#{STRING2.source}/
+      URLCHAR  = /[#%&*-~]|#{NONASCII.source}|#{ESCAPE.source}/
+      URL      = /((?:#{URLCHAR.source})*)/
       W        = /[ \t\r\n\f]*/
-      VARIABLE = /(\$)(#{Sass::SCSS::RX::IDENT})/
+      VARIABLE = /(\$)(#{Sass::SCSS::RX::IDENT.source})/
 
       # This is more liberal than the spec's definition,
       # but that definition didn't work well with the greediness rules
-      RANGE    = /(?:#{H}|\?){1,6}/
+      RANGE    = /(?:#{H.source}|\?){1,6}/
 
       ##
 
       S = /[ \t\r\n\f]+/
 
-      COMMENT = %r{/\*([^*]|\*+[^/*])*\**\*/}
-      SINGLE_LINE_COMMENT = %r{//.*(\n[ \t]*//.*)*}
+      COMMENT = /\/\*([^*]|\*+[^\/*])*\**\*\//
+      SINGLE_LINE_COMMENT = /\/\/.*(\n[ \t]*\/\/.*)*/
 
       CDO            = quote("<!--")
       CDC            = quote("-->")
@@ -91,42 +97,42 @@ module Sass
       SUFFIXMATCH    = quote("$=")
       SUBSTRINGMATCH = quote("*=")
 
-      HASH = /##{NAME}/
+      HASH = /##{NAME.source}/
 
-      IMPORTANT = /!#{W}important/i
+      IMPORTANT = /!#{W.source}important/i
 
-      NUMBER = /#{NUM}(?:#{IDENT}|%)?/
+      NUMBER = /(?:#{NUM.source})(?:#{IDENT.source}|%)?/
 
-      URI = /url\(#{W}(?:#{STRING}|#{URL})#{W}\)/i
-      FUNCTION = /#{IDENT}\(/
+      URI = /url\(#{W.source}(?:#{STRING.source}|#{URL.source})#{W.source}\)/i
+      FUNCTION = /#{IDENT.source}\(/
 
-      UNICODERANGE = /u\+(?:#{H}{1,6}-#{H}{1,6}|#{RANGE})/i
+      UNICODERANGE = /[uU]\+(?:#{H.source}{1,6}-#{H.source}{1,6}|#{RANGE.source})/
 
       # Defined in http://www.w3.org/TR/css3-selectors/#lex
-      PLUS = /#{W}\+/
-      GREATER = /#{W}>/
-      TILDE = /#{W}~/
+      PLUS = /#{W.source}\+/
+      GREATER = /#{W.source}>/
+      TILDE = /#{W.source}~/
       NOT = quote(":not(", Regexp::IGNORECASE)
 
       # Defined in https://developer.mozilla.org/en/CSS/@-moz-document as a
       # non-standard version of http://www.w3.org/TR/css3-conditional/
-      URL_PREFIX = /url-prefix\(#{W}(?:#{STRING}|#{URL})#{W}\)/i
-      DOMAIN = /domain\(#{W}(?:#{STRING}|#{URL})#{W}\)/i
+      URL_PREFIX = /url-prefix\(#{W.source}(?:#{STRING.source}|#{URL.source})#{W.source}\)/i
+      DOMAIN = /domain\(#{W.source}(?:#{STRING.source}|#{URL.source})#{W.source}\)/i
 
       # Custom
       HEXCOLOR = /\#[0-9a-fA-F]+/
       INTERP_START = /#\{/
       ANY = /:(-[-\w]+-)?any\(/i
-      OPTIONAL = /!#{W}optional/i
+      OPTIONAL = /!#{W.source}optional/i
 
       IDENT_HYPHEN_INTERP = /-(#\{)/
-      STRING1_NOINTERP = /\"((?:[^\n\r\f\\"#]|#(?!\{)|\\#{NL}|#{ESCAPE})*)\"/
-      STRING2_NOINTERP = /\'((?:[^\n\r\f\\'#]|#(?!\{)|\\#{NL}|#{ESCAPE})*)\'/
-      STRING_NOINTERP = /#{STRING1_NOINTERP}|#{STRING2_NOINTERP}/
+      STRING1_NOINTERP = /\"((?:[^\n\r\f\\"#]|#(?!\{)|\\#{NL.source}|#{ESCAPE.source})*)\"/
+      STRING2_NOINTERP = /\'((?:[^\n\r\f\\'#]|#(?!\{)|\\#{NL.source}|#{ESCAPE.source})*)\'/
+      STRING_NOINTERP = /#{STRING1_NOINTERP.source}|#{STRING2_NOINTERP.source}/
 
-      STATIC_COMPONENT = /#{IDENT}|#{STRING_NOINTERP}|#{HEXCOLOR}|[+-]?#{NUMBER}|\!important/i
-      STATIC_VALUE = /#{STATIC_COMPONENT}(\s*[\s,\/]\s*#{STATIC_COMPONENT})*([;}])/i
-      STATIC_SELECTOR = /(#{NMCHAR}|[ \t]|[,>+*]|[:#.]#{NMSTART}){1,50}([{])/i
+      STATIC_COMPONENT = /#{IDENT.source}|#{STRING_NOINTERP.source}|#{HEXCOLOR.source}|[+-]?#{NUMBER.source}|\!important/i
+      STATIC_VALUE = /(?:#{STATIC_COMPONENT.source})(\s*[\s,\/]\s*(?:#{STATIC_COMPONENT.source}))*([;}])/i
+      STATIC_SELECTOR = /(#{NMCHAR.source}|[ \t]|[,>+*]|[:#.]#{NMSTART.source}){1,50}([{])/i
     end
   end
 end
diff --git a/lib/sass/scss/static_parser.rb b/lib/sass/scss/static_parser.rb
index 1ab2b8d..1ae3287 100644
--- a/lib/sass/scss/static_parser.rb
+++ b/lib/sass/scss/static_parser.rb
@@ -16,7 +16,7 @@ module Sass
       # @return [Selector::CommaSequence] The parsed selector
       # @raise [Sass::SyntaxError] if there's a syntax error in the selector
       def parse_selector
-        init_scanner!
+	@scanner = init_scanner
         seq = expr!(:selector_comma_sequence)
         expected("selector") unless @scanner.eos?
         seq.line = @line
@@ -31,7 +31,7 @@ module Sass
       # @raise [Sass::SyntaxError] if there's a syntax error in the query,
       #   or if it doesn't take up the entire input string.
       def parse_static_at_root_query
-        init_scanner!
+	@scanner = init_scanner
         tok!(/\(/); ss
         type = tok!(/\b(without|with)\b/).to_sym; ss
         tok!(/:/); ss
@@ -56,7 +56,9 @@ module Sass
       def var_expr; nil; end
       def interp_string; (s = tok(STRING)) && [s]; end
       def interp_uri; (s = tok(URI)) && [s]; end
-      def interp_ident(ident = IDENT); (s = tok(ident)) && [s]; end
+      def interp_ident(ident = IDENT);
+	(s = tok(ident)) && [s];
+      end
       def use_css_import?; true; end
 
       def special_directive(name, start_pos)
diff --git a/lib/sass/selector.rb b/lib/sass/selector.rb
index 22a7d3f..e12a1b2 100644
--- a/lib/sass/selector.rb
+++ b/lib/sass/selector.rb
@@ -178,16 +178,20 @@ module Sass
       #
       # @see Selector#unify
       def unify(sels)
+	should_exit = false
         name =
           case sels.first
           when Universal; :universal
           when Element; sels.first.name
           else
+	    should_exit = true
             return [self] + sels unless namespace.nil? || namespace == ['*']
             return sels unless sels.empty?
             return [self]
           end
 
+	return name if should_exit
+
         ns, accept = unify_namespaces(namespace, sels.first.namespace)
         return unless accept
         [name == :universal ? Universal.new(ns) : Element.new(name, ns)] + sels[1..-1]
diff --git a/lib/sass/selector/comma_sequence.rb b/lib/sass/selector/comma_sequence.rb
index d5bda88..8bda066 100644
--- a/lib/sass/selector/comma_sequence.rb
+++ b/lib/sass/selector/comma_sequence.rb
@@ -62,7 +62,7 @@ module Sass
           # always contain the base selector.
           #
           # See https://github.com/nex3/sass/issues/324.
-          extended.unshift seq unless seq.has_placeholder? || extended.include?(seq)
+	  extended.unshift seq unless seq.has_placeholder? || extended.any?{ |i| i.to_a.join.eql? seq.to_a.join}
           extended
         end.flatten)
       end
diff --git a/lib/sass/selector/sequence.rb b/lib/sass/selector/sequence.rb
index a0f0087..569544a 100644
--- a/lib/sass/selector/sequence.rb
+++ b/lib/sass/selector/sequence.rb
@@ -388,9 +388,14 @@ module Sass
         tail = seq.dup
         until tail.empty?
           head = []
-          begin
+	  loop do
             head << tail.shift
-          end while !tail.empty? && head.last.is_a?(String) || tail.first.is_a?(String)
+	    if !tail.empty? && head.last.is_a?(String) || tail.first.is_a?(String)
+	      next
+	    else
+	      break
+	    end
+	  end
           newseq << head
         end
         newseq
diff --git a/lib/sass/selector/simple_sequence.rb b/lib/sass/selector/simple_sequence.rb
index 34307fb..b2349ee 100644
--- a/lib/sass/selector/simple_sequence.rb
+++ b/lib/sass/selector/simple_sequence.rb
@@ -162,7 +162,9 @@ module Sass
           seen.include?(sels) ? [] : seq.do_extend(extends, parent_directives, seen + [sels])
         end
         groups.flatten!
-        groups.uniq!
+	groups.uniq! { |v|
+	  v.to_a.slice_before(/ /).to_a.map{|w| w.sort}.uniq
+	}
         groups
       end
 
diff --git a/lib/sass/shared.rb b/lib/sass/shared.rb
index 9e9189c..2c790e0 100644
--- a/lib/sass/shared.rb
+++ b/lib/sass/shared.rb
@@ -15,7 +15,7 @@ module Sass
     # @return [String] The text remaining in the scanner after all `#{`s have been processed
     def handle_interpolation(str)
       scan = Sass::Util::MultibyteStringScanner.new(str)
-      yield scan while scan.scan(/(.*?)(\\*)\#\{/m)
+      yield scan while scan.scan(/([\s\S]*?)(\\*)\#\{/m)
       scan.rest
     end
 
@@ -41,7 +41,7 @@ module Sass
       scanner = Sass::Util::MultibyteStringScanner.new(scanner) unless scanner.is_a? StringScanner
       regexp = Regexp.new("(.*?)[\\#{start.chr}\\#{finish.chr}]", Regexp::MULTILINE)
       while scanner.scan(regexp)
-        str << scanner.matched
+	str += scanner.matched
         count += 1 if scanner.matched[-1] == start
         count -= 1 if scanner.matched[-1] == finish
         return [str, scanner.rest] if count == 0
diff --git a/lib/sass/tree/css_import_node.rb b/lib/sass/tree/css_import_node.rb
index 125ca13..7058e7f 100644
--- a/lib/sass/tree/css_import_node.rb
+++ b/lib/sass/tree/css_import_node.rb
@@ -52,7 +52,7 @@ module Sass::Tree
       @resolved_value ||=
         begin
           str = "@import #{resolved_uri}"
-          str << " #{resolved_query.to_css}" if resolved_query
+	  str += " #{resolved_query.to_css}" if resolved_query
           str
         end
     end
diff --git a/lib/sass/tree/import_node.rb b/lib/sass/tree/import_node.rb
index 01dc0a9..e5debc6 100644
--- a/lib/sass/tree/import_node.rb
+++ b/lib/sass/tree/import_node.rb
@@ -57,9 +57,9 @@ module Sass
 
         message = "File to import not found or unreadable: #{@imported_filename}.\n"
         if paths.size == 1
-          message << "Load path: #{paths.first}"
+	  message += "Load path: #{paths.first}"
         else
-          message << "Load paths:\n  " << paths.join("\n  ")
+	  message += "Load paths:\n  " << paths.join("\n  ")
         end
         raise SyntaxError.new(message)
       rescue SyntaxError => e
diff --git a/lib/sass/tree/rule_node.rb b/lib/sass/tree/rule_node.rb
index 9fe2b51..b924469 100644
--- a/lib/sass/tree/rule_node.rb
+++ b/lib/sass/tree/rule_node.rb
@@ -115,7 +115,7 @@ module Sass::Tree
     #
     # @return [{#to_s => #to_s}]
     def debug_info
-      {:filename => filename && ("file://" + Sass::Util.escape_uri(File.expand_path(filename))),
+      {:filename => filename && ("file://" + URI.escape(filename)),
        :line => line}
     end
 
diff --git a/lib/sass/tree/visitors/convert.rb b/lib/sass/tree/visitors/convert.rb
index 7602901..c972019 100644
--- a/lib/sass/tree/visitors/convert.rb
+++ b/lib/sass/tree/visitors/convert.rb
@@ -58,28 +58,28 @@ class Sass::Tree::Visitors::Convert < Sass::Tree::Visitors::Base
     value = interp_to_src(node.value)
     if @format == :sass
       content = value.gsub(/\*\/$/, '').rstrip
-      if content =~ /\A[ \t]/
+      if content =~ /^[ \t]/
         # Re-indent SCSS comments like this:
         #     /* foo
         #   bar
         #       baz */
-        content.gsub!(/^/, '   ')
-        content.sub!(/\A([ \t]*)\/\*/, '/*\1')
+	content = content.lines.map{|l| l.sub(/^/, '   ')}.join
+	content = content.sub(/^([ \t]*)\/\*/, '/*\1')
       end
 
       if content.include?("\n")
-        content.gsub!(/\n \*/, "\n  ")
+	content = content.gsub(/\n \*/, "\n  ")
         spaces = content.scan(/\n( *)/).map {|s| s.first.size}.min
         sep = node.type == :silent ? "\n//" : "\n *"
         if spaces >= 2
-          content.gsub!(/\n  /, sep)
+	  content = content.gsub(/\n  /, sep)
         else
-          content.gsub!(/\n#{' ' * spaces}/, sep)
+	  content = content.gsub(/\n#{' ' * spaces}/, sep)
         end
       end
 
-      content.gsub!(/\A\/\*/, '//') if node.type == :silent
-      content.gsub!(/^/, tab_str)
+      content = content.gsub(/^\/\*/, '//') if node.type == :silent
+      content = content.lines.map{|l| l.sub(/^/, tab_str)}.join
       content = content.rstrip + "\n"
     else
       spaces = (@tab_chars * [@tabs - value[/^ */].size, 0].max)
@@ -98,7 +98,7 @@ class Sass::Tree::Visitors::Convert < Sass::Tree::Visitors::Base
 
   def visit_directive(node)
     res = "#{tab_str}#{interp_to_src(node.value)}"
-    res.gsub!(/^@import \#\{(.*)\}([^}]*)$/, '@import \1\2')
+    res = res.gsub(/^@import \#\{(.*)\}([^}]*)$/, '@import \1\2')
     return res + "#{semi}\n" unless node.has_children
     res + yield + "\n"
   end
@@ -141,10 +141,10 @@ class Sass::Tree::Visitors::Convert < Sass::Tree::Visitors::Base
       end
     @is_else = false
     str = "#{tab_str}@#{name}"
-    str << " #{node.expr.to_sass(@options)}" if node.expr
-    str << yield
+    str += " #{node.expr.to_sass(@options)}" if node.expr
+    str += yield
     @is_else = true
-    str << visit(node.else) if node.else
+    str += visit(node.else) if node.else
     str
   ensure
     @is_else = false
@@ -169,7 +169,7 @@ class Sass::Tree::Visitors::Convert < Sass::Tree::Visitors::Base
     else
       str = "#{tab_str}@import #{node.uri}"
     end
-    str << " #{interp_to_src(node.query)}" unless node.query.empty?
+    str += " #{interp_to_src(node.query)}" unless node.query.empty?
     "#{str}#{semi}\n"
   end
 
@@ -179,7 +179,7 @@ class Sass::Tree::Visitors::Convert < Sass::Tree::Visitors::Base
         ""
       else
         str = '('
-        str << node.args.map do |v, d|
+	str += node.args.map do |v, d|
           if d
             "#{v.to_sass(@options)}: #{d.to_sass(@options)}"
           else
@@ -188,11 +188,11 @@ class Sass::Tree::Visitors::Convert < Sass::Tree::Visitors::Base
         end.join(", ")
 
         if node.splat
-          str << ", " unless node.args.empty?
-          str << node.splat.to_sass(@options) << '...'
+	  str += ", " unless node.args.empty?
+	  str += node.splat.to_sass(@options) + '...'
         end
 
-        str << ')'
+	str += ')'
       end
 
     "#{tab_str}#{@format == :sass ? '=' : '@mixin '}#{dasherize(node.name)}#{args}#{yield}"
@@ -240,13 +240,13 @@ class Sass::Tree::Visitors::Convert < Sass::Tree::Visitors::Base
     if @format == :sass
       name = selector_to_sass(rule)
       name = "\\" + name if name[0] == ?:
-      name.gsub(/^/, tab_str) + yield
+      return name.lines.map{|l| l.sub(/^/, tab_str)}.join + yield
     elsif @format == :scss
       name = selector_to_scss(rule)
       res = name + yield
       if node.children.last.is_a?(Sass::Tree::CommentNode) && node.children.last.type == :silent
-        res.slice!(-3..-1)
-        res << "\n" << tab_str << "}\n"
+	res = res.slice(0...-3)
+	res += "\n" + tab_str + "}\n"
       end
       res
     end
diff --git a/lib/sass/tree/visitors/perform.rb b/lib/sass/tree/visitors/perform.rb
index 5800503..7e8f922 100644
--- a/lib/sass/tree/visitors/perform.rb
+++ b/lib/sass/tree/visitors/perform.rb
@@ -187,7 +187,7 @@ class Sass::Tree::Visitors::Perform < Sass::Tree::Visitors::Base
   def visit_comment(node)
     return [] if node.invisible?
     node.resolved_value = run_interp_no_strip(node.value)
-    node.resolved_value.gsub!(/\\([\\#])/, '\1')
+    node.resolved_value = node.resolved_value.gsub(/\\([\\#])/, '\1')
     node
   end
 
@@ -216,7 +216,7 @@ class Sass::Tree::Visitors::Perform < Sass::Tree::Visitors::Base
         if node.vars.length == 1
           @environment.set_local_var(node.vars.first, value)
         else
-          node.vars.zip(value.to_a) do |(var, sub_value)|
+	  node.vars.zip(value.to_a) do |var, sub_value|
             @environment.set_local_var(var, sub_value || Sass::Script::Value::Null.new)
           end
         end
@@ -421,9 +421,9 @@ class Sass::Tree::Visitors::Perform < Sass::Tree::Visitors::Base
         !env.global_env.global_warning_given.include?(identifier)
       env.global_env.global_warning_given.add(identifier)
       var_expr = "$#{node.name}: #{node.expr.to_sass(env.options)} !global"
-      var_expr << " !default" if node.guarded
+      var_expr += " !default" if node.guarded
       location = "on line #{node.line}"
-      location << " of #{node.filename}" if node.filename
+      location += " of #{node.filename}" if node.filename
       Sass::Util.sass_warn <<WARNING
 DEPRECATION WARNING #{location}:
 Assigning to global variable "$#{node.name}" by default is deprecated.
@@ -450,7 +450,7 @@ WARNING
     res = node.expr.perform(@environment)
     res = res.value if res.is_a?(Sass::Script::Value::String)
     msg = "WARNING: #{res}\n         "
-    msg << @environment.stack.to_s.gsub("\n", "\n         ") << "\n"
+    msg += @environment.stack.to_s.gsub("\n", "\n         ") + "\n"
     Sass::Util.sass_warn msg
     []
   end
@@ -519,7 +519,7 @@ WARNING
     end
 
     files << node.filename << node.imported_file.options[:filename]
-    msg << "\n" << Sass::Util.enum_cons(files, 2).map do |m1, m2|
+    msg += "\n" + Sass::Util.enum_cons(files, 2).map do |m1, m2|
       "    #{m1} imports #{m2}"
     end.join("\n")
     raise Sass::SyntaxError.new(msg)
diff --git a/lib/sass/tree/visitors/to_css.rb b/lib/sass/tree/visitors/to_css.rb
index 61c0a44..b2436c5 100644
--- a/lib/sass/tree/visitors/to_css.rb
+++ b/lib/sass/tree/visitors/to_css.rb
@@ -54,7 +54,8 @@ class Sass::Tree::Visitors::ToCss < Sass::Tree::Visitors::Base
   # Move the output cursor back `chars` characters.
   def erase!(chars)
     return if chars == 0
-    str = @result.slice!(-chars..-1)
+    str = @result.slice(-chars..-1)
+    @result = @result.slice(0...-chars)
     newlines = str.count("\n")
     if newlines > 0
       @line -= newlines
@@ -72,7 +73,7 @@ class Sass::Tree::Visitors::ToCss < Sass::Tree::Visitors::Base
   # accordingly.
   def output(s)
     if @lstrip
-      s = s.gsub(/\A\s+/, "")
+      s = s.gsub(/^\s+/, "")
       @lstrip = false
     end
 
@@ -84,7 +85,7 @@ class Sass::Tree::Visitors::ToCss < Sass::Tree::Visitors::Base
       @offset += s.size
     end
 
-    @result << s
+    @result += s
   end
 
   # Strip all trailing whitespace from the output string.
@@ -103,7 +104,7 @@ class Sass::Tree::Visitors::ToCss < Sass::Tree::Visitors::Base
 
   # Prepend `prefix` to the output string.
   def prepend!(prefix)
-    @result.insert 0, prefix
+    @result = prefix + @result
     return unless @source_mapping
 
     line_delta = prefix.count("\n")
@@ -127,21 +128,12 @@ class Sass::Tree::Visitors::ToCss < Sass::Tree::Visitors::Base
     return "" if @result.empty?
 
     output "\n"
-    return @result if Sass::Util.ruby1_8? || @result.ascii_only?
-
-    if node.children.first.is_a?(Sass::Tree::CharsetNode)
-      begin
-        encoding = node.children.first.name
-        # Default to big-endian encoding, because we have to decide somehow
-        encoding << 'BE' if encoding =~ /\Autf-(16|32)\Z/i
-        @result = @result.encode(Encoding.find(encoding))
-      rescue EncodingError
-      end
-    end
 
-    prepend! "@charset \"#{@result.encoding.name}\";#{
+    unless Sass::Util.ruby1_8? || !(@result =~ /[^ -~\n]/)
+      prepend! "@charset \"UTF-8\";#{
       node.style == :compressed ? '' : "\n"
-    }".encode(@result.encoding)
+      }"
+    end
     @result
   rescue Sass::SyntaxError => e
     e.sass_template ||= node.template
@@ -156,12 +148,12 @@ class Sass::Tree::Visitors::ToCss < Sass::Tree::Visitors::Base
     return if node.invisible?
     spaces = ('  ' * [@tabs - node.resolved_value[/^ */].size, 0].max)
 
-    content = node.resolved_value.gsub(/^/, spaces)
+    content = node.resolved_value.lines.map{|l| l.sub(/^/, spaces)}.join
     if node.type == :silent
-      content.gsub!(%r{^(\s*)//(.*)$}) {|md| "#{$1}/*#{$2} */"}
+      content = content.gsub(/^(\s*)\/\/(.*)$/) {|md| "#{$1}/*#{$2} */"}
     end
     if (node.style == :compact || node.style == :compressed) && node.type != :loud
-      content.gsub!(/\n +(\* *(?!\/))?/, ' ')
+      content = content.gsub(/\n +(\* *(?!\/))?/, ' ')
     end
     for_node(node) {output(content)}
   end
@@ -283,15 +275,15 @@ class Sass::Tree::Visitors::ToCss < Sass::Tree::Visitors::Base
         next if seq.has_placeholder?
         rule_part = seq.to_a.join
         if node.style == :compressed
-          rule_part.gsub!(/([^,])\s*\n\s*/m, '\1 ')
-          rule_part.gsub!(/\s*([,+>])\s*/m, '\1')
-          rule_part.strip!
+	  rule_part = rule_part.gsub(/([^,])\s*\n\s*/m, '\1 ')
+	  rule_part = rule_part.gsub(/\s*([,+>])\s*/m, '\1')
+	  rule_part = rule_part.strip
         end
         rule_part
       end.compact.join(rule_separator)
 
-      joined_rules.lstrip!
-      joined_rules.gsub!(/\s*\n\s*/, "#{line_separator}#{per_rule_indent}")
+      joined_rules = joined_rules.lstrip
+      joined_rules = joined_rules.gsub(/\s*\n\s*/, "#{line_separator}#{per_rule_indent}")
 
       old_spaces = '  ' * @tabs
       if node.style != :compressed
diff --git a/lib/sass/util.rb b/lib/sass/util.rb
index 8821839..fc057e5 100644
--- a/lib/sass/util.rb
+++ b/lib/sass/util.rb
@@ -3,7 +3,6 @@ require 'set'
 require 'enumerator'
 require 'stringio'
 require 'rbconfig'
-require 'uri'
 require 'thread'
 require 'pathname'
 
@@ -151,7 +150,7 @@ module Sass
       arr.inject([]) do |a, e|
         if e.is_a?(String)
           if a.last.is_a?(String)
-            a.last << e
+	    a[-1] = a.last + e
           else
             a << e.dup
           end
@@ -246,8 +245,8 @@ module Sass
     # @param arr [Array]
     # @return [Array] `arr`
     def strip_string_array(arr)
-      arr.first.lstrip! if arr.first.is_a?(String)
-      arr.last.rstrip! if arr.last.is_a?(String)
+      arr[0] = arr.first.lstrip if arr.first.is_a?(String)
+      arr[-1] = arr.last.rstrip if arr.last.is_a?(String)
       arr
     end
 
@@ -296,8 +295,7 @@ module Sass
     # @param hash [Hash]
     # @return [Array]
     def hash_to_a(hash)
-      return hash.to_a unless ruby1_8? || defined?(Test::Unit)
-      hash.sort_by {|k, v| k}
+      return hash.to_a
     end
 
     # Performs the equivalent of `enum.group_by.to_a`, but with a guaranteed
@@ -396,12 +394,20 @@ module Sass
     #   The method name may be nil
     def caller_info(entry = nil)
       # JRuby evaluates `caller` incorrectly when it's in an actual default argument.
-      entry ||= caller[1]
-      info = entry.scan(/^(.*?):(-?.*?)(?::.*`(.+)')?$/).first
-      info[1] = info[1].to_i
-      # This is added by Rubinius to designate a block, but we don't care about it.
-      info[2].sub!(/ \{\}\Z/, '') if info[2]
-      info
+      if RUBY_PLATFORM.eql? 'opal'
+	%x{
+	  var func_name = $$caller_info.caller.caller.name;
+	  func_name = func_name.replace(/^\$+/, '')
+	  return [func_name, 0, func_name]
+	}
+      else
+	entry ||= caller[1]
+	info = entry.scan(/^(.*?):(-?.*?)(?::.*`(.+)')?$/).first
+	info[1] = info[1].to_i
+	# This is added by Rubinius to designate a block, but we don't care about it.
+	info[0] = info[2].sub(/ \{\}$/, '') if info[2]
+	info
+      end
     end
 
     # Returns whether one version string represents a more recent version than another.
@@ -544,14 +550,7 @@ module Sass
     #
     # @return [Boolean]
     def listen_geq_2?
-      return @listen_geq_2 unless @listen_geq_2.nil?
-      @listen_geq_2 =
-        begin
-          require 'listen/version'
-          version_geq(::Listen::VERSION, '2.0.0')
-        rescue LoadError
-          false
-        end
+      false
     end
 
     # Returns an ActionView::Template* class.
@@ -762,28 +761,6 @@ module Sass
     # @yieldparam msg [String] The error message to be raised
     # @return [String] `str`, potentially with encoding gotchas like BOMs removed
     def check_encoding(str)
-      if ruby1_8?
-        return str.gsub(/\A\xEF\xBB\xBF/, '') # Get rid of the UTF-8 BOM
-      elsif str.valid_encoding?
-        # Get rid of the Unicode BOM if possible
-        if str.encoding.name =~ /^UTF-(8|16|32)(BE|LE)?$/
-          return str.gsub(Regexp.new("\\A\uFEFF".encode(str.encoding.name)), '')
-        else
-          return str
-        end
-      end
-
-      encoding = str.encoding
-      newlines = Regexp.new("\r\n|\r|\n".encode(encoding).force_encoding("binary"))
-      str.force_encoding("binary").split(newlines).each_with_index do |line, i|
-        begin
-          line.encode(encoding)
-        rescue Encoding::UndefinedConversionError => e
-          yield <<MSG.rstrip, i + 1
-Invalid #{encoding.name} character #{undefined_conversion_error_char(e)}
-MSG
-        end
-      end
       str
     end
 
@@ -807,30 +784,7 @@ MSG
     #   cannot be converted to UTF-8
     # @raise [ArgumentError] if the document uses an unknown encoding with `@charset`
     def check_sass_encoding(str, &block)
-      return check_encoding(str, &block), nil if ruby1_8?
-      # We allow any printable ASCII characters but double quotes in the charset decl
-      bin = str.dup.force_encoding("BINARY")
-      encoding = Sass::Util::ENCODINGS_TO_CHECK.find do |enc|
-        re = Sass::Util::CHARSET_REGEXPS[enc]
-        re && bin =~ re
-      end
-      charset, bom = $1, $2
-      if charset
-        charset = charset.force_encoding(encoding).encode("UTF-8")
-        if (endianness = encoding[/[BL]E$/])
-          begin
-            Encoding.find(charset + endianness)
-            charset << endianness
-          rescue ArgumentError # Encoding charset + endianness doesn't exist
-          end
-        end
-        str.force_encoding(charset)
-      elsif bom
-        str.force_encoding(encoding)
-      end
-
-      str = check_encoding(str, &block)
-      return str.encode("UTF-8"), str.encoding
+      return str, str.encoding
     end
 
     unless ruby1_8?
@@ -844,20 +798,20 @@ MSG
       # without manually checking that each encoding
       # encodes all ASCII characters properly,
       # which takes long enough to affect the startup time of the CLI.
-      ENCODINGS_TO_CHECK = %w[UTF-8 UTF-16BE UTF-16LE UTF-32BE UTF-32LE]
+      ENCODINGS_TO_CHECK = %w[UTF-8]
 
       CHARSET_REGEXPS = Hash.new do |h, e|
         h[e] =
           begin
-            # /\A(?:\uFEFF)?@charset "(.*?)"|\A(\uFEFF)/
-            Regexp.new(/\A(?:#{_enc("\uFEFF", e)})?#{
-              _enc('@charset "', e)}(.*?)#{_enc('"', e)}|\A(#{
+	    # /^(?:\uFEFF)?@charset "(.*?)"|^(\uFEFF)/
+	    Regexp.new(/^(?:#{_enc("\uFEFF", e)})?#{
+	_enc('@charset "', e)}(.*?)#{_enc('"', e)}|^(#{
               _enc("\uFEFF", e)})/)
           rescue Encoding::ConverterNotFoundError => _
             nil # JRuby on Java 5 doesn't support UTF-32
           rescue
-            # /\A@charset "(.*?)"/
-            Regexp.new(/\A#{_enc('@charset "', e)}(.*?)#{_enc('"', e)}/)
+	    # /^@charset "(.*?)"/
+	    Regexp.new(/^#{_enc('@charset "', e)}(.*?)#{_enc('"', e)}/)
           end
       end
     end
@@ -1027,7 +981,7 @@ MSG
     def inject_values(str, values)
       return [str.gsub('{{', '{')] if values.empty?
       # Add an extra { so that we process the tail end of the string
-      result = (str + '{{').scan(/(.*?)(?:(\{\{)|\{(\d+)\})/m).map do |(pre, esc, n)|
+      result = (str + '{{').scan(/([\s\S]*?)(?:(\{\{)|\{(\d+)\})/m).map do |(pre, esc, n)|
         [pre, esc ? '{' : '', n ? values[n.to_i] : '']
       end.flatten(1)
       result[-2] = '' # Get rid of the extra {
@@ -1069,14 +1023,14 @@ MSG
       s.split("").each do |c|
         case c
         when '"', "\\"
-          result << "\\" << c
-        when "\n" then result << "\\n"
-        when "\t" then result << "\\t"
-        when "\r" then result << "\\r"
-        when "\f" then result << "\\f"
-        when "\b" then result << "\\b"
+	  result += "\\" + c
+	when "\n" then result += "\\n"
+	when "\t" then result += "\\t"
+	when "\r" then result += "\\r"
+	when "\f" then result += "\\f"
+	when "\b" then result += "\\b"
         else
-          result << c
+	  result += c
         end
       end
       result
@@ -1096,9 +1050,9 @@ MSG
         "[" + v.map {|x| json_value_of(x)}.join(",") + "]"
       when NilClass
         "null"
-      when TrueClass
+      when TRUE
         "true"
-      when FalseClass
+      when FALSE
         "false"
       else
         raise ArgumentError.new("Unknown type: #{v.class.name}")
@@ -1131,14 +1085,15 @@ MSG
       end
 
       result = ''
-      begin
+      loop do
         digit = value & VLQ_BASE_MASK
         value >>= VLQ_BASE_SHIFT
         if value > 0
           digit |= VLQ_CONTINUATION_BIT
         end
-        result << BASE64_DIGITS[digit]
-      end while value > 0
+	result += BASE64_DIGITS[digit]
+      break unless value > 0
+      end
       result
     end
 
@@ -1147,14 +1102,12 @@ MSG
     # support is dropped, we can remove this method.
     #
     # @private
-    URI_ESCAPE = URI.const_defined?("DEFAULT_PARSER") ? URI::DEFAULT_PARSER : URI
 
     # URI-escape `string`.
     #
     # @param string [String]
     # @return [String]
     def escape_uri(string)
-      URI_ESCAPE.escape string
     end
 
     # A cross-platform implementation of `File.absolute_path`.
@@ -1206,64 +1159,10 @@ MSG
     # @yieldparam tmpfile [Tempfile] The temp file that can be written to.
     # @return The value returned by the block.
     def atomic_create_and_write_file(filename, perms = 0666)
-      require 'tempfile'
-      tmpfile = Tempfile.new(File.basename(filename), File.dirname(filename))
-      tmpfile.binmode if tmpfile.respond_to?(:binmode)
-      result = yield tmpfile
-      tmpfile.close
-      ATOMIC_WRITE_MUTEX.synchronize do
-        begin
-          File.chmod(perms & ~File.umask, tmpfile.path)
-        rescue Errno::EPERM
-          # If we don't have permissions to chmod the file, don't let that crash
-          # the compilation. See issue 1215.
-        end
-        File.rename tmpfile.path, filename
-      end
-      result
-    ensure
-      # close and remove the tempfile if it still exists,
-      # presumably due to an error during write
-      tmpfile.close if tmpfile
-      tmpfile.unlink if tmpfile
+      nil
     end
 
     def load_listen!
-      if defined?(gem)
-        begin
-          gem 'listen', '>= 1.1.0', '< 3.0.0'
-          require 'listen'
-        rescue Gem::LoadError
-          dir = scope("vendor/listen/lib")
-          $LOAD_PATH.unshift dir
-          begin
-            require 'listen'
-          rescue LoadError => e
-            if version_geq(RUBY_VERSION, "1.9.3")
-              version_constraint = "~> 2.7"
-            else
-              version_constraint = "~> 1.1"
-            end
-            e.message << "\n" <<
-              "Run \"gem install listen --version '#{version_constraint}'\" to get it."
-            raise e
-          end
-        end
-      else
-        begin
-          require 'listen'
-        rescue LoadError => e
-          dir = scope("vendor/listen/lib")
-          if $LOAD_PATH.include?(dir)
-            raise e unless File.exist?(scope(".git"))
-            e.message << "\n" <<
-              'Run "git submodule update --init" to get the bundled version.'
-          else
-            $LOAD_PATH.unshift dir
-            retry
-          end
-        end
-      end
     end
 
     private
@@ -1305,7 +1204,7 @@ MSG
       lcs_backtrace(c, x, y, i - 1, j, &block)
     end
 
-    singleton_methods.each {|method| module_function method}
+    #singleton_methods.each {|method| module_function method}
   end
 end
 
diff --git a/lib/sass/util/multibyte_string_scanner.rb b/lib/sass/util/multibyte_string_scanner.rb
index 6675aa5..64011ac 100644
--- a/lib/sass/util/multibyte_string_scanner.rb
+++ b/lib/sass/util/multibyte_string_scanner.rb
@@ -43,11 +43,23 @@ else
       super
     end
 
-    alias_method :byte_pos, :pos
+
+    if RUBY_PLATFORM.eql? 'opal'
+      def byte_pos
+	%x{ utf8.encode(self.string.slice(0, #@mb_pos)).length}
+      end
+    else
+      alias_method :byte_pos, :pos
+    end
     alias_method :byte_matched_size, :matched_size
 
     def check(pattern); _match super; end
-    def check_until(pattern); _matched super; end
+    def check_until(pattern);
+      last_pos = @mb_pos
+      ret = _matched super;
+      @mb_pos = last_pos
+      ret
+    end
     def getch; _forward _match super; end
     def match?(pattern); _size check(pattern); end
     def matched_size; @mb_matched_size; end
@@ -81,7 +93,9 @@ else
       # if the new position is close to the current one, just count the
       # characters between the two; if the new position is closer to the
       # beginning of the string, just count the characters from there.
-      if @mb_pos - n < @mb_pos / 2
+      if RUBY_PLATFORM.eql? 'opal'
+	super(n)
+      elsif @mb_pos - n < @mb_pos / 2
         # New position is close to old position
         byte_delta = @mb_pos > n ? -string[n...@mb_pos].bytesize : string[@mb_pos...n].bytesize
         super(byte_pos + byte_delta)
diff --git a/lib/sass/version.rb b/lib/sass/version.rb
index 89c8a06..9a26816 100644
--- a/lib/sass/version.rb
+++ b/lib/sass/version.rb
@@ -1,124 +1,7 @@
-require 'date'
-require 'sass/util'
-
+A="3.3.14 (Maptastic Maple)"
 module Sass
-  # Handles Sass version-reporting.
-  # Sass not only reports the standard three version numbers,
-  # but its Git revision hash as well,
-  # if it was installed from Git.
   module Version
-    # Returns a hash representing the version of Sass.
-    # The `:major`, `:minor`, and `:teeny` keys have their respective numbers as Fixnums.
-    # The `:name` key has the name of the version.
-    # The `:string` key contains a human-readable string representation of the version.
-    # The `:number` key is the major, minor, and teeny keys separated by periods.
-    # The `:date` key, which is not guaranteed to be defined, is the `DateTime`
-    #   at which this release was cut.
-    # If Sass is checked out from Git, the `:rev` key will have the revision hash.
-    # For example:
-    #
-    #     {
-    #       :string => "2.1.0.9616393",
-    #       :rev    => "9616393b8924ef36639c7e82aa88a51a24d16949",
-    #       :number => "2.1.0",
-    #       :date   => DateTime.parse("Apr 30 13:52:01 2009 -0700"),
-    #       :major  => 2, :minor => 1, :teeny => 0
-    #     }
-    #
-    # If a prerelease version of Sass is being used,
-    # the `:string` and `:number` fields will reflect the full version
-    # (e.g. `"2.2.beta.1"`), and the `:teeny` field will be `-1`.
-    # A `:prerelease` key will contain the name of the prerelease (e.g. `"beta"`),
-    # and a `:prerelease_number` key will contain the rerelease number.
-    # For example:
-    #
-    #     {
-    #       :string => "3.0.beta.1",
-    #       :number => "3.0.beta.1",
-    #       :date   => DateTime.parse("Mar 31 00:38:04 2010 -0700"),
-    #       :major => 3, :minor => 0, :teeny => -1,
-    #       :prerelease => "beta",
-    #       :prerelease_number => 1
-    #     }
-    #
-    # @return [{Symbol => String/Fixnum}] The version hash
-    # @comment
-    #   rubocop:disable ClassVars
-    def version
-      return @@version if defined?(@@version)
-
-      numbers = File.read(Sass::Util.scope('VERSION')).strip.split('.').
-        map {|n| n =~ /^[0-9]+$/ ? n.to_i : n}
-      name = File.read(Sass::Util.scope('VERSION_NAME')).strip
-      @@version = {
-        :major => numbers[0],
-        :minor => numbers[1],
-        :teeny => numbers[2],
-        :name => name
-      }
-
-      if (date = version_date)
-        @@version[:date] = date
-      end
-
-      if numbers[3].is_a?(String)
-        @@version[:teeny] = -1
-        @@version[:prerelease] = numbers[3]
-        @@version[:prerelease_number] = numbers[4]
-      end
-
-      @@version[:number] = numbers.join('.')
-      @@version[:string] = @@version[:number].dup
-
-      if (rev = revision_number)
-        @@version[:rev] = rev
-        unless rev[0] == ?(
-          @@version[:string] << "." << rev[0...7]
-        end
-      end
-
-      @@version[:string] << " (#{name})"
-      @@version
-    end
-    # rubocop:enable ClassVars
-
-    private
-
-    def revision_number
-      if File.exist?(Sass::Util.scope('REVISION'))
-        rev = File.read(Sass::Util.scope('REVISION')).strip
-        return rev unless rev =~ /^([a-f0-9]+|\(.*\))$/ || rev == '(unknown)'
-      end
-
-      return unless File.exist?(Sass::Util.scope('.git/HEAD'))
-      rev = File.read(Sass::Util.scope('.git/HEAD')).strip
-      return rev unless rev =~ /^ref: (.*)$/
-
-      ref_name = $1
-      ref_file = Sass::Util.scope(".git/#{ref_name}")
-      info_file = Sass::Util.scope(".git/info/refs")
-      return File.read(ref_file).strip if File.exist?(ref_file)
-      return unless File.exist?(info_file)
-      File.open(info_file) do |f|
-        f.each do |l|
-          sha, ref = l.strip.split("\t", 2)
-          next unless ref == ref_name
-          return sha
-        end
-      end
-      nil
-    end
-
-    def version_date
-      return unless File.exist?(Sass::Util.scope('VERSION_DATE'))
-      DateTime.parse(File.read(Sass::Util.scope('VERSION_DATE')).strip)
-    end
+    A
   end
-
-  extend Sass::Version
-
-  # A string representing the version of Sass.
-  # A more fine-grained representation is available from Sass.version.
-  # @api public
-  VERSION = version[:string] unless defined?(Sass::VERSION)
+  VERSION = A
 end
diff --git a/yard/callbacks.rb b/yard/callbacks.rb
index d826e46..f0bd12c 100644
--- a/yard/callbacks.rb
+++ b/yard/callbacks.rb
@@ -1,5 +1,5 @@
 class CallbacksHandler < YARD::Handlers::Ruby::Legacy::Base
-  handles /\Adefine_callback(\s|\()/
+  handles /^define_callback(\s|\()/
 
   def process
     callback_name = tokval(statement.tokens[2])
diff --git a/yard/inherited_hash.rb b/yard/inherited_hash.rb
index f990aac..3f8cb01 100644
--- a/yard/inherited_hash.rb
+++ b/yard/inherited_hash.rb
@@ -1,5 +1,5 @@
 class InheritedHashHandler < YARD::Handlers::Ruby::Legacy::Base
-  handles /\Ainherited_hash(\s|\()/
+  handles /^inherited_hash(\s|\()/
 
   def process
     hash_name = tokval(statement.tokens[2])
-- 
2.10.0

