From 64ca6e66dcd41d9d9fce511c9eef7909f3e8cf7f Mon Sep 17 00:00:00 2001
From: Patrick Kettner <patrickkettner@gmail.com>
Date: Tue, 20 Dec 2016 01:30:58 -0500
Subject: [PATCH] .

---
 lib/sass/engine.rb                        |  73 ++++++++------------
 lib/sass/environment.rb                   |  14 ++--
 lib/sass/error.rb                         |  11 ++-
 lib/sass/importers/filesystem.rb          |   7 --
 lib/sass/less.rb                          |   2 +-
 lib/sass/plugin/compiler.rb               |  76 ---------------------
 lib/sass/script.rb                        |   5 +-
 lib/sass/script/interpolation.rb          |  24 +++----
 lib/sass/script/lexer.rb                  |  29 +++++---
 lib/sass/script/number.rb                 |   4 +-
 lib/sass/script/parser.rb                 |   3 +-
 lib/sass/script/string_interpolation.rb   |  28 ++++----
 lib/sass/scss/css_parser.rb               |   2 +-
 lib/sass/scss/parser.rb                   |  55 +++++++++------
 lib/sass/scss/rx.rb                       |  83 ++++++++++++----------
 lib/sass/scss/static_parser.rb            |   2 +-
 lib/sass/selector.rb                      |   4 ++
 lib/sass/selector/sequence.rb             |   9 ++-
 lib/sass/selector/simple_sequence.rb      |   2 +-
 lib/sass/shared.rb                        |   4 +-
 lib/sass/tree/comment_node.rb             |   4 +-
 lib/sass/tree/import_node.rb              |   4 +-
 lib/sass/tree/rule_node.rb                |   2 +-
 lib/sass/tree/visitors/convert.rb         |  42 ++++++------
 lib/sass/tree/visitors/perform.rb         |  10 +--
 lib/sass/tree/visitors/to_css.rb          |  72 +++++++++----------
 lib/sass/util.rb                          |  67 +++---------------
 lib/sass/util/multibyte_string_scanner.rb |  15 +++-
 lib/sass/version.rb                       | 110 +-----------------------------
 29 files changed, 283 insertions(+), 480 deletions(-)

diff --git a/lib/sass/engine.rb b/lib/sass/engine.rb
index 87d50c4..c67a47f 100644
--- a/lib/sass/engine.rb
+++ b/lib/sass/engine.rb
@@ -1,5 +1,4 @@
 require 'set'
-require 'digest/sha1'
 require 'sass/cache_stores'
 require 'sass/tree/node'
 require 'sass/tree/root_node'
@@ -153,6 +152,7 @@ module Sass
     # @return [{Symbol => Object}] The normalized options hash.
     # @private
     def self.normalize_options(options)
+      options[:syntax] = options[:syntax].to_sym
       options = DEFAULT_OPTIONS.merge(options.reject {|k, v| v.nil?})
 
       # If the `:filename` option is passed in without an importer,
@@ -300,29 +300,13 @@ module Sass
       rendered = _to_tree.render
       return rendered if ruby1_8?
       begin
-        # Try to convert the result to the original encoding,
-        # but if that doesn't work fall back on UTF-8
-        rendered = rendered.encode(source_encoding)
+      rendered
       rescue EncodingError
       end
-      rendered.gsub(Regexp.new('\A@charset "(.*?)"'.encode(source_encoding)),
-        "@charset \"#{source_encoding.name}\"".encode(source_encoding))
+      rendered
     end
 
     def _to_tree
-      if (@options[:cache] || @options[:read_cache]) &&
-          @options[:filename] && @options[:importer]
-        key = sassc_key
-        sha = Digest::SHA1.hexdigest(@template)
-
-        if root = @options[:cache_store].retrieve(key, sha)
-          root.options = @options
-          return root
-        end
-      end
-
-      check_encoding!
-
       if @options[:syntax] == :scss
         root = Sass::SCSS::Parser.new(@template, @options[:filename]).parse
       else
@@ -331,15 +315,6 @@ module Sass
       end
 
       root.options = @options
-      if @options[:cache] && key && sha
-        begin
-          old_options = root.options
-          root.options = {}
-          @options[:cache_store].store(key, sha, root)
-        ensure
-          root.options = old_options
-        end
-      end
       root
     rescue SyntaxError => e
       e.modify_backtrace(:filename => @options[:filename], :line => @line)
@@ -347,10 +322,6 @@ module Sass
       raise e
     end
 
-    def sassc_key
-      @options[:cache_store].key(*@options[:importer].key(@options[:filename], @options))
-    end
-
     def check_encoding!
       return if @checked_encoding
       @checked_encoding = true
@@ -367,7 +338,7 @@ module Sass
       string.gsub(/\r|\n|\r\n|\r\n/, "\n").scan(/^[^\n]*?$/).each_with_index do |line, index|
         index += (@options[:line] || 1)
         if line.strip.empty?
-          lines.last.text << "\n" if lines.last && lines.last.comment?
+	  lines.last.text += "\n" if lines.last && lines.last.comment?
           next
         end
 
@@ -428,7 +399,7 @@ MSG
       end
 
       last.comment_tab_str ||= comment_tab_str
-      last.text << "\n" << line
+      last.text += "\n" + line
       true
     end
 
@@ -612,7 +583,7 @@ WARNING
         silent = line.text[1] == SASS_COMMENT_CHAR
         if loud = line.text[2] == SASS_LOUD_COMMENT_CHAR
           value = self.class.parse_interp(line.text, line.index, line.offset, :filename => @filename)
-          value[0].slice!(2) # get rid of the "!"
+	  value[0] = value[0][0...2] + value[0][3..-1] # get rid of the "!"
         else
           value = [line.text]
         end
@@ -627,7 +598,11 @@ WARNING
     end
 
     def parse_directive(parent, line, root)
-      directive, whitespace, value = line.text[1..-1].split(/(\s+)/, 2)
+      txt = line.text[1..-1]
+      re = /\s+/
+      directive, value = txt.split(re, 2)
+      whitespace = txt.match(re)
+      whitespace = whitespace.to_s unless whitespace.nil?
       offset = directive.size + whitespace.size + 1 if whitespace
 
       # If value begins with url( or ",
@@ -677,7 +652,7 @@ WARNING
         offset = line.offset + line.text.index(value).to_i
         Tree::ReturnNode.new(parse_script(value, :offset => offset))
       elsif directive == "charset"
-        name = value && value[/\A(["'])(.*)\1\Z/, 2] #"
+	name = value && value[/\^(["'])(.*)\1\$/, 2] #"
         raise SyntaxError.new("Invalid charset directive '@charset': expected string.") unless name
         raise SyntaxError.new("Illegal nesting: Nothing may be nested beneath charset directives.",
           :line => @line + 1) unless line.children.empty?
@@ -791,7 +766,7 @@ WARNING
       end
     end
 
-    MIXIN_DEF_RE = /^(?:=|@mixin)\s*(#{Sass::SCSS::RX::IDENT})(.*)$/
+    MIXIN_DEF_RE = /^(?:=|@mixin)\s*(#{Sass::SCSS::RX::IDENT.source})(.*)$/
     def parse_mixin_definition(line)
       name, arg_string = line.text.scan(MIXIN_DEF_RE).first
       raise SyntaxError.new("Invalid mixin \"#{line.text[1..-1]}\".") if name.nil?
@@ -802,7 +777,7 @@ WARNING
       Tree::MixinDefNode.new(name, args)
     end
 
-    MIXIN_INCLUDE_RE = /^(?:\+|@include)\s*(#{Sass::SCSS::RX::IDENT})(.*)$/
+    MIXIN_INCLUDE_RE = /^(?:\+|@include)\s*(#{Sass::SCSS::RX::IDENT.source})(.*)$/
     def parse_mixin_include(line, root)
       name, arg_string = line.text.scan(MIXIN_INCLUDE_RE).first
       raise SyntaxError.new("Invalid mixin include \"#{line.text}\".") if name.nil?
@@ -815,7 +790,7 @@ WARNING
       Tree::MixinNode.new(name, args, keywords)
     end
 
-    FUNCTION_RE = /^@function\s*(#{Sass::SCSS::RX::IDENT})(.*)$/
+    FUNCTION_RE = /^@function\s*(#{Sass::SCSS::RX::IDENT.source})(.*)$/
     def parse_function(line, root)
       name, arg_string = line.text.scan(FUNCTION_RE).first
       raise SyntaxError.new("Invalid function definition \"#{line.text}\".") if name.nil?
@@ -841,15 +816,23 @@ WARNING
       end
 
       return silent ? "//" : "/* */" if content.empty?
-      content.last.gsub!(%r{ ?\*/ *$}, '')
-      content.map! {|l| l.gsub!(/^\*( ?)/, '\1') || (l.empty? ? "" : " ") + l}
-      content.first.gsub!(/^ /, '') unless removed_first
+      content[-1] = content.last.gsub(%r{ ?\*/ *$}, '')
+      content = content.map {|l|
+	old_val = l
+	l = l.gsub(/^\*( ?)/, '\1')
+	l = (l.empty? ? "" : " ") + l if l == old_val
+	l
+      }
+      content[0] = content.first.gsub(/^ /, '') unless removed_first
       if silent
-        "//" + content.join("\n//")
+	res = "//" + content.join("\n//")
       else
         # The #gsub fixes the case of a trailing */
-        "/*" + content.join("\n *").gsub(/ \*\Z/, '') + " */"
+	res = "/*" + content.join("\n *")
+	res = res[0...-2] if res[-2..-1] == ' *'
+	res += " */"
       end
+      res
     end
 
     def parse_interp(text, offset = 0)
diff --git a/lib/sass/environment.rb b/lib/sass/environment.rb
index 260983a..adfe6f0 100644
--- a/lib/sass/environment.rb
+++ b/lib/sass/environment.rb
@@ -104,8 +104,8 @@ module Sass
       trace = []
       stack.reverse.each_with_index do |entry, i|
         msg = "#{i == 0 ? "on" : "from"} line #{entry[:line]}"
-        msg << " of #{entry[:filename] || "an unknown file"}"
-        msg << ", in `#{entry[:mixin]}'" if entry[:mixin]
+	msg += " of #{entry[:filename] || "an unknown file"}"
+	msg += ", in `#{entry[:mixin]}'" if entry[:mixin]
         trace << msg
       end
       trace
@@ -125,15 +125,15 @@ module Sass
     end
 
     class << self
-      private
-      UNDERSCORE, DASH = '_', '-'
+      UNDERSCORE = '_'
+      DASH = '-'
 
       # Note: when updating this,
       # update sass/yard/inherited_hash.rb as well.
       def inherited_hash(name)
         class_eval <<RUBY, __FILE__, __LINE__ + 1
           def #{name}(name)
-            _#{name}(name.tr(UNDERSCORE, DASH))
+	    _#{name}(name.tr("_", "-"))
           end
 
           def _#{name}(name)
@@ -142,7 +142,7 @@ module Sass
           protected :_#{name}
 
           def set_#{name}(name, value)
-            name = name.tr(UNDERSCORE, DASH)
+	    name = name.tr("_", "-")
             @#{name}s[name] = value unless try_set_#{name}(name, value)
           end
 
@@ -161,7 +161,7 @@ module Sass
 
           def set_local_#{name}(name, value)
             @#{name}s ||= {}
-            @#{name}s[name.tr(UNDERSCORE, DASH)] = value
+	    @#{name}s[name.tr("_", "-")] = value
           end
 RUBY
       end
diff --git a/lib/sass/error.rb b/lib/sass/error.rb
index c47c0db..93e1d99 100644
--- a/lib/sass/error.rb
+++ b/lib/sass/error.rb
@@ -103,13 +103,17 @@ module Sass
     #
     # @param attrs [{Symbol => Object}] The information to add to the backtrace entry.
     #   See \{#sass\_backtrace}
+    def reject_if_included(attrs, entry)
+      attrs.reject {|k, v| entry.include?(k)}
+    end
+
     def modify_backtrace(attrs)
       attrs = attrs.reject {|k, v| v.nil?}
       # Move backwards through the backtrace
       (0...sass_backtrace.size).to_a.reverse.each do |i|
         entry = sass_backtrace[i]
         sass_backtrace[i] = attrs.merge(entry)
-        attrs.reject! {|k, v| entry.include?(k)}
+	attrs = reject_if_included(attrs, entry)
         break if attrs.empty?
       end
     end
@@ -119,6 +123,11 @@ module Sass
       @message
     end
 
+    def append_to_err (str)
+      @message += str
+      self
+    end
+
     # Returns the standard exception backtrace,
     # including the Sass backtrace.
     #
diff --git a/lib/sass/importers/filesystem.rb b/lib/sass/importers/filesystem.rb
index 456c98c..928f82b 100644
--- a/lib/sass/importers/filesystem.rb
+++ b/lib/sass/importers/filesystem.rb
@@ -107,13 +107,6 @@ module Sass
       # @param name [String] The filename to search for.
       # @return [(String, Symbol)] A filename-syntax pair.
       def find_real_file(dir, name)
-        for (f,s) in possible_files(remove_root(name))
-          path = (dir == "." || Pathname.new(f).absolute?) ? f : "#{dir}/#{f}"
-          if full_path = Dir[path].first
-            full_path.gsub!(REDUNDANT_DIRECTORY,File::SEPARATOR)
-            return full_path, s
-          end
-        end
         nil
       end
 
diff --git a/lib/sass/less.rb b/lib/sass/less.rb
index affef14..1519af1 100755
--- a/lib/sass/less.rb
+++ b/lib/sass/less.rb
@@ -171,7 +171,7 @@ WARNING
           end
           last_el = el
           comma_sel = comma_sel.join(' ').gsub(' :', ':')
-          comma_sel.gsub!(/^:/, '&:') unless parent.root?
+	  comma_sel = comma_sel.gsub(/^:/, '&:') unless parent.root?
           comma_sel
         end.join(', ')
 
diff --git a/lib/sass/plugin/compiler.rb b/lib/sass/plugin/compiler.rb
index e6ea988..27ba0b0 100644
--- a/lib/sass/plugin/compiler.rb
+++ b/lib/sass/plugin/compiler.rb
@@ -231,82 +231,6 @@ module Sass::Plugin
     #   The first string in each pair is the location of the Sass/SCSS file,
     #   the second is the location of the CSS file that it should be compiled to.
     def watch(individual_files = [])
-      update_stylesheets(individual_files)
-
-      begin
-        require 'listen'
-      rescue LoadError => e
-        dir = Sass::Util.scope("vendor/listen/lib")
-        if $LOAD_PATH.include?(dir)
-          e.message << "\n" <<
-            if File.exists?(scope(".git"))
-              'Run "git submodule update --init" to get the recommended version.'
-            else
-              'Run "gem install listen" to get it.'
-            end
-          raise e
-        else
-          $LOAD_PATH.unshift dir
-          retry
-        end
-      end
-
-      template_paths = template_locations # cache the locations
-      individual_files_hash = individual_files.inject({}) do |h, files|
-        parent = File.dirname(files.first)
-        (h[parent] ||= []) << files unless template_paths.include?(parent)
-        h
-      end
-      directories = template_paths + individual_files_hash.keys +
-        [{:relative_paths => true}]
-
-      # TODO: Keep better track of what depends on what
-      # so we don't have to run a global update every time anything changes.
-      listener = Listen::MultiListener.new(*directories) do |modified, added, removed|
-        modified.each do |f|
-          parent = File.dirname(f)
-          if files = individual_files_hash[parent]
-            next unless files.first == f
-          else
-            next unless f =~ /\.s[ac]ss$/
-          end
-          run_template_modified(f)
-        end
-
-        added.each do |f|
-          parent = File.dirname(f)
-          if files = individual_files_hash[parent]
-            next unless files.first == f
-          else
-            next unless f =~ /\.s[ac]ss$/
-          end
-          run_template_created(f)
-        end
-
-        removed.each do |f|
-          parent = File.dirname(f)
-          if files = individual_files_hash[parent]
-            next unless files.first == f
-            try_delete_css files[1]
-          else
-            next unless f =~ /\.s[ac]ss$/
-            try_delete_css f.gsub(/\.s[ac]ss$/, '.css')
-          end
-          run_template_deleted(f)
-        end
-
-        update_stylesheets(individual_files)
-      end
-
-      # The native windows listener is much slower than the polling
-      # option, according to https://github.com/nex3/sass/commit/a3031856b22bc834a5417dedecb038b7be9b9e3e#commitcomment-1295118
-      listener.force_polling(true) if Sass::Util.windows?
-
-      begin
-        listener.start
-      rescue Exception => e
-        raise e unless e.is_a?(Interrupt)
-      end
     end
 
     # Non-destructively modifies \{#options} so that default values are properly set,
diff --git a/lib/sass/script.rb b/lib/sass/script.rb
index 44228b5..bd94106 100644
--- a/lib/sass/script.rb
+++ b/lib/sass/script.rb
@@ -12,10 +12,11 @@ module Sass
   # This module contains code that handles the parsing and evaluation of SassScript.
   module Script
     # The regular expression used to parse variables.
-    MATCH = /^\$(#{Sass::SCSS::RX::IDENT})\s*:\s*(.+?)(!(?i:default))?$/
+
+    MATCH = /^\$(#{Sass::SCSS::RX::IDENT.source})\s*:\s*(.+?)(!(?:[dD][eE][fF][aA][uU][lL][tT]))?$/
 
     # The regular expression used to validate variables without matching.
-    VALIDATE = /^\$#{Sass::SCSS::RX::IDENT}$/
+    VALIDATE = /^\$#{Sass::SCSS::RX::IDENT.source}$/
 
     # Parses a string of SassScript
     #
diff --git a/lib/sass/script/interpolation.rb b/lib/sass/script/interpolation.rb
index 53902b1..5d3395e 100644
--- a/lib/sass/script/interpolation.rb
+++ b/lib/sass/script/interpolation.rb
@@ -31,13 +31,13 @@ module Sass::Script
     # @see Node#to_sass
     def to_sass(opts = {})
       res = ""
-      res << @before.to_sass(opts) if @before
-      res << ' ' if @before && @whitespace_before
-      res << '#{' unless @originally_text
-      res << @mid.to_sass(opts)
-      res << '}' unless @originally_text
-      res << ' ' if @after && @whitespace_after
-      res << @after.to_sass(opts) if @after
+      res += @before.to_sass(opts) if @before
+      res += ' ' if @before && @whitespace_before
+      res += '#{' unless @originally_text
+      res += @mid.to_sass(opts)
+      res += '}' unless @originally_text
+      res += ' ' if @after && @whitespace_after
+      res += @after.to_sass(opts) if @after
       res
     end
 
@@ -67,12 +67,12 @@ module Sass::Script
     # @return [Sass::Script::String] The SassScript string that is the value of the interpolation
     def _perform(environment)
       res = ""
-      res << @before.perform(environment).to_s if @before
-      res << " " if @before && @whitespace_before
+      res += @before.perform(environment).to_s if @before
+      res += " " if @before && @whitespace_before
       val = @mid.perform(environment)
-      res << (val.is_a?(Sass::Script::String) ? val.value : val.to_s)
-      res << " " if @after && @whitespace_after
-      res << @after.perform(environment).to_s if @after
+      res += (val.is_a?(Sass::Script::String) ? val.value : val.to_s)
+      res += " " if @after && @whitespace_after
+      res += @after.perform(environment).to_s if @after
       opts(Sass::Script::String.new(res))
     end
   end
diff --git a/lib/sass/script/lexer.rb b/lib/sass/script/lexer.rb
index 0ab6275..e200eda 100644
--- a/lib/sass/script/lexer.rb
+++ b/lib/sass/script/lexer.rb
@@ -85,12 +85,13 @@ module Sass
         :whitespace => /\s+/,
         :comment => COMMENT,
         :single_line_comment => SINGLE_LINE_COMMENT,
-        :variable => /(\$)(#{IDENT})/,
-        :ident => /(#{IDENT})(\()?/,
+	:variable => /(\$)(#{IDENT.source})/,
+	:ident => /(#{IDENT.source})(\()?/,
         :number => /(-)?(?:(\d*\.\d+)|(\d+))([a-zA-Z%]+)?/,
         :color => HEXCOLOR,
         :bool => /(true|false)\b/,
-        :ident_op => %r{(#{Regexp.union(*IDENT_OP_NAMES.map{|s| Regexp.new(Regexp.escape(s) + "(?!#{NMCHAR}|\Z)")})})},
+	:ident_op => %r{(#{Regexp.union(*IDENT_OP_NAMES.map{|s| Regexp.new(Regexp.escape(s) + "(?!#{NMCHAR.source}|\Z)")})})},
+	:ident_op_pre => /#{IDENT_OP_NAMES.join('|')}/,
         :op => %r{(#{Regexp.union(*OP_NAMES)})},
       }
 
@@ -112,8 +113,8 @@ module Sass
         [:single, false] => string_re("'", "'"),
         [:double, true] => string_re('', '"'),
         [:single, true] => string_re('', "'"),
-        [:uri, false] => /url\(#{W}(#{URLCHAR}*?)(#{W}\)|#\{)/,
-        [:uri, true] => /(#{URLCHAR}*?)(#{W}\)|#\{)/,
+	[:uri, false] => /url\(#{W.source}((#{URLCHAR.source})*?)(#{W.source}\)|#\{)/,
+	[:uri, true] => /((#{URLCHAR.source})*?)(#{W.source}\)|#\{)/,
       }
 
       # @param str [String, StringScanner] The source text to lex
@@ -147,10 +148,10 @@ module Sass
       # @return [Boolean]
       def whitespace?(tok = @tok)
         if tok
-          @scanner.string[0...tok.pos] =~ /\s\Z/
+	  @scanner.string[0...tok.pos] =~ /\s$/
         else
           @scanner.string[@scanner.pos, 1] =~ /^\s/ ||
-            @scanner.string[@scanner.pos - 1, 1] =~ /\s\Z/
+	    @scanner.string[@scanner.pos - 1, 1] =~ /\s$/
         end
       end
 
@@ -209,7 +210,7 @@ module Sass
         return if done?
         return unless value = token
         type, val, size = value
-        size ||= @scanner.matched_size
+	size ||= @scanner.matched && @scanner.matched.length
 
         val.line = @line if val.is_a?(Script::Node)
         Token.new(type, val, @line,
@@ -306,7 +307,17 @@ MESSAGE
       end
 
       def ident_op
-        return unless op = scan(REGULAR_EXPRESSIONS[:ident_op])
+	# have to rewrite this entirely because of JS's support of \Z in order
+	# to get the fix in 67a662e3 working
+	return unless op = @scanner.check(REGULAR_EXPRESSIONS[:ident_op_pre])
+
+	orig_position = @scanner.pos
+	@scanner.pos += op.size
+	negative_check = @scanner.check(%r{(?!#{NMCHAR.source})}) != ""
+	@scanner.pos = orig_position
+
+	return if @scanner.eos? or negative_check
+	op = scan(REGULAR_EXPRESSIONS[:ident_op_pre])
         [OPERATORS[op]]
       end
 
diff --git a/lib/sass/script/number.rb b/lib/sass/script/number.rb
index a75294f..84561d7 100644
--- a/lib/sass/script/number.rb
+++ b/lib/sass/script/number.rb
@@ -345,8 +345,8 @@ module Sass::Script
     def unit_str
       rv = @numerator_units.sort.join("*")
       if @denominator_units.any?
-        rv << "/"
-        rv << @denominator_units.sort.join("*")
+	rv += "/"
+	rv += @denominator_units.sort.join("*")
       end
       rv
     end
diff --git a/lib/sass/script/parser.rb b/lib/sass/script/parser.rb
index ef4a278..66fad74 100644
--- a/lib/sass/script/parser.rb
+++ b/lib/sass/script/parser.rb
@@ -270,7 +270,8 @@ RUBY
 
       def space
         line = @lexer.line
-        return unless e = or_expr
+	e = or_expr
+	return unless e
         arr = [e]
         while e = or_expr
           arr << e
diff --git a/lib/sass/script/string_interpolation.rb b/lib/sass/script/string_interpolation.rb
index 6baba12..2c76d9e 100644
--- a/lib/sass/script/string_interpolation.rb
+++ b/lib/sass/script/string_interpolation.rb
@@ -31,23 +31,23 @@ module Sass::Script
         (!before_quote_char && after_quote_char && !before_str.empty?)
       quote_char =
         if before_quote_char && after_quote_char && before_quote_char != after_quote_char
-          before_str.gsub!("\\'", "'")
-          before_str.gsub!('"', "\\\"")
-          after_str.gsub!("\\'", "'")
-          after_str.gsub!('"', "\\\"")
+	  before_str = before_str.gsub("\\'", "'")
+	  before_str = before_str.gsub('"', "\\\"")
+	  after_str = after_str.gsub("\\'", "'")
+	  after_str = after_str.gsub('"', "\\\"")
           '"'
         else
           before_quote_char || after_quote_char
         end
 
       res = ""
-      res << 'unquote(' if unquote
-      res << quote_char if quote_char
-      res << before_str
-      res << '#{' << @mid.to_sass(opts) << '}'
-      res << after_str
-      res << quote_char if quote_char
-      res << ')' if unquote
+      res += 'unquote(' if unquote
+      res += quote_char if quote_char
+      res += before_str
+      res += '#{' + @mid.to_sass(opts) + '}'
+      res += after_str
+      res += quote_char if quote_char
+      res += ')' if unquote
       res
     end
 
@@ -78,10 +78,10 @@ module Sass::Script
     def _perform(environment)
       res = ""
       before = @before.perform(environment)
-      res << before.value
+      res += before.value
       mid = @mid.perform(environment)
-      res << (mid.is_a?(Sass::Script::String) ? mid.value : mid.to_s)
-      res << @after.perform(environment).value
+      res += (mid.is_a?(Sass::Script::String) ? mid.value : mid.to_s)
+      res += @after.perform(environment).value
       opts(Sass::Script::String.new(res, before.type))
     end
 
diff --git a/lib/sass/scss/css_parser.rb b/lib/sass/scss/css_parser.rb
index 8964ced..f5c594f 100644
--- a/lib/sass/scss/css_parser.rb
+++ b/lib/sass/scss/css_parser.rb
@@ -12,7 +12,7 @@ module Sass
       # @return [String, nil] The parsed selector, or nil if no selector was parsed
       # @raise [Sass::SyntaxError] if there's a syntax error in the selector
       def parse_selector_string
-        init_scanner!
+	init_scanner
         str {return unless selector}
       end
 
diff --git a/lib/sass/scss/parser.rb b/lib/sass/scss/parser.rb
index ef61f5d..e264946 100644
--- a/lib/sass/scss/parser.rb
+++ b/lib/sass/scss/parser.rb
@@ -23,7 +23,7 @@ module Sass
       # @return [Sass::Tree::RootNode] The root node of the document tree
       # @raise [Sass::SyntaxError] if there's a syntax error in the document
       def parse
-        init_scanner!
+	@scanner = init_scanner
         root = stylesheet
         expected("selector or at-rule") unless @scanner.eos?
         root
@@ -36,7 +36,7 @@ module Sass
       # @return [Array<String, Sass::Script::Node>, nil]
       #   The interpolated identifier, or nil if none could be parsed
       def parse_interp_ident
-        init_scanner!
+	@scanner = init_scanner
         interp_ident
       end
 
@@ -44,7 +44,7 @@ module Sass
 
       include Sass::SCSS::RX
 
-      def init_scanner!
+      def init_scanner
         @scanner =
           if @template.is_a?(StringScanner)
             @template
@@ -92,7 +92,7 @@ module Sass
         line = @line - text.count("\n")
         if loud = text =~ %r{^/[/*]!}
           value = Sass::Engine.parse_interp(text, line, @scanner.pos - text.size, :filename => @filename)
-          value[0].slice!(2) # get rid of the "!"
+	  value[0] = value[0][0...2] + value[0][3..-1] # get rid of the "!"
         else
           value = [text]
         end
@@ -102,10 +102,11 @@ module Sass
             str.sub(/^\s*\/\//, '/*').gsub(/^\s*\/\//, ' *') + ' */'
           end
         else
-          value.unshift(@scanner.
-            string[0...@scanner.pos].
-            reverse[/.*?\*\/(.*?)($|\Z)/, 1].
-            reverse.gsub(/[^\s]/, ' '))
+	    pre_str = @scanner.string[0...@scanner.pos].reverse
+	    pre_str = pre_str[/.*?\*\/(.*?)($|\Z)/m, 1] || ''
+	    pre_str = pre_str.reverse.gsub(/[^\s]/, ' ')
+
+	  value.unshift(pre_str)
         end
 
         comment = Sass::Tree::CommentNode.new(value, silent, loud)
@@ -369,10 +370,15 @@ module Sass
       # think WebKit works sans quotes.
       def _moz_document_directive
         value = str do
-          begin
+	  loop do
             ss
             expr!(:moz_document_function)
-          end while tok(/,/)
+	    if tok(/,/)
+	      next
+	    else
+	      break
+	    end
+	  end
         end
         directive_body("@-moz-document #{value}")
       end
@@ -401,10 +407,15 @@ module Sass
       def supports_operator
         return unless supports_condition_in_parens
         tok!(/and|or/i)
-        begin
+	loop do
           ss
           expr!(:supports_condition_in_parens)
-        end while tok(/and|or/i)
+	  if tok(/and|or/i)
+	    next
+	  else
+	    break
+	  end
+	end
         true
       end
 
@@ -532,7 +543,7 @@ module Sass
 
         ws = ''
         while tok(/,/)
-          ws << str {ss}
+	  ws += str {ss}
           if v = selector
             rules << ',' << ws
             rules.concat v
@@ -552,7 +563,7 @@ module Sass
         selectors = [sel]
         ws = ''
         while tok(/,/)
-          ws << str{ss}
+	  ws += str{ss}
           if sel = _selector
             selectors << sel
             selectors[-1] = Selector::Sequence.new(["\n"] + selectors.last.members) if ws.include?("\n")
@@ -603,7 +614,7 @@ module Sass
             begin
               throw_error {expected('"{"')}
             rescue Sass::SyntaxError => e
-              e.message << "\n\n\"#{sel}\" may only be used at the beginning of a selector."
+	      e.append_to_err "\n\n\"#{sel}\" may only be used at the beginning of a selector."
               raise e
             end
           else
@@ -844,7 +855,7 @@ MESSAGE
         # @scanner[2].empty? means we've started an interpolated section
         while @scanner[2] == '#{'
           @scanner.pos -= 2 # Don't consume the #{
-          res.last.slice!(-2..-1)
+	  res[-1] = res.last.slice(0...-2)
           res << expr!(:interpolation) << tok(mid_re)
         end
         res
@@ -1000,9 +1011,9 @@ MESSAGE
         was = scanner.rest.dup
         # Get rid of whitespace between pos and the next token,
         # but only if there's a newline in there
-        was.gsub!(/^\s*\n\s*/, '')
+	was = was.gsub(/^\s*\n\s*/, '')
         # Also get rid of stuff after the next newline
-        was.gsub!(/\n.*/, '')
+	was = was.gsub(/\n.*/, '')
         was = was[0...15] + "..." if was.size > 18
 
         raise Sass::SyntaxError.new(
@@ -1017,9 +1028,9 @@ MESSAGE
         after = scanner.string[0...pos]
         # Get rid of whitespace between pos and the last token,
         # but only if there's a newline in there
-        after.gsub!(/\s*\n\s*$/, '')
+	after = after.gsub(/\s*\n\s*$/, '')
         # Also get rid of stuff before the last newline
-        after.gsub!(/.*\n/, '')
+	after = after.gsub(/.*\n/, '')
         after = "..." + after[-15..-1] if after.size > 18
         after
       end
@@ -1040,12 +1051,12 @@ MESSAGE
           # matched group will always occur at the end of the match.
           if last_group_lookahead && @scanner[-1]
             @scanner.pos -= @scanner[-1].length
-            res.slice!(-@scanner[-1].length..-1)
+	    res = res.slice(0...-@scanner[-1].length)
           end
           @line += res.count(NEWLINE)
           @expected = nil
           if !@strs.empty? && rx != COMMENT && rx != SINGLE_LINE_COMMENT
-            @strs.each {|s| s << res}
+	    @strs = @strs.map {|s| s += res}
           end
           res
         end
diff --git a/lib/sass/scss/rx.rb b/lib/sass/scss/rx.rb
index 1549ddd..84c7878 100644
--- a/lib/sass/scss/rx.rb
+++ b/lib/sass/scss/rx.rb
@@ -15,13 +15,19 @@ module Sass
         return "\\#{str}" if str == '-' || str == '_'
         out = ""
         value = str.dup
-        out << value.slice!(0...1) if value =~ /^[-_]/
+
+	if value =~ /^[-_]/
+	  out += value.slice(0...1)
+	  value = value.slice(1..-1)
+	end
         if value[0...1] =~ NMSTART
-          out << value.slice!(0...1)
+	  out += value.slice(0...1)
+	  value = value.slice(1..-1)
         else
-          out << escape_char(value.slice!(0...1))
+	  out += escape_char(value.slice(0...1))
+	  value = value.slice(1..-1)
         end
-        out << value.gsub(/[^a-zA-Z0-9_-]/) {|c| escape_char c}
+	out += value.gsub(/[^a-zA-Z0-9_-]/) {|c| escape_char c}
         return out
       end
 
@@ -46,33 +52,36 @@ module Sass
         Regexp.new(Regexp.quote(str), flags)
       end
 
+      IS_OPAL = RUBY_PLATFORM.eql? 'opal'
       H        = /[0-9a-fA-F]/
       NL       = /\n|\r\n|\r|\f/
-      UNICODE  = /\\#{H}{1,6}[ \t\r\n\f]?/
+      UNICODE  = /\\#{H.source}{1,6}[ \t\r\n\f]?/
       s = if Sass::Util.ruby1_8?
             '\200-\377'
+	  elsif IS_OPAL
+	    "[\\x80-\\uD7FF\\uDC00-\\uFFFF\]|[\\uD800-\\uDBFF\][\\uDC00-\\uDFFF\]|[\\uD800-\\uDBFF]"
           else
             '\u{80}-\u{D7FF}\u{E000}-\u{FFFD}\u{10000}-\u{10FFFF}'
           end
-      NONASCII = /[#{s}]/
-      ESCAPE   = /#{UNICODE}|\\[ -~#{s}]/
-      NMSTART  = /[_a-zA-Z]|#{NONASCII}|#{ESCAPE}/
-      NMCHAR   = /[a-zA-Z0-9_-]|#{NONASCII}|#{ESCAPE}/
-      STRING1  = /\"((?:[^\n\r\f\\"]|\\#{NL}|#{ESCAPE})*)\"/
-      STRING2  = /\'((?:[^\n\r\f\\']|\\#{NL}|#{ESCAPE})*)\'/
-
-      IDENT    = /-?#{NMSTART}#{NMCHAR}*/
-      NAME     = /#{NMCHAR}+/
+      NONASCII = IS_OPAL ? /#{s}/ : /[#{s}]/
+      ESCAPE   =  IS_OPAL ? /#{UNICODE.source}|\\(?:[ -~]|#{s})/ : /#{UNICODE.source}|\\[ -~#{s}]/
+      NMSTART  = /[_a-zA-Z]|#{NONASCII.source}|#{ESCAPE.source}/
+      NMCHAR   = /[a-zA-Z0-9_-]|#{NONASCII.source}|#{ESCAPE.source}/
+      STRING1  = /\"((?:[^\n\r\f\\"]|\\#{NL.source}|#{ESCAPE.source})*)\"/
+      STRING2  = /\'((?:[^\n\r\f\\']|\\#{NL.source}|#{ESCAPE.source})*)\'/
+
+      IDENT    = /-?(?:#{NMSTART.source})(?:#{NMCHAR.source})*/
+
+      NAME     = /(?:#{NMCHAR.source})+/
       NUM      = /[0-9]+|[0-9]*\.[0-9]+/
-      STRING   = /#{STRING1}|#{STRING2}/
-      URLCHAR  = /[#%&*-~]|#{NONASCII}|#{ESCAPE}/
-      URL      = /(#{URLCHAR}*)/
+      STRING   = /#{STRING1.source}|#{STRING2.source}/
+      URLCHAR  = /[#%&*-~]|#{NONASCII.source}|#{ESCAPE.source}/
+      URL      = /((?:#{URLCHAR.source})*)/
       W        = /[ \t\r\n\f]*/
-      VARIABLE = /(\$)(#{Sass::SCSS::RX::IDENT})/
-
+      VARIABLE = /(\$)(#{Sass::SCSS::RX::IDENT.source})/
       # This is more liberal than the spec's definition,
       # but that definition didn't work well with the greediness rules
-      RANGE    = /(?:#{H}|\?){1,6}/
+      RANGE    = /(?:#{H.source}|\?){1,6}/
 
       ##
 
@@ -89,28 +98,28 @@ module Sass
       SUFFIXMATCH    = quote("$=")
       SUBSTRINGMATCH = quote("*=")
 
-      HASH = /##{NAME}/
+      HASH = /##{NAME.source}/
 
-      IMPORTANT = /!#{W}important/i
-      DEFAULT = /!#{W}default/i
+      IMPORTANT = /!#{W.source}[iI][mM][pP][oO][rR][tT][aA][nN][tT]/
+      DEFAULT = /!#{W.source}[dD][eE][fF][aA][uU][lL][tT]/
 
-      NUMBER = /#{NUM}(?:#{IDENT}|%)?/
+      NUMBER = /(?:#{NUM.source})(?:#{IDENT.source}|%)?/
 
-      URI = /url\(#{W}(?:#{STRING}|#{URL})#{W}\)/i
-      FUNCTION = /#{IDENT}\(/
+      URI = /[uU][rR][lL]\(#{W.source}(?:#{STRING.source}|#{URL.source})#{W.source}\)/
+      FUNCTION = /#{IDENT.source}\(/
 
-      UNICODERANGE = /u\+(?:#{H}{1,6}-#{H}{1,6}|#{RANGE})/i
+      UNICODERANGE = /[uU]\+(?:#{H.source}{1,6}-#{H.source}{1,6}|#{RANGE.source})/
 
       # Defined in http://www.w3.org/TR/css3-selectors/#lex
-      PLUS = /#{W}\+/
-      GREATER = /#{W}>/
-      TILDE = /#{W}~/
+      PLUS = /#{W.source}\+/
+      GREATER = /#{W.source}>/
+      TILDE = /#{W.source}~/
       NOT = quote(":not(", Regexp::IGNORECASE)
 
       # Defined in https://developer.mozilla.org/en/CSS/@-moz-document as a
       # non-standard version of http://www.w3.org/TR/css3-conditional/
-      URL_PREFIX = /url-prefix\(#{W}(?:#{STRING}|#{URL})#{W}\)/i
-      DOMAIN = /domain\(#{W}(?:#{STRING}|#{URL})#{W}\)/i
+      URL_PREFIX = /[uU][rR][lL]-[pP][rR][eE][fF][iI][xX]\(#{W.source}(?:#{STRING.source}|#{URL.source})#{W.source}\)/i
+      DOMAIN = /[dD][oO][mM][aA][iI][nN]\(#{W.source}(?:#{STRING.source}|#{URL.source})#{W.source}\)/i
 
       # Custom
       HEXCOLOR = /\#[0-9a-fA-F]+/
@@ -118,9 +127,9 @@ module Sass
       MOZ_ANY = quote(":-moz-any(", Regexp::IGNORECASE)
 
       IDENT_HYPHEN_INTERP = /-(#\{)/
-      STRING1_NOINTERP = /\"((?:[^\n\r\f\\"#]|#(?!\{)|\\#{NL}|#{ESCAPE})*)\"/
-      STRING2_NOINTERP = /\'((?:[^\n\r\f\\'#]|#(?!\{)|\\#{NL}|#{ESCAPE})*)\'/
-      STRING_NOINTERP = /#{STRING1_NOINTERP}|#{STRING2_NOINTERP}/
+      STRING1_NOINTERP = /\"((?:[^\n\r\f\\"#]|#(?!\{)|\\#{NL.source}|#{ESCAPE.source})*)\"/
+      STRING2_NOINTERP = /\'((?:[^\n\r\f\\'#]|#(?!\{)|\\#{NL.source}|#{ESCAPE.source})*)\'/
+      STRING_NOINTERP = /#{STRING1_NOINTERP.source}|#{STRING2_NOINTERP.source}/
       # Can't use IDENT here, because it seems to take exponential time on 1.8.
       # We could use it for 1.9 only, but I don't want to introduce a cross-version
       # behavior difference.
@@ -130,8 +139,8 @@ module Sass
       # about 50 characters. This mitigates the problem of exponential parsing
       # time when a value has a long string of valid, parsable content followed
       # by something invalid.
-      STATIC_VALUE = /(-?#{NMSTART}|#{STRING_NOINTERP}|[ \t](?!%)|#[a-f0-9]|[,%]|#{NUM}|\!important){0,50}([;}])/i
-      STATIC_SELECTOR = /(#{NMCHAR}|[ \t]|[,>+*]|[:#.]#{NMSTART}){0,50}([{])/i
+      STATIC_VALUE = /(-?#{NMSTART.source}|#{STRING_NOINTERP.source}|[ \t](?!%)|#[a-f0-9]|[,%]|#{NUM.source}|\!important){0,50}([;}])/i
+      STATIC_SELECTOR = /(#{NMCHAR.source}|[ \t]|[,>+*]|[:#.]#{NMSTART.source}){0,50}([{])/i
     end
   end
 end
diff --git a/lib/sass/scss/static_parser.rb b/lib/sass/scss/static_parser.rb
index 11a221d..948aa2f 100644
--- a/lib/sass/scss/static_parser.rb
+++ b/lib/sass/scss/static_parser.rb
@@ -14,7 +14,7 @@ module Sass
       # @return [Selector::CommaSequence] The parsed selector
       # @raise [Sass::SyntaxError] if there's a syntax error in the selector
       def parse_selector
-        init_scanner!
+	@scanner = init_scanner
         seq = expr!(:selector_comma_sequence)
         expected("selector") unless @scanner.eos?
         seq.line = @line
diff --git a/lib/sass/selector.rb b/lib/sass/selector.rb
index 9bc92fe..5a8462a 100644
--- a/lib/sass/selector.rb
+++ b/lib/sass/selector.rb
@@ -127,16 +127,20 @@ module Sass
       #
       # @see Selector#unify
       def unify(sels)
+	should_exit = false
         name =
           case sels.first
           when Universal; :universal
           when Element; sels.first.name
           else
+	    should_exit = true
             return [self] + sels unless namespace.nil? || namespace == ['*']
             return sels unless sels.empty?
             return [self]
           end
 
+	return name if should_exit
+
         ns, accept = unify_namespaces(namespace, sels.first.namespace)
         return unless accept
         [name == :universal ? Universal.new(ns) : Element.new(name, ns)] + sels[1..-1]
diff --git a/lib/sass/selector/sequence.rb b/lib/sass/selector/sequence.rb
index ddf6cf3..c11772c 100644
--- a/lib/sass/selector/sequence.rb
+++ b/lib/sass/selector/sequence.rb
@@ -251,9 +251,14 @@ module Sass
         tail = seq.dup
         until tail.empty?
           head = []
-          begin
+	  loop do
             head << tail.shift
-          end while !tail.empty? && head.last.is_a?(String) || tail.first.is_a?(String)
+	    if !tail.empty? && head.last.is_a?(String) || tail.first.is_a?(String)
+	      next
+	    else
+	      break
+	    end
+	  end
           newseq << head
         end
         return newseq
diff --git a/lib/sass/selector/simple_sequence.rb b/lib/sass/selector/simple_sequence.rb
index ab69ada..92f9701 100644
--- a/lib/sass/selector/simple_sequence.rb
+++ b/lib/sass/selector/simple_sequence.rb
@@ -76,7 +76,7 @@ module Sass
           seq = Sequence.new(seq)
           next [] if seen.include?(sels)
           seq.do_extend(extends, parent_directives, seen + [sels])
-        end.flatten.uniq
+        end.flatten.uniq{|v| v.to_a.sort.join }
       end
 
       # Unifies this selector with another {SimpleSequence}'s {SimpleSequence#members members array},
diff --git a/lib/sass/shared.rb b/lib/sass/shared.rb
index 54bd9bd..f015ecb 100644
--- a/lib/sass/shared.rb
+++ b/lib/sass/shared.rb
@@ -15,7 +15,7 @@ module Sass
     # @return [String] The text remaining in the scanner after all `#{`s have been processed
     def handle_interpolation(str)
       scan = Sass::Util::MultibyteStringScanner.new(str)
-      yield scan while scan.scan(/(.*?)(\\*)\#\{/m)
+      yield scan while scan.scan(/([\s\S]*?)(\\*)\#\{/m)
       scan.rest
     end
 
@@ -41,7 +41,7 @@ module Sass
       scanner = Sass::Util::MultibyteStringScanner.new(scanner) unless scanner.is_a? StringScanner
       regexp = Regexp.new("(.*?)[\\#{start.chr}\\#{finish.chr}]", Regexp::MULTILINE)
       while scanner.scan(regexp)
-        str << scanner.matched
+	str += scanner.matched
         count += 1 if scanner.matched[-1] == start
         count -= 1 if scanner.matched[-1] == finish
         return [str.strip, scanner.rest] if count == 0
diff --git a/lib/sass/tree/comment_node.rb b/lib/sass/tree/comment_node.rb
index 49315b3..5c651fa 100644
--- a/lib/sass/tree/comment_node.rb
+++ b/lib/sass/tree/comment_node.rb
@@ -78,8 +78,8 @@ module Sass::Tree
     private
 
     def normalize_indentation(str)
-      pre = str.split("\n").inject(str[/^[ \t]*/].split("")) do |pre, line|
-        line[/^[ \t]*/].split("").zip(pre).inject([]) do |arr, (a, b)|
+      pre = str.split("\n").inject(str[/^[ \t]*/].split("")) do |p, line|
+	line[/^[ \t]*/].split("").zip(p).inject([]) do |arr, (a, b)|
           break arr if a != b
           arr << a
         end
diff --git a/lib/sass/tree/import_node.rb b/lib/sass/tree/import_node.rb
index 98bcfe1..049e19e 100644
--- a/lib/sass/tree/import_node.rb
+++ b/lib/sass/tree/import_node.rb
@@ -55,9 +55,9 @@ module Sass
 
         message = "File to import not found or unreadable: #{@imported_filename}.\n"
         if paths.size == 1
-          message << "Load path: #{paths.first}"
+	  message += "Load path: #{paths.first}"
         else
-          message << "Load paths:\n  " << paths.join("\n  ")
+	  message += "Load paths:\n  " << paths.join("\n  ")
         end
         raise SyntaxError.new(message)
       rescue SyntaxError => e
diff --git a/lib/sass/tree/rule_node.rb b/lib/sass/tree/rule_node.rb
index 740524a..00e4df1 100644
--- a/lib/sass/tree/rule_node.rb
+++ b/lib/sass/tree/rule_node.rb
@@ -109,7 +109,7 @@ module Sass::Tree
     #
     # @return [{#to_s => #to_s}]
     def debug_info
-      {:filename => filename && ("file://" + URI.escape(File.expand_path(filename))),
+      {:filename => filename && ("file://" + URI.escape(filename)),
        :line => self.line}
     end
 
diff --git a/lib/sass/tree/visitors/convert.rb b/lib/sass/tree/visitors/convert.rb
index 5d7dbfa..3fe0598 100644
--- a/lib/sass/tree/visitors/convert.rb
+++ b/lib/sass/tree/visitors/convert.rb
@@ -56,20 +56,20 @@ class Sass::Tree::Visitors::Convert < Sass::Tree::Visitors::Base
 
     content = if @format == :sass
       content = value.gsub(/\*\/$/, '').rstrip
-      if content =~ /\A[ \t]/
+      if content =~ /^[ \t]/
         # Re-indent SCSS comments like this:
         #     /* foo
         #   bar
         #       baz */
-        content.gsub!(/^/, '   ')
-        content.sub!(/\A([ \t]*)\/\*/, '/*\1')
+	content = content.lines.map{|l| l.sub(/^/, '   ')}.join
+	content = content.sub(/^([ \t]*)\/\*/, '/*\1')
       end
 
       content =
         unless content.include?("\n")
           content
         else
-          content.gsub!(/\n( \*|\/\/)/, "\n  ")
+	  content = content.gsub(/\n( \*|\/\/)/, "\n  ")
           spaces = content.scan(/\n( *)/).map {|s| s.first.size}.min
           sep = node.silent ? "\n//" : "\n *"
           if spaces >= 2
@@ -79,8 +79,8 @@ class Sass::Tree::Visitors::Convert < Sass::Tree::Visitors::Base
           end
         end
 
-      content.gsub!(/\A\/\*/, '//') if node.silent
-      content.gsub!(/^/, tab_str)
+      content = content.gsub(/^\/\*/, '//') if node.silent
+      content = content.lines.map{|l| l.sub(/^/, tab_str)}.join
       content.rstrip + "\n"
     else
       spaces = ('  ' * [@tabs - value[/^ */].size, 0].max)
@@ -88,14 +88,14 @@ class Sass::Tree::Visitors::Convert < Sass::Tree::Visitors::Base
         value.gsub(/^[\/ ]\*/, '//').gsub(/ *\*\/$/, '')
       else
         value
-      end.gsub(/^/, spaces) + "\n"
+      end.lines.map{|l| l.sub(/^/, spaces)}.join + "\n"
       content
     end
     if node.loud
       if node.silent
-        content.gsub!(%r{^\s*(//!?)}, '//!')
+	content = content.gsub(%r{^\s*(//!?)}, '//!')
       else
-        content.sub!(%r{^\s*(/\*)}, '/*!')
+	content = content.sub(%r{^\s*(/\*)}, '/*!')
       end
     end
     content
@@ -140,10 +140,10 @@ class Sass::Tree::Visitors::Convert < Sass::Tree::Visitors::Base
       end
     @is_else = false
     str = "#{tab_str}@#{name}"
-    str << " #{node.expr.to_sass(@options)}" if node.expr
-    str << yield
+    str += " #{node.expr.to_sass(@options)}" if node.expr
+    str += yield
     @is_else = true
-    str << visit(node.else) if node.else
+    str += visit(node.else) if node.else
     str
   ensure
     @is_else = false
@@ -165,13 +165,13 @@ class Sass::Tree::Visitors::Convert < Sass::Tree::Visitors::Base
       else
         '(' + node.args.map do |v, d|
           if d
-            "#{v.to_sass(@options)}: #{d.to_sass(@options)}"
-          else
-            v.to_sass(@options)
-          end
-        end.join(", ") + ')'
+	    "#{v.to_sass(@options)}: #{d.to_sass(@options)}"
+	  else
+	    v.to_sass(@options)
+	  end
+	end.join(", ") + ')'
       end
-          
+
     "#{tab_str}#{@format == :sass ? '=' : '@mixin '}#{dasherize(node.name)}#{args}#{yield}"
   end
 
@@ -199,13 +199,13 @@ class Sass::Tree::Visitors::Convert < Sass::Tree::Visitors::Base
     if @format == :sass
       name = selector_to_sass(node.rule)
       name = "\\" + name if name[0] == ?:
-      name.gsub(/^/, tab_str) + yield
+      return name.lines.map{|l| l.sub(/^/, tab_str)}.join + yield
     elsif @format == :scss
       name = selector_to_scss(node.rule)
       res = name + yield
       if node.children.last.is_a?(Sass::Tree::CommentNode) && node.children.last.silent
-        res.slice!(-3..-1)
-        res << "\n" << tab_str << "}\n"
+	res = res.slice(0...-3)
+	res += "\n" + tab_str + "}\n"
       end
       res
     end
diff --git a/lib/sass/tree/visitors/perform.rb b/lib/sass/tree/visitors/perform.rb
index 46a57c4..c88cdd8 100644
--- a/lib/sass/tree/visitors/perform.rb
+++ b/lib/sass/tree/visitors/perform.rb
@@ -56,7 +56,7 @@ class Sass::Tree::Visitors::Perform < Sass::Tree::Visitors::Base
     check_for_loud_silent_comment node
     check_for_comment_interp node
     node.resolved_value = run_interp_no_strip(node.value)
-    node.resolved_value.gsub!(/\\([\\#])/, '\1')
+    node.resolved_value = node.resolved_value.gsub(/\\([\\#])/, '\1')
     node
   end
 
@@ -252,9 +252,9 @@ END
     res = node.expr.perform(@environment)
     res = res.value if res.is_a?(Sass::Script::String)
     msg = "WARNING: #{res}\n         "
-    msg << @environment.stack_trace.join("\n         ")
+    msg += @environment.stack_trace.join("\n         ")
     # JRuby doesn't automatically add a newline for #warn
-    msg << (RUBY_PLATFORM =~ /java/ ? "\n\n" : "\n")
+    msg += (RUBY_PLATFORM =~ /java/ ? "\n\n" : "\n")
     Sass::Util.sass_warn msg
     []
   ensure
@@ -309,7 +309,7 @@ WARNING
     raise Sass::SyntaxError.new("#{msg} #{node.name} includes itself") if mixins.size == 1
 
     mixins << node.name
-    msg << "\n" << Sass::Util.enum_cons(mixins, 2).map do |m1, m2|
+    msg += "\n" + Sass::Util.enum_cons(mixins, 2).map do |m1, m2|
       "    #{m1} includes #{m2}"
     end.join("\n")
     raise Sass::SyntaxError.new(msg)
@@ -323,7 +323,7 @@ WARNING
     end
 
     files << node.filename << node.imported_file.options[:filename]
-    msg << "\n" << Sass::Util.enum_cons(files, 2).map do |m1, m2|
+    msg += "\n" << Sass::Util.enum_cons(files, 2).map do |m1, m2|
       "    #{m1} imports #{m2}"
     end.join("\n")
     raise Sass::SyntaxError.new(msg)
diff --git a/lib/sass/tree/visitors/to_css.rb b/lib/sass/tree/visitors/to_css.rb
index 13364b5..efcea9a 100644
--- a/lib/sass/tree/visitors/to_css.rb
+++ b/lib/sass/tree/visitors/to_css.rb
@@ -25,25 +25,15 @@ class Sass::Tree::Visitors::ToCss < Sass::Tree::Visitors::Base
     node.children.each do |child|
       next if child.invisible?
       child_str = visit(child)
-      result << child_str + (node.style == :compressed ? '' : "\n")
+      result += child_str + (node.style == :compressed ? '' : "\n")
     end
-    result.rstrip!
+    result = result.rstrip
     return "" if result.empty?
-    result << "\n"
-    unless Sass::Util.ruby1_8? || result.ascii_only?
-      if node.children.first.is_a?(Sass::Tree::CharsetNode)
-        begin
-          encoding = node.children.first.name
-          # Default to big-endian encoding, because we have to decide somehow
-          encoding << 'BE' if encoding =~ /\Autf-(16|32)\Z/i
-          result = result.encode(Encoding.find(encoding))
-        rescue EncodingError
-        end
-      end
-
-      result = "@charset \"#{result.encoding.name}\";#{
+    result += "\n"
+    unless Sass::Util.ruby1_8? || !(result =~ /[^ -~\n]/)
+      result = "@charset \"UTF-8\";#{
         node.style == :compressed ? '' : "\n"
-      }".encode(result.encoding) + result
+      }" + result
     end
     result
   rescue Sass::SyntaxError => e
@@ -59,10 +49,10 @@ class Sass::Tree::Visitors::ToCss < Sass::Tree::Visitors::Base
     return if node.invisible?
     spaces = ('  ' * [@tabs - node.resolved_value[/^ */].size, 0].max)
 
-    content = node.resolved_value.gsub(/^/, spaces).gsub(%r{^(\s*)//(.*)$}) do |md|
+    content = node.resolved_value.lines.map{|l| l.sub(/^/, spaces)}.join.gsub(%r{^(\s*)//(.*)$}) do |md|
       "#{$1}/*#{$2} */"
     end
-    content.gsub!(/\n +(\* *(?!\/))?/, ' ') if (node.style == :compact || node.style == :compressed) && !node.loud
+    content = content.gsub(/\n +(\* *(?!\/))?/, ' ') if (node.style == :compact || node.style == :compressed) && !node.loud
     content
   end
 
@@ -83,20 +73,20 @@ class Sass::Tree::Visitors::ToCss < Sass::Tree::Visitors::Base
       next if child.invisible?
       if node.style == :compact
         if child.is_a?(Sass::Tree::PropNode)
-          with_tabs(first || was_prop ? 0 : @tabs + 1) {result << visit(child) << ' '}
+	  with_tabs(first || was_prop ? 0 : @tabs + 1) {result += visit(child) + ' '}
         else
-          result[-1] = "\n" if was_prop
+	  result = result[0...-1] + "\n" if was_prop
           rendered = with_tabs(@tabs + 1) {visit(child).dup}
           rendered = rendered.lstrip if first
-          result << rendered.rstrip + "\n"
+	  result += rendered.rstrip + "\n"
         end
         was_prop = child.is_a?(Sass::Tree::PropNode)
         first = false
       elsif node.style == :compressed
-        result << (was_prop ? ";" : "") << with_tabs(0) {visit(child)}
+	result += (was_prop ? ";" : "") + with_tabs(0) {visit(child)}
         was_prop = child.is_a?(Sass::Tree::PropNode)
       else
-        result << with_tabs(@tabs + 1) {visit(child)} + "\n"
+	result += with_tabs(@tabs + 1) {visit(child)} + "\n"
       end
     end
     result.rstrip + if node.style == :compressed
@@ -110,7 +100,9 @@ class Sass::Tree::Visitors::ToCss < Sass::Tree::Visitors::Base
 
   def visit_media(node)
     str = with_tabs(@tabs + node.tabs) {visit_directive(node)}
-    str.gsub!(/\n\Z/, '') unless node.style == :compressed || node.group_end
+    unless node.style == :compressed || node.group_end
+      str = str[0..-2] if str[-1] == "\n"
+    end
     str
   end
 
@@ -138,29 +130,29 @@ class Sass::Tree::Visitors::ToCss < Sass::Tree::Visitors::Base
       joined_rules = node.resolved_rules.members.map do |seq|
         rule_part = seq.to_a.join
         if node.style == :compressed
-          rule_part.gsub!(/([^,])\s*\n\s*/m, '\1 ')
-          rule_part.gsub!(/\s*([,+>])\s*/m, '\1')
-          rule_part.strip!
+	  rule_part = rule_part.gsub(/([^,])\s*\n\s*/m, '\1 ')
+	  rule_part = rule_part.gsub(/\s*([,+>])\s*/m, '\1')
+	  rule_part = rule_part.strip
         end
         rule_part
       end.join(rule_separator)
 
-      joined_rules.sub!(/\A\s*/, per_rule_indent)
-      joined_rules.gsub!(/\s*\n\s*/, "#{line_separator}#{per_rule_indent}")
-      total_rule = total_indent << joined_rules
+      joined_rules = joined_rules.sub(/^\s*/, per_rule_indent)
+      joined_rules = joined_rules.gsub(/\s*\n\s*/, "#{line_separator}#{per_rule_indent}")
+      total_rule = total_indent += joined_rules
 
       to_return = ''
       old_spaces = '  ' * @tabs
       spaces = '  ' * (@tabs + 1)
       if node.style != :compressed
         if node.options[:debug_info] && !@in_directive
-          to_return << visit(debug_info_rule(node.debug_info, node.options)) << "\n"
+	  to_return += visit(debug_info_rule(node.debug_info, node.options)) + "\n"
         elsif node.options[:trace_selectors]
-          to_return << "#{old_spaces}/* "
-          to_return << node.stack_trace.join("\n   #{old_spaces}")
-          to_return << " */\n"
+	  to_return += "#{old_spaces}/* "
+	  to_return += node.stack_trace.join("\n   #{old_spaces}")
+	  to_return += " */\n"
         elsif node.options[:line_comments]
-          to_return << "#{old_spaces}/* line #{node.line}"
+	  to_return += "#{old_spaces}/* line #{node.line}"
 
           if node.filename
             relative_filename = if node.options[:css_filename]
@@ -172,23 +164,23 @@ class Sass::Tree::Visitors::ToCss < Sass::Tree::Visitors::Base
               end
             end
             relative_filename ||= node.filename
-            to_return << ", #{relative_filename}"
+	    to_return += ", #{relative_filename}"
           end
 
-          to_return << " */\n"
+	  to_return += " */\n"
         end
       end
 
       if node.style == :compact
         properties = with_tabs(0) {node.children.map {|a| visit(a)}.join(' ')}
-        to_return << "#{total_rule} { #{properties} }#{"\n" if node.group_end}"
+	to_return += "#{total_rule} { #{properties} }#{"\n" if node.group_end}"
       elsif node.style == :compressed
         properties = with_tabs(0) {node.children.map {|a| visit(a)}.join(';')}
-        to_return << "#{total_rule}{#{properties}}"
+	to_return += "#{total_rule}{#{properties}}"
       else
         properties = with_tabs(@tabs + 1) {node.children.map {|a| visit(a)}.join("\n")}
         end_props = (node.style == :expanded ? "\n" + old_spaces : ' ')
-        to_return << "#{total_rule} {\n#{properties}#{end_props}}#{"\n" if node.group_end}"
+	to_return += "#{total_rule} {\n#{properties}#{end_props}}#{"\n" if node.group_end}"
       end
 
       to_return
diff --git a/lib/sass/util.rb b/lib/sass/util.rb
index bc436ab..e265eaa 100644
--- a/lib/sass/util.rb
+++ b/lib/sass/util.rb
@@ -134,7 +134,7 @@ module Sass
       arr.inject([]) do |a, e|
         if e.is_a?(String)
           if a.last.is_a?(String)
-            a.last << e
+	    a[-1] = a.last + e
           else
             a << e.dup
           end
@@ -179,8 +179,8 @@ module Sass
     # @param arr [Array]
     # @return [Array] `arr`
     def strip_string_array(arr)
-      arr.first.lstrip! if arr.first.is_a?(String)
-      arr.last.rstrip! if arr.last.is_a?(String)
+      arr[0] = arr.first.lstrip if arr.first.is_a?(String)
+      arr[-1] = arr.last.rstrip if arr.last.is_a?(String)
       arr
     end
 
@@ -477,29 +477,7 @@ module Sass
     # @yieldparam msg [String] The error message to be raised
     # @return [String] `str`, potentially with encoding gotchas like BOMs removed
     def check_encoding(str)
-      if ruby1_8?
-        return str.gsub(/\A\xEF\xBB\xBF/, '') # Get rid of the UTF-8 BOM
-      elsif str.valid_encoding?
-        # Get rid of the Unicode BOM if possible
-        if str.encoding.name =~ /^UTF-(8|16|32)(BE|LE)?$/
-          return str.gsub(Regexp.new("\\A\uFEFF".encode(str.encoding.name)), '')
-        else
-          return str
-        end
-      end
-
-      encoding = str.encoding
-      newlines = Regexp.new("\r\n|\r|\n".encode(encoding).force_encoding("binary"))
-      str.force_encoding("binary").split(newlines).each_with_index do |line, i|
-        begin
-          line.encode(encoding)
-        rescue Encoding::UndefinedConversionError => e
-          yield <<MSG.rstrip, i + 1
-Invalid #{encoding.name} character #{e.error_char.dump}
-MSG
-        end
-      end
-      return str
+      str
     end
 
     # Like {\#check\_encoding}, but also checks for a `@charset` declaration
@@ -522,30 +500,7 @@ MSG
     #   cannot be converted to UTF-8
     # @raise [ArgumentError] if the document uses an unknown encoding with `@charset`
     def check_sass_encoding(str, &block)
-      return check_encoding(str, &block), nil if ruby1_8?
-      # We allow any printable ASCII characters but double quotes in the charset decl
-      bin = str.dup.force_encoding("BINARY")
-      encoding = Sass::Util::ENCODINGS_TO_CHECK.find do |enc|
-        re = Sass::Util::CHARSET_REGEXPS[enc]
-        re && bin =~ re
-      end
-      charset, bom = $1, $2
-      if charset
-        charset = charset.force_encoding(encoding).encode("UTF-8")
-        if endianness = encoding[/[BL]E$/]
-          begin
-            Encoding.find(charset + endianness)
-            charset << endianness
-          rescue ArgumentError # Encoding charset + endianness doesn't exist
-          end
-        end
-        str.force_encoding(charset)
-      elsif bom
-        str.force_encoding(encoding)
-      end
-
-      str = check_encoding(str, &block)
-      return str.encode("UTF-8"), str.encoding
+      return str, str.encoding
     end
 
     unless ruby1_8?
@@ -559,20 +514,20 @@ MSG
       # without manually checking that each encoding
       # encodes all ASCII characters properly,
       # which takes long enough to affect the startup time of the CLI.
-      ENCODINGS_TO_CHECK = %w[UTF-8 UTF-16BE UTF-16LE UTF-32BE UTF-32LE]
+      ENCODINGS_TO_CHECK = %w[UTF-8]
 
       CHARSET_REGEXPS = Hash.new do |h, e|
         h[e] =
           begin
-            # /\A(?:\uFEFF)?@charset "(.*?)"|\A(\uFEFF)/
-            Regexp.new(/\A(?:#{_enc("\uFEFF", e)})?#{
-              _enc('@charset "', e)}(.*?)#{_enc('"', e)}|\A(#{
+	    # /^(?:\uFEFF)?@charset "(.*?)"|^(\uFEFF)/
+	    Regexp.new(/^(?:#{_enc("\uFEFF", e)})?#{
+	      _enc('@charset "', e)}(.*?)#{_enc('"', e)}|^(#{
               _enc("\uFEFF", e)})/)
           rescue Encoding::ConverterNotFound => _
             nil # JRuby on Java 5 doesn't support UTF-32
           rescue
-            # /\A@charset "(.*?)"/
-            Regexp.new(/\A#{_enc('@charset "', e)}(.*?)#{_enc('"', e)}/)
+	    # /^@charset "(.*?)"/
+	    Regexp.new(/^#{_enc('@charset "', e)}(.*?)#{_enc('"', e)}/)
           end
       end
     end
diff --git a/lib/sass/util/multibyte_string_scanner.rb b/lib/sass/util/multibyte_string_scanner.rb
index 890f2a8..d78f50c 100644
--- a/lib/sass/util/multibyte_string_scanner.rb
+++ b/lib/sass/util/multibyte_string_scanner.rb
@@ -20,11 +20,18 @@ else
       @mb_last_pos = nil
     end
 
-    alias_method :byte_pos, :pos
+    def byte_pos
+      %x{utf8.encode(self.string.slice(0, #@mb_pos)).length}
+    end
     alias_method :byte_matched_size, :matched_size
 
     def check(pattern); _match super; end
-    def check_until(pattern); _matched super; end
+    def check_until(pattern);
+      last_pos = @mb_pos
+      ret = _matched super;
+      @mb_pos = last_pos
+      ret
+    end
     def getch; _forward _match super; end
     def match?(pattern); _size check(pattern); end
     def matched_size; @mb_matched_size; end
@@ -58,7 +65,9 @@ else
       # if the new position is close to the current one, just count the
       # characters between the two; if the new position is closer to the
       # beginning of the string, just count the characters from there.
-      if @mb_pos - n < @mb_pos / 2
+      if RUBY_PLATFORM.eql? 'opal'
+	super(n)
+      elsif @mb_pos - n < @mb_pos / 2
         # New position is close to old position
         byte_delta = @mb_pos > n ? -string[n...@mb_pos].bytesize : string[@mb_pos...n].bytesize
         super(byte_pos + byte_delta)
diff --git a/lib/sass/version.rb b/lib/sass/version.rb
index 3804f5f..1c4ec41 100644
--- a/lib/sass/version.rb
+++ b/lib/sass/version.rb
@@ -1,112 +1,8 @@
-# This is necessary for loading Sass when Haml is required in Rails 3.
-# Once the split is complete, we can remove it.
-require File.dirname(__FILE__) + '/../sass'
-require 'sass/util'
+A="3.1.19 (Brainy Betty)"
 
 module Sass
-  # Handles Sass version-reporting.
-  # Sass not only reports the standard three version numbers,
-  # but its Git revision hash as well,
-  # if it was installed from Git.
   module Version
-    include Sass::Util
-
-    # Returns a hash representing the version of Sass.
-    # The `:major`, `:minor`, and `:teeny` keys have their respective numbers as Fixnums.
-    # The `:name` key has the name of the version.
-    # The `:string` key contains a human-readable string representation of the version.
-    # The `:number` key is the major, minor, and teeny keys separated by periods.
-    # If Sass is checked out from Git, the `:rev` key will have the revision hash.
-    # For example:
-    #
-    #     {
-    #       :string => "2.1.0.9616393",
-    #       :rev    => "9616393b8924ef36639c7e82aa88a51a24d16949",
-    #       :number => "2.1.0",
-    #       :major  => 2, :minor => 1, :teeny => 0
-    #     }
-    #
-    # If a prerelease version of Sass is being used,
-    # the `:string` and `:number` fields will reflect the full version
-    # (e.g. `"2.2.beta.1"`), and the `:teeny` field will be `-1`.
-    # A `:prerelease` key will contain the name of the prerelease (e.g. `"beta"`),
-    # and a `:prerelease_number` key will contain the rerelease number.
-    # For example:
-    #
-    #     {
-    #       :string => "3.0.beta.1",
-    #       :number => "3.0.beta.1",
-    #       :major => 3, :minor => 0, :teeny => -1,
-    #       :prerelease => "beta",
-    #       :prerelease_number => 1
-    #     }
-    #
-    # @return [{Symbol => String/Fixnum}] The version hash
-    def version
-      return @@version if defined?(@@version)
-
-      numbers = File.read(scope('VERSION')).strip.split('.').
-        map {|n| n =~ /^[0-9]+$/ ? n.to_i : n}
-      name = File.read(scope('VERSION_NAME')).strip
-      @@version = {
-        :major => numbers[0],
-        :minor => numbers[1],
-        :teeny => numbers[2],
-        :name => name
-      }
-
-      if numbers[3].is_a?(String)
-        @@version[:teeny] = -1
-        @@version[:prerelease] = numbers[3]
-        @@version[:prerelease_number] = numbers[4]
-      end
-
-      @@version[:number] = numbers.join('.')
-      @@version[:string] = @@version[:number].dup
-
-      if rev = revision_number
-        @@version[:rev] = rev
-        unless rev[0] == ?(
-          @@version[:string] << "." << rev[0...7]
-        end
-      end
-
-      @@version[:string] << " (#{name})"
-      @@version
-    end
-
-    private
-
-    def revision_number
-      if File.exists?(scope('REVISION'))
-        rev = File.read(scope('REVISION')).strip
-        return rev unless rev =~ /^([a-f0-9]+|\(.*\))$/ || rev == '(unknown)'
-      end
-
-      return unless File.exists?(scope('.git/HEAD'))
-      rev = File.read(scope('.git/HEAD')).strip
-      return rev unless rev =~ /^ref: (.*)$/
-
-      ref_name = $1
-      ref_file = scope(".git/#{ref_name}")
-      info_file = scope(".git/info/refs")
-      return File.read(ref_file).strip if File.exists?(ref_file)
-      return unless File.exists?(info_file)
-      File.open(info_file) do |f|
-        f.each do |l|
-          sha, ref = l.strip.split("\t", 2)
-          next unless ref == ref_name
-          return sha
-        end
-      end
-      return nil
-    end
+    A
   end
-
-  extend Sass::Version
-
-  # A string representing the version of Sass.
-  # A more fine-grained representation is available from Sass.version.
-  # @api public
-  VERSION = version[:string] unless defined?(Sass::VERSION)
+  VERSION = A
 end
-- 
2.10.0

