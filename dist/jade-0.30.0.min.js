/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmory imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmory exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		Object.defineProperty(exports, name, {
/******/ 			configurable: false,
/******/ 			enumerable: true,
/******/ 			get: getter
/******/ 		});
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 41);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports) {


/*!
 * Jade - nodes - Node
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Initialize a `Node`.
 *
 * @api public
 */

var Node = module.exports = function Node(){};

/**
 * Clone this node (return itself)
 *
 * @return {Node}
 * @api private
 */

Node.prototype.clone = function(){
  return this;
};


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ },
/* 2 */
/***/ function(module, exports) {



/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {


/*!
 * Jade - nodes - Block
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Node = __webpack_require__(0);

/**
 * Initialize a new `Block` with an optional `node`.
 *
 * @param {Node} node
 * @api public
 */

var Block = module.exports = function Block(node){
  this.nodes = [];
  if (node) this.push(node);
};

/**
 * Inherit from `Node`.
 */

Block.prototype.__proto__ = Node.prototype;

/**
 * Block flag.
 */

Block.prototype.isBlock = true;

/**
 * Replace the nodes in `other` with the nodes
 * in `this` block.
 *
 * @param {Block} other
 * @api private
 */

Block.prototype.replace = function(other){
  other.nodes = this.nodes;
};

/**
 * Pust the given `node`.
 *
 * @param {Node} node
 * @return {Number}
 * @api public
 */

Block.prototype.push = function(node){
  return this.nodes.push(node);
};

/**
 * Check if this block is empty.
 *
 * @return {Boolean}
 * @api public
 */

Block.prototype.isEmpty = function(){
  return 0 == this.nodes.length;
};

/**
 * Unshift the given `node`.
 *
 * @param {Node} node
 * @return {Number}
 * @api public
 */

Block.prototype.unshift = function(node){
  return this.nodes.unshift(node);
};

/**
 * Return the "last" block, or the first `yield` node.
 *
 * @return {Block}
 * @api private
 */

Block.prototype.includeBlock = function(){
  var ret = this
    , node;

  for (var i = 0, len = this.nodes.length; i < len; ++i) {
    node = this.nodes[i];
    if (node.yield) return node;
    else if (node.textOnly) continue;
    else if (node.includeBlock) ret = node.includeBlock();
    else if (node.block && !node.block.isEmpty()) ret = node.block.includeBlock();
    if (ret.yield) return ret;
  }

  return ret;
};

/**
 * Return a clone of this block.
 *
 * @return {Block}
 * @api private
 */

Block.prototype.clone = function(){
  var clone = new Block;
  for (var i = 0, len = this.nodes.length; i < len; ++i) {
    clone.push(this.nodes[i].clone());
  }
  return clone;
};



/***/ },
/* 4 */
/***/ function(module, exports) {


/*!
 * Jade - utils
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Merge `b` into `a`.
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object}
 * @api public
 */

exports.merge = function(a, b) {
  for (var key in b) a[key] = b[key];
  return a;
};



/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

/*!
 * Jade - filters
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

var transformers = __webpack_require__(37);

module.exports = filter;
function filter(name, str, options) {
  if (typeof filter[name] === 'function') {
    var res = filter[name](str, options);
  } else if (transformers[name]) {
    var res = transformers[name].renderSync(str, options);
    if (transformers[name].outputFormat === 'js') {
      res = '<script type="text/javascript">\n' + res + '</script>';
    } else if (transformers[name].outputFormat === 'css') {
      res = '<style type="text/css">' + res + '</style>';
    } else if (transformers[name].outputFormat === 'xml') {
      res = res.replace(/'/g, '&#39;');
    }
  } else {
    throw new Error('unknown filter ":' + name + '"');
  }
  return res;
}
filter.exists = function (name, str, options) {
  return typeof filter[name] === 'function' || transformers[name];
};


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {


/*!
 * Jade - nodes
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

exports.Node = __webpack_require__(0);
exports.Tag = __webpack_require__(28);
exports.Code = __webpack_require__(21);
exports.Each = __webpack_require__(24);
exports.Case = __webpack_require__(20);
exports.Text = __webpack_require__(29);
exports.Block = __webpack_require__(3);
exports.Mixin = __webpack_require__(27);
exports.Filter = __webpack_require__(25);
exports.Comment = __webpack_require__(22);
exports.Literal = __webpack_require__(26);
exports.BlockComment = __webpack_require__(19);
exports.Doctype = __webpack_require__(23);


/***/ },
/* 7 */
/***/ function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ },
/* 8 */
/***/ function(module, exports) {


/*!
 * Jade - doctypes
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

module.exports = {
    '5': '<!DOCTYPE html>'
  , 'default': '<!DOCTYPE html>'
  , 'xml': '<?xml version="1.0" encoding="utf-8" ?>'
  , 'transitional': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'
  , 'strict': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">'
  , 'frameset': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">'
  , '1.1': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">'
  , 'basic': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML Basic 1.1//EN" "http://www.w3.org/TR/xhtml-basic/xhtml-basic11.dtd">'
  , 'mobile': '<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.2//EN" "http://www.openmobilealliance.org/tech/DTD/xhtml-mobile12.dtd">'
};

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

/*!
 * Jade - Lexer
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

var utils = __webpack_require__(4);
var parseJSExpression = __webpack_require__(13).parseMax;

/**
 * Initialize `Lexer` with the given `str`.
 *
 * Options:
 *
 *   - `colons` allow colons for attr delimiters
 *
 * @param {String} str
 * @param {Object} options
 * @api private
 */

var Lexer = module.exports = function Lexer(str, options) {
  options = options || {};
  this.input = str.replace(/\r\n|\r/g, '\n');
  this.colons = options.colons;
  this.deferredTokens = [];
  this.lastIndents = 0;
  this.lineno = 1;
  this.stash = [];
  this.indentStack = [];
  this.indentRe = null;
  this.pipeless = false;
};

/**
 * Lexer prototype.
 */

Lexer.prototype = {
  
  /**
   * Construct a token with the given `type` and `val`.
   *
   * @param {String} type
   * @param {String} val
   * @return {Object}
   * @api private
   */
  
  tok: function(type, val){
    return {
        type: type
      , line: this.lineno
      , val: val
    }
  },
  
  /**
   * Consume the given `len` of input.
   *
   * @param {Number} len
   * @api private
   */
  
  consume: function(len){
    this.input = this.input.substr(len);
  },
  
  /**
   * Scan for `type` with the given `regexp`.
   *
   * @param {String} type
   * @param {RegExp} regexp
   * @return {Object}
   * @api private
   */
  
  scan: function(regexp, type){
    var captures;
    if (captures = regexp.exec(this.input)) {
      this.consume(captures[0].length);
      return this.tok(type, captures[1]);
    }
  },
  
  /**
   * Defer the given `tok`.
   *
   * @param {Object} tok
   * @api private
   */
  
  defer: function(tok){
    this.deferredTokens.push(tok);
  },
  
  /**
   * Lookahead `n` tokens.
   *
   * @param {Number} n
   * @return {Object}
   * @api private
   */
  
  lookahead: function(n){
    var fetch = n - this.stash.length;
    while (fetch-- > 0) this.stash.push(this.next());
    return this.stash[--n];
  },
  
  /**
   * Return the indexOf `(` or `{` or `[` / `)` or `}` or `]` delimiters.
   *
   * @return {Number}
   * @api private
   */
  
  bracketExpression: function(skip){
    skip = skip || 0;
    var start = this.input[skip];
    if (start != '(' && start != '{' && start != '[') throw new Error('unrecognized start character');
    var end = ({'(': ')', '{': '}', '[': ']'})[start];
    var range = parseJSExpression(this.input, {start: skip + 1});
    if (this.input[range.end] !== end) throw new Error('start character ' + start + ' does not match end character ' + this.input[range.end]);
    return range;
  },
  
  /**
   * Stashed token.
   */
  
  stashed: function() {
    return this.stash.length
      && this.stash.shift();
  },
  
  /**
   * Deferred token.
   */
  
  deferred: function() {
    return this.deferredTokens.length 
      && this.deferredTokens.shift();
  },
  
  /**
   * end-of-source.
   */
  
  eos: function() {
    if (this.input.length) return;
    if (this.indentStack.length) {
      this.indentStack.shift();
      return this.tok('outdent');
    } else {
      return this.tok('eos');
    }
  },

  /**
   * Blank line.
   */
  
  blank: function() {
    var captures;
    if (captures = /^\n *\n/.exec(this.input)) {
      this.consume(captures[0].length - 1);
      ++this.lineno;
      if (this.pipeless) return this.tok('text', '');
      return this.next();
    }
  },

  /**
   * Comment.
   */
  
  comment: function() {
    var captures;
    if (captures = /^ *\/\/(-)?([^\n]*)/.exec(this.input)) {
      this.consume(captures[0].length);
      var tok = this.tok('comment', captures[2]);
      tok.buffer = '-' != captures[1];
      return tok;
    }
  },

  /**
   * Interpolated tag.
   */

  interpolation: function() {
    if (/^#\{/.test(this.input)) {
      var match;
      try {
        match = this.bracketExpression(1);
      } catch (ex) {
        return;//not an interpolation expression, just an unmatched open interpolation
      }

      this.consume(match.end + 1);
      return this.tok('interpolation', match.src);
    }
  },

  /**
   * Tag.
   */
  
  tag: function() {
    var captures;
    if (captures = /^(\w[-:\w]*)(\/?)/.exec(this.input)) {
      this.consume(captures[0].length);
      var tok, name = captures[1];
      if (':' == name[name.length - 1]) {
        name = name.slice(0, -1);
        tok = this.tok('tag', name);
        this.defer(this.tok(':'));
        while (' ' == this.input[0]) this.input = this.input.substr(1);
      } else {
        tok = this.tok('tag', name);
      }
      tok.selfClosing = !! captures[2];
      return tok;
    }
  },
  
  /**
   * Filter.
   */
  
  filter: function() {
    return this.scan(/^:(\w+)/, 'filter');
  },
  
  /**
   * Doctype.
   */
  
  doctype: function() {
    return this.scan(/^(?:!!!|doctype) *([^\n]+)?/, 'doctype');
  },

  /**
   * Id.
   */
  
  id: function() {
    return this.scan(/^#([\w-]+)/, 'id');
  },
  
  /**
   * Class.
   */
  
  className: function() {
    return this.scan(/^\.([\w-]+)/, 'class');
  },
  
  /**
   * Text.
   */
  
  text: function() {
    return this.scan(/^(?:\| ?| ?)?([^\n]+)/, 'text');
  },

  /**
   * Extends.
   */
  
  "extends": function() {
    return this.scan(/^extends? +([^\n]+)/, 'extends');
  },

  /**
   * Block prepend.
   */
  
  prepend: function() {
    var captures;
    if (captures = /^prepend +([^\n]+)/.exec(this.input)) {
      this.consume(captures[0].length);
      var mode = 'prepend'
        , name = captures[1]
        , tok = this.tok('block', name);
      tok.mode = mode;
      return tok;
    }
  },
  
  /**
   * Block append.
   */
  
  append: function() {
    var captures;
    if (captures = /^append +([^\n]+)/.exec(this.input)) {
      this.consume(captures[0].length);
      var mode = 'append'
        , name = captures[1]
        , tok = this.tok('block', name);
      tok.mode = mode;
      return tok;
    }
  },

  /**
   * Block.
   */
  
  block: function() {
    var captures;
    if (captures = /^block\b *(?:(prepend|append) +)?([^\n]*)/.exec(this.input)) {
      this.consume(captures[0].length);
      var mode = captures[1] || 'replace'
        , name = captures[2]
        , tok = this.tok('block', name);

      tok.mode = mode;
      return tok;
    }
  },

  /**
   * Yield.
   */
  
  yield: function() {
    return this.scan(/^yield */, 'yield');
  },

  /**
   * Include.
   */
  
  include: function() {
    return this.scan(/^include +([^\n]+)/, 'include');
  },

  /**
   * Case.
   */
  
  "case": function() {
    return this.scan(/^case +([^\n]+)/, 'case');
  },

  /**
   * When.
   */
  
  when: function() {
    return this.scan(/^when +([^:\n]+)/, 'when');
  },

  /**
   * Default.
   */
  
  "default": function() {
    return this.scan(/^default */, 'default');
  },

  /**
   * Assignment.
   */
  
  assignment: function() {
    var captures;
    if (captures = /^(\w+) += *([^;\n]+)( *;? *)/.exec(this.input)) {
      this.consume(captures[0].length);
      var name = captures[1]
        , val = captures[2];
      return this.tok('code', 'var ' + name + ' = (' + val + ');');
    }
  },

  /**
   * Call mixin.
   */
  
  call: function(){
    var captures;
    if (captures = /^\+([-\w]+)/.exec(this.input)) {
      this.consume(captures[0].length);
      var tok = this.tok('call', captures[1]);

      // Check for args (not attributes)
      if (captures = /^ *\(/.exec(this.input)) {
        try {
          var range = this.bracketExpression(captures[0].length - 1);
          if (!/^ *[-\w]+ *=/.test(range.src)) { // not attributes
            this.consume(range.end + 1);
            tok.args = range.src;
          }
        } catch (ex) {
          //not a bracket expcetion, just unmatched open parens
        }
      }
      
      return tok;
    }
  },

  /**
   * Mixin.
   */

  mixin: function(){
    var captures;
    if (captures = /^mixin +([-\w]+)(?: *\((.*)\))?/.exec(this.input)) {
      this.consume(captures[0].length);
      var tok = this.tok('mixin', captures[1]);
      tok.args = captures[2];
      return tok;
    }
  },

  /**
   * Conditional.
   */
  
  conditional: function() {
    var captures;
    if (captures = /^(if|unless|else if|else)\b([^\n]*)/.exec(this.input)) {
      this.consume(captures[0].length);
      var type = captures[1]
        , js = captures[2];

      switch (type) {
        case 'if': js = 'if (' + js + ')'; break;
        case 'unless': js = 'if (!(' + js + '))'; break;
        case 'else if': js = 'else if (' + js + ')'; break;
        case 'else': js = 'else'; break;
      }

      return this.tok('code', js);
    }
  },

  /**
   * While.
   */
  
  "while": function() {
    var captures;
    if (captures = /^while +([^\n]+)/.exec(this.input)) {
      this.consume(captures[0].length);
      return this.tok('code', 'while (' + captures[1] + ')');
    }
  },

  /**
   * Each.
   */
  
  each: function() {
    var captures;
    if (captures = /^(?:- *)?(?:each|for) +(\w+)(?: *, *(\w+))? * in *([^\n]+)/.exec(this.input)) {
      this.consume(captures[0].length);
      var tok = this.tok('each', captures[1]);
      tok.key = captures[2] || '$index';
      tok.code = captures[3];
      return tok;
    }
  },
  
  /**
   * Code.
   */
  
  code: function() {
    var captures;
    if (captures = /^(!?=|-)[ \t]*([^\n]+)/.exec(this.input)) {
      this.consume(captures[0].length);
      var flags = captures[1];
      captures[1] = captures[2];
      var tok = this.tok('code', captures[1]);
      tok.escape = flags.charAt(0) === '=';
      tok.buffer = flags.charAt(0) === '=' || flags.charAt(1) === '=';
      return tok;
    }
  },
  
  /**
   * Attributes.
   */
  
  attrs: function() {
    if ('(' == this.input.charAt(0)) {
      var index = this.bracketExpression().end
        , str = this.input.substr(1, index-1)
        , tok = this.tok('attrs')
        , len = str.length
        , colons = this.colons
        , states = ['key']
        , escapedAttr
        , key = ''
        , val = ''
        , quote
        , c
        , p;

      function state(){
        return states[states.length - 1];
      }

      function interpolate(attr) {
        return attr.replace(/(\\)?#\{(.+)/g, function(_, escape, expr){
          if (escape) return _;
          try {
            var range = parseJSExpression(expr);
            if (expr[range.end] !== '}') return _.substr(0, 2) + interpolate(_.substr(2));
            return quote + " + (" + range.src + ") + " + quote + interpolate(expr.substr(range.end + 1));
          } catch (ex) {
            return _.substr(0, 2) + interpolate(_.substr(2));
          }
        });
      }

      this.consume(index + 1);
      tok.attrs = {};
      tok.escaped = {};

      function parse(c) {
        var real = c;
        // TODO: remove when people fix ":"
        if (colons && ':' == c) c = '=';
        switch (c) {
          case ',':
          case '\n':
            switch (state()) {
              case 'expr':
              case 'array':
              case 'string':
              case 'object':
                val += c;
                break;
              default:
                states.push('key');
                val = val.trim();
                key = key.trim();
                if ('' == key) return;
                key = key.replace(/^['"]|['"]$/g, '').replace('!', '');
                tok.escaped[key] = escapedAttr;
                tok.attrs[key] = '' == val
                  ? true
                  : interpolate(val);
                key = val = '';
            }
            break;
          case '=':
            switch (state()) {
              case 'key char':
                key += real;
                break;
              case 'val':
              case 'expr':
              case 'array':
              case 'string':
              case 'object':
                val += real;
                break;
              default:
                escapedAttr = '!' != p;
                states.push('val');
            }
            break;
          case '(':
            if ('val' == state()
              || 'expr' == state()) states.push('expr');
            val += c;
            break;
          case ')':
            if ('expr' == state()
              || 'val' == state()) states.pop();
            val += c;
            break;
          case '{':
            if ('val' == state()) states.push('object');
            val += c;
            break;
          case '}':
            if ('object' == state()) states.pop();
            val += c;
            break;
          case '[':
            if ('val' == state()) states.push('array');
            val += c;
            break;
          case ']':
            if ('array' == state()) states.pop();
            val += c;
            break;
          case '"':
          case "'":
            switch (state()) {
              case 'key':
                states.push('key char');
                break;
              case 'key char':
                states.pop();
                break;
              case 'string':
                if (c == quote) states.pop();
                val += c;
                break;
              default:
                states.push('string');
                val += c;
                quote = c;
            }
            break;
          case '':
            break;
          default:
            switch (state()) {
              case 'key':
              case 'key char':
                key += c;
                break;
              default:
                val += c;
            }
        }
        p = c;
      }

      for (var i = 0; i < len; ++i) {
        parse(str.charAt(i));
      }

      parse(',');

      if ('/' == this.input.charAt(0)) {
        this.consume(1);
        tok.selfClosing = true;
      }

      return tok;
    }
  },
  
  /**
   * Indent | Outdent | Newline.
   */
  
  indent: function() {
    var captures, re;

    // established regexp
    if (this.indentRe) {
      captures = this.indentRe.exec(this.input);
    // determine regexp
    } else {
      // tabs
      re = /^\n(\t*) */;
      captures = re.exec(this.input);

      // spaces
      if (captures && !captures[1].length) {
        re = /^\n( *)/;
        captures = re.exec(this.input);
      }

      // established
      if (captures && captures[1].length) this.indentRe = re;
    }

    if (captures) {
      var tok
        , indents = captures[1].length;

      ++this.lineno;
      this.consume(indents + 1);

      if (' ' == this.input[0] || '\t' == this.input[0]) {
        throw new Error('Invalid indentation, you can use tabs or spaces but not both');
      }

      // blank line
      if ('\n' == this.input[0]) return this.tok('newline');

      // outdent
      if (this.indentStack.length && indents < this.indentStack[0]) {
        while (this.indentStack.length && this.indentStack[0] > indents) {
          this.stash.push(this.tok('outdent'));
          this.indentStack.shift();
        }
        tok = this.stash.pop();
      // indent
      } else if (indents && indents != this.indentStack[0]) {
        this.indentStack.unshift(indents);
        tok = this.tok('indent', indents);
      // newline
      } else {
        tok = this.tok('newline');
      }

      return tok;
    }
  },

  /**
   * Pipe-less text consumed only when 
   * pipeless is true;
   */

  pipelessText: function() {
    if (this.pipeless) {
      if ('\n' == this.input[0]) return;
      var i = this.input.indexOf('\n');
      if (-1 == i) i = this.input.length;
      var str = this.input.substr(0, i);
      this.consume(str.length);
      return this.tok('text', str);
    }
  },

  /**
   * ':'
   */

  colon: function() {
    return this.scan(/^: */, ':');
  },

  /**
   * Return the next token object, or those
   * previously stashed by lookahead.
   *
   * @return {Object}
   * @api private
   */
  
  advance: function(){
    return this.stashed()
      || this.next();
  },
  
  /**
   * Return the next token object.
   *
   * @return {Object}
   * @api private
   */
  
  next: function() {
    return this.deferred()
      || this.blank()
      || this.eos()
      || this.pipelessText()
      || this.yield()
      || this.doctype()
      || this.interpolation()
      || this["case"]()
      || this.when()
      || this["default"]()
      || this["extends"]()
      || this.append()
      || this.prepend()
      || this.block()
      || this.include()
      || this.mixin()
      || this.call()
      || this.conditional()
      || this.each()
      || this["while"]()
      || this.assignment()
      || this.tag()
      || this.filter()
      || this.code()
      || this.id()
      || this.className()
      || this.attrs()
      || this.indent()
      || this.comment()
      || this.colon()
      || this.text();
  }
};


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {


/*!
 * Jade - nodes - Attrs
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Node = __webpack_require__(0),
    Block = __webpack_require__(3);

/**
 * Initialize a `Attrs` node.
 *
 * @api public
 */

var Attrs = module.exports = function Attrs() {
  this.attrs = [];
};

/**
 * Inherit from `Node`.
 */

Attrs.prototype.__proto__ = Node.prototype;

/**
 * Set attribute `name` to `val`, keep in mind these become
 * part of a raw js object literal, so to quote a value you must
 * '"quote me"', otherwise or example 'user.name' is literal JavaScript.
 *
 * @param {String} name
 * @param {String} val
 * @param {Boolean} escaped
 * @return {Tag} for chaining
 * @api public
 */

Attrs.prototype.setAttribute = function(name, val, escaped){
  this.attrs.push({ name: name, val: val, escaped: escaped });
  return this;
};

/**
 * Remove attribute `name` when present.
 *
 * @param {String} name
 * @api public
 */

Attrs.prototype.removeAttribute = function(name){
  for (var i = 0, len = this.attrs.length; i < len; ++i) {
    if (this.attrs[i] && this.attrs[i].name == name) {
      delete this.attrs[i];
    }
  }
};

/**
 * Get attribute value by `name`.
 *
 * @param {String} name
 * @return {String}
 * @api public
 */

Attrs.prototype.getAttribute = function(name){
  for (var i = 0, len = this.attrs.length; i < len; ++i) {
    if (this.attrs[i] && this.attrs[i].name == name) {
      return this.attrs[i].val;
    }
  }
};


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {


/*!
 * Jade - runtime
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Lame Array.isArray() polyfill for now.
 */

if (!Array.isArray) {
  Array.isArray = function(arr){
    return '[object Array]' == Object.prototype.toString.call(arr);
  };
}

/**
 * Lame Object.keys() polyfill for now.
 */

if (!Object.keys) {
  Object.keys = function(obj){
    var arr = [];
    for (var key in obj) {
      if (obj.hasOwnProperty(key)) {
        arr.push(key);
      }
    }
    return arr;
  }
}

/**
 * Merge two attribute objects giving precedence
 * to values in object `b`. Classes are special-cased
 * allowing for arrays and merging/joining appropriately
 * resulting in a string.
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 * @api private
 */

exports.merge = function merge(a, b) {
  var ac = a['class'];
  var bc = b['class'];

  if (ac || bc) {
    ac = ac || [];
    bc = bc || [];
    if (!Array.isArray(ac)) ac = [ac];
    if (!Array.isArray(bc)) bc = [bc];
    ac = ac.filter(nulls);
    bc = bc.filter(nulls);
    a['class'] = ac.concat(bc).join(' ');
  }

  for (var key in b) {
    if (key != 'class') {
      a[key] = b[key];
    }
  }

  return a;
};

/**
 * Filter null `val`s.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function nulls(val) {
  return val != null;
}

/**
 * Render the given attributes object.
 *
 * @param {Object} obj
 * @param {Object} escaped
 * @return {String}
 * @api private
 */

exports.attrs = function attrs(obj, escaped){
  var buf = []
    , terse = obj.terse;

  delete obj.terse;
  var keys = Object.keys(obj)
    , len = keys.length;

  if (len) {
    buf.push('');
    for (var i = 0; i < len; ++i) {
      var key = keys[i]
        , val = obj[key];

      if ('boolean' == typeof val || null == val) {
        if (val) {
          terse
            ? buf.push(key)
            : buf.push(key + '="' + key + '"');
        }
      } else if (0 == key.indexOf('data') && 'string' != typeof val) {
        buf.push(key + "='" + JSON.stringify(val) + "'");
      } else if ('class' == key && Array.isArray(val)) {
        buf.push(key + '="' + exports.escape(val.join(' ')) + '"');
      } else if (escaped && escaped[key]) {
        buf.push(key + '="' + exports.escape(val) + '"');
      } else {
        buf.push(key + '="' + val + '"');
      }
    }
  }

  return buf.join(' ');
};

/**
 * Escape the given string of `html`.
 *
 * @param {String} html
 * @return {String}
 * @api private
 */

exports.escape = function escape(html){
  return String(html)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
};

/**
 * Re-throw the given `err` in context to the
 * the jade in `filename` at the given `lineno`.
 *
 * @param {Error} err
 * @param {String} filename
 * @param {String} lineno
 * @api private
 */

exports.rethrow = function rethrow(err, filename, lineno){
  if (!filename) throw err;
  if (typeof window != 'undefined') throw err;

  var context = 3
    , str = __webpack_require__(2).readFileSync(filename, 'utf8')
    , lines = str.split('\n')
    , start = Math.max(lineno - context, 0)
    , end = Math.min(lines.length, lineno + context);

  // Error context
  var context = lines.slice(start, end).map(function(line, i){
    var curr = i + start + 1;
    return (curr == lineno ? '  > ' : '    ')
      + curr
      + '| '
      + line;
  }).join('\n');

  // Alter exception message
  err.path = filename;
  err.message = (filename || 'Jade') + ':' + lineno
    + '\n' + context + '\n\n' + err.message;
  throw err;
};


/***/ },
/* 12 */
/***/ function(module, exports) {


/*!
 * Jade - self closing tags
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

module.exports = [
    'meta'
  , 'img'
  , 'link'
  , 'input'
  , 'source'
  , 'area'
  , 'base'
  , 'col'
  , 'br'
  , 'hr'
];

/***/ },
/* 13 */
/***/ function(module, exports) {

exports = (module.exports = parse);
exports.parse = parse;
function parse(src, state, options) {
  options = options || {};
  state = state || exports.defaultState();
  var start = options.start || 0;
  var end = options.end || src.length;
  var index = start;
  while (index < end) {
    if (state.roundDepth < 0 || state.curlyDepth < 0 || state.squareDepth < 0) {
      throw new SyntaxError('Mismatched Bracket: ' + src[index - 1]);
    }
    exports.parseChar(src[index++], state);
  }
  return state;
}

exports.parseMax = parseMax;
function parseMax(src, options) {
  options = options || {};
  var start = options.start || 0;
  var index = start;
  var state = exports.defaultState();
  while (state.roundDepth >= 0 && state.curlyDepth >= 0 && state.squareDepth >= 0) {
    if (index >= src.length) {
      throw new Error('The end of the string was reached with no closing bracket found.');
    }
    exports.parseChar(src[index++], state);
  }
  var end = index - 1;
  return {
    start: start,
    end: end,
    src: src.substring(start, end)
  };
}

exports.parseUntil = parseUntil;
function parseUntil(src, delimiter, options) {
  options = options || {};
  var includeLineComment = options.includeLineComment || false;
  var start = options.start || 0;
  var index = start;
  var state = exports.defaultState();
  while (state.singleQuote || state.doubleQuote || state.regexp || state.blockComment ||
         (!includeLineComment && state.lineComment) || !startsWith(src, delimiter, index)) {
    exports.parseChar(src[index++], state);
  }
  var end = index;
  return {
    start: start,
    end: end,
    src: src.substring(start, end)
  };
}


exports.parseChar = parseChar;
function parseChar(character, state) {
  if (character.length !== 1) throw new Error('Character must be a string of length 1');
  state = state || defaultState();
  var wasComment = state.blockComment || state.lineComment;
  var lastChar = state.history ? state.history[0] : '';
  if (state.lineComment) {
    if (character === '\n') {
      state.lineComment = false;
    }
  } else if (state.blockComment) {
    if (state.lastChar === '*' && character === '/') {
      state.blockComment = false;
    }
  } else if (state.singleQuote) {
    if (character === '\'' && !state.escaped) {
      state.singleQuote = false;
    } else if (character === '\\' && !state.escaped) {
      state.escaped = true;
    } else {
      state.escaped = false;
    }
  } else if (state.doubleQuote) {
    if (character === '"' && !state.escaped) {
      state.doubleQuote = false;
    } else if (character === '\\' && !state.escaped) {
      state.escaped = true;
    } else {
      state.escaped = false;
    }
  } else if (state.regexp) {
    if (character === '/' && !state.escaped) {
      state.regexp = false;
    } else if (character === '\\' && !state.escaped) {
      state.escaped = true;
    } else {
      state.escaped = false;
    }
  } else if (lastChar === '/' && character === '/') {
    history = history.substr(1);
    state.lineComment = true;
  } else if (lastChar === '/' && character === '*') {
    history = history.substr(1);
    state.blockComment = true;
  } else if (character === '/') {
    //could be start of regexp or divide sign
    var history = state.history.replace(/^\s*/, '');
    if (history[0] === ')') {
      //unless its an `if`, `while`, `for` or `with` it's a divide
      //this is probably best left though
    } else if (history[0] === '}') {
      //unless it's a function expression, it's a regexp
      //this is probably best left though
    } else if (isPunctuator(history[0])) {
      state.regexp = true;
    } else if (/^\w+\b/.test(history) && isKeyword(/^\w+\b/.exec(history)[0])) {
      state.regexp = true;
    } else {
      // assume it's divide
    }
  } else if (character === '\'') {
    state.singleQuote = true;
  } else if (character === '"') {
    state.doubleQuote = true;
  } else if (character === '(') {
    state.roundDepth++;
  } else if (character === ')') {
    state.roundDepth--;
  } else if (character === '{') {
    state.curlyDepth++;
  } else if (character === '}') {
    state.curlyDepth--;
  } else if (character === '[') {
    state.squareDepth++;
  } else if (character === ']') {
    state.squareDepth--;
  }
  if (!state.blockComment && !state.lineComment && !wasComment) state.history = character + state.history;
  return state;
}

exports.defaultState = defaultState;
function defaultState() {
  return {
    lineComment: false,
    blockComment: false,

    singleQuote: false,
    doubleQuote: false,
    regexp: false,
    escaped: false,

    roundDepth: 0,
    curlyDepth: 0,
    squareDepth: 0,

    history: ''
  };
}

function startsWith(str, start, i) {
  return str.substr(i || 0, start.length) === start;
}

function isPunctuator(c) {
  var code = c.charCodeAt(0)

  switch (code) {
    case 46:   // . dot
    case 40:   // ( open bracket
    case 41:   // ) close bracket
    case 59:   // ; semicolon
    case 44:   // , comma
    case 123:  // { open curly brace
    case 125:  // } close curly brace
    case 91:   // [
    case 93:   // ]
    case 58:   // :
    case 63:   // ?
    case 126:  // ~
    case 37:   // %
    case 38:   // &
    case 42:   // *:
    case 43:   // +
    case 45:   // -
    case 47:   // /
    case 60:   // <
    case 62:   // >
    case 94:   // ^
    case 124:  // |
    case 33:   // !
    case 61:   // =
      return true;
    default:
      return false;
    }
}
function isKeyword(id) {
    return (id === 'if') || (id === 'in') || (id === 'do') || (id === 'var') || (id === 'for') || (id === 'new') ||
          (id === 'try') || (id === 'let') || (id === 'this') || (id === 'else') || (id === 'case') ||
          (id === 'void') || (id === 'with') || (id === 'enum') || (id === 'while') || (id === 'break') || (id === 'catch') ||
          (id === 'throw') || (id === 'const') || (id === 'yield') || (id === 'class') || (id === 'super') ||
          (id === 'return') || (id === 'typeof') || (id === 'delete') || (id === 'switch') || (id === 'export') ||
          (id === 'import') || (id === 'default') || (id === 'finally') || (id === 'extends') || (id === 'function') ||
          (id === 'continue') || (id === 'debugger') || (id === 'package') || (id === 'private') || (id === 'interface') ||
          (id === 'instanceof') || (id === 'implements') || (id === 'protected') || (id === 'public') || (id === 'static') ||
          (id === 'yield') || (id === 'let');
}


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

/*!
 * Jade
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Parser = __webpack_require__(30)
  , Lexer = __webpack_require__(9)
  , Compiler = __webpack_require__(17)
  , runtime = __webpack_require__(11)
// if node
  , fs = __webpack_require__(2);
// end

/**
 * Library version.
 */

exports.version = '0.30.0';

/**
 * Expose self closing tags.
 */

exports.selfClosing = __webpack_require__(12);

/**
 * Default supported doctypes.
 */

exports.doctypes = __webpack_require__(8);

/**
 * Text filters.
 */

exports.filters = __webpack_require__(5);

/**
 * Utilities.
 */

exports.utils = __webpack_require__(4);

/**
 * Expose `Compiler`.
 */

exports.Compiler = Compiler;

/**
 * Expose `Parser`.
 */

exports.Parser = Parser;

/**
 * Expose `Lexer`.
 */

exports.Lexer = Lexer;

/**
 * Nodes.
 */

exports.nodes = __webpack_require__(6);

/**
 * Jade runtime helpers.
 */

exports.runtime = runtime;

/**
 * Template function cache.
 */

exports.cache = {};

/**
 * Parse the given `str` of jade and return a function body.
 *
 * @param {String} str
 * @param {Object} options
 * @return {String}
 * @api private
 */

function parse(str, options){
  try {
    // Parse
    var parser = new Parser(str, options.filename, options);

    // Compile
    var compiler = new (options.compiler || Compiler)(parser.parse(), options)
      , js = compiler.compile();

    // Debug compiler
    if (options.debug) {
      console.error('\nCompiled Function:\n\n\033[90m%s\033[0m', js.replace(/^/gm, '  '));
    }

    return ''
      + 'var buf = [];\n'
      + (options.self
        ? 'var self = locals || {};\n' + js
        : 'with (locals || {}) {\n' + js + '\n}\n')
      + 'return buf.join("");';
  } catch (err) {
    parser = parser.context();
    runtime.rethrow(err, parser.filename, parser.lexer.lineno);
  }
}

/**
 * Strip any UTF-8 BOM off of the start of `str`, if it exists.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

function stripBOM(str){
  return 0xFEFF == str.charCodeAt(0)
    ? str.substring(1)
    : str;
}

/**
 * Compile a `Function` representation of the given jade `str`.
 *
 * Options:
 *
 *   - `compileDebug` when `false` debugging code is stripped from the compiled template
 *   - `filename` used to improve errors when `compileDebug` is not `false`
 *
 * @param {String} str
 * @param {Options} options
 * @return {Function}
 * @api public
 */

exports.compile = function(str, options){
  var options = options || {}
    , filename = options.filename
      ? JSON.stringify(options.filename)
      : 'undefined'
    , fn;

  str = stripBOM(String(str));

  if (options.compileDebug !== false) {
    fn = [
        'jade.debug = [{ lineno: 1, filename: ' + filename + ' }];'
      , 'try {'
      , parse(str, options)
      , '} catch (err) {'
      , '  jade.rethrow(err, jade.debug[0].filename, jade.debug[0].lineno);'
      , '}'
    ].join('\n');
  } else {
    fn = parse(str, options);
  }

  if (options.client) return new Function('locals', fn)
  fn = new Function('locals, jade', fn)
  return function(locals){ return fn(locals, Object.create(runtime)) }
};

/**
 * Render the given `str` of jade and invoke
 * the callback `fn(err, str)`.
 *
 * Options:
 *
 *   - `cache` enable template caching
 *   - `filename` filename required for `include` / `extends` and caching
 *
 * @param {String} str
 * @param {Object|Function} options or fn
 * @param {Function} fn
 * @api public
 */

exports.render = function(str, options, fn){
  // swap args
  if ('function' == typeof options) {
    fn = options, options = {};
  }

  // cache requires .filename
  if (options.cache && !options.filename) {
    return fn(new Error('the "filename" option is required for caching'));
  }

  try {
    var path = options.filename;
    var tmpl = options.cache
      ? exports.cache[path] || (exports.cache[path] = exports.compile(str, options))
      : exports.compile(str, options);
    fn(null, tmpl(options));
  } catch (err) {
    fn(err);
  }
};

/**
 * Render a Jade file at the given `path` and callback `fn(err, str)`.
 *
 * @param {String} path
 * @param {Object|Function} options or callback
 * @param {Function} fn
 * @api public
 */

exports.renderFile = function(path, options, fn){
  var key = path + ':string';

  if ('function' == typeof options) {
    fn = options, options = {};
  }

  try {
    options.filename = path;
    var str = options.cache
      ? exports.cache[key] || (exports.cache[key] = fs.readFileSync(path, 'utf8'))
      : fs.readFileSync(path, 'utf8');
    exports.render(str, options, fn);
  } catch (err) {
    fn(err);
  }
};

/**
 * Express support.
 */

exports.__express = exports.renderFile;


/***/ },
/* 15 */
/***/ function(module, exports) {

function webpackEmptyContext(req) {
	throw new Error("Cannot find module '" + req + "'.");
}
webpackEmptyContext.keys = function() { return []; };
webpackEmptyContext.resolve = webpackEmptyContext;
module.exports = webpackEmptyContext;
webpackEmptyContext.id = 15;


/***/ },
/* 16 */
/***/ function(module, exports) {

!function(n,e){"use strict";function t(n){for(var e=Object.create(null),t=0;t<n.length;++t)e[n[t]]=!0;return e}function r(n){return n.split("")}function i(n,e){return e.indexOf(n)>=0}function o(n,e){for(var t=0,r=e.length;t<r;++t)if(n(e[t]))return e[t]}function a(n,e){if(e<=0)return"";if(1==e)return n;var t=a(n,e>>1);return t+=t,1&e&&(t+=n),t}function u(n,e){Error.call(this,n),this.msg=n,this.defs=e}function s(n,e,t){n===!0&&(n={});var r=n||{};if(t)for(var i in r)g(r,i)&&!g(e,i)&&u.croak("`"+i+"` is not a supported option",e);for(var i in e)g(e,i)&&(r[i]=n&&g(n,i)?n[i]:e[i]);return r}function c(n,e){var t=0;for(var r in e)g(e,r)&&(n[r]=e[r],t++);return t}function f(){}function l(n,e){n.indexOf(e)<0&&n.push(e)}function p(n,e){return n.replace(/\{(.+?)\}/g,function(n,t){return e[t]})}function d(n,e){for(var t=n.length;--t>=0;)n[t]===e&&n.splice(t,1)}function h(n,e){function t(n,t){for(var r=[],i=0,o=0,a=0;i<n.length&&o<t.length;)e(n[i],t[o])<=0?r[a++]=n[i++]:r[a++]=t[o++];return i<n.length&&r.push.apply(r,n.slice(i)),o<t.length&&r.push.apply(r,t.slice(o)),r}function r(n){if(n.length<=1)return n;var e=Math.floor(n.length/2),i=n.slice(0,e),o=n.slice(e);return i=r(i),o=r(o),t(i,o)}return n.length<2?n.slice():r(n)}function v(n){function e(n){return JSON.stringify(n).replace(/[\u2028\u2029]/g,function(n){switch(n){case"\u2028":return"\\u2028";case"\u2029":return"\\u2029"}return n})}function t(n){if(1==n.length)return r+="return str === "+e(n[0])+";";r+="switch(str){";for(var t=0;t<n.length;++t)r+="case "+e(n[t])+":";r+="return true}return false;"}n instanceof Array||(n=n.split(" "));var r="",i=[];n:for(var o=0;o<n.length;++o){for(var a=0;a<i.length;++a)if(i[a][0].length==n[o].length){i[a].push(n[o]);continue n}i.push([n[o]])}if(i.length>3){i.sort(function(n,e){return e.length-n.length}),r+="switch(str.length){";for(var o=0;o<i.length;++o){var u=i[o];r+="case "+u[0].length+":",t(u)}r+="}"}else t(n);return new Function("str",r)}function m(n,e){for(var t=n.length;--t>=0;)if(!e(n[t]))return!1;return!0}function _(){this._values=Object.create(null),this._size=0}function g(n,e){return Object.prototype.hasOwnProperty.call(n,e)}function b(e,t,r,i){arguments.length<4&&(i=W),t=t?t.split(/\s+/):[];var o=t;i&&i.PROPS&&(t=t.concat(i.PROPS));for(var a="return function AST_"+e+"(props){ if (props) { ",u=t.length;--u>=0;)a+="this."+t[u]+" = props."+t[u]+";";var s=i&&new i;(s&&s.initialize||r&&r.initialize)&&(a+="this.initialize();"),a+="}}";var c=new Function(a)();if(s&&(c.prototype=s,c.BASE=i),i&&i.SUBCLASSES.push(c),c.prototype.CTOR=c,c.PROPS=t||null,c.SELF_PROPS=o,c.SUBCLASSES=[],e&&(c.prototype.TYPE=c.TYPE=e),r)for(u in r)g(r,u)&&(/^\$/.test(u)?c[u.substr(1)]=r[u]:c.prototype[u]=r[u]);return c.DEFMETHOD=function(n,e){this.prototype[n]=e},n["AST_"+e]=c,c}function y(n,e){n.body instanceof G?n.body._walk(e):n.body.forEach(function(n){n._walk(e)})}function A(n){this.visit=n,this.stack=[],this.directives=Object.create(null)}function w(n){return n>=97&&n<=122||n>=65&&n<=90||n>=170&&Ne.letter.test(String.fromCharCode(n))}function E(n){return n>=48&&n<=57}function D(n){return E(n)||w(n)}function x(n){return Ne.digit.test(String.fromCharCode(n))}function k(n){return Ne.non_spacing_mark.test(n)||Ne.space_combining_mark.test(n)}function F(n){return Ne.connector_punctuation.test(n)}function C(n){return!Ce(n)&&/^[a-z_$][a-z0-9_$]*$/i.test(n)}function B(n){return 36==n||95==n||w(n)}function S(n){var e=n.charCodeAt(0);return B(e)||E(e)||8204==e||8205==e||k(n)||F(n)||x(e)}function T(n){return/^[a-z_$][a-z0-9_$]*$/i.test(n)}function $(n){if(Te.test(n))return parseInt(n.substr(2),16);if($e.test(n))return parseInt(n.substr(1),8);var e=parseFloat(n);return e==n?e:void 0}function O(n,e,t,r,i){this.message=n,this.filename=e,this.line=t,this.col=r,this.pos=i,this.stack=(new Error).stack}function q(n,e,t,r,i){throw new O(n,e,t,r,i)}function M(n,e,t){return n.type==e&&(null==t||n.value==t)}function z(n,e,t,r){function i(){return T.text.charAt(T.pos)}function o(n,e){var t=T.text.charAt(T.pos++);if(n&&!t)throw je;return Me(t)?(T.newline_before=T.newline_before||!e,++T.line,T.col=0,e||"\r"!=t||"\n"!=i()||(++T.pos,t="\n")):++T.col,t}function a(n){for(;n-- >0;)o()}function u(n){return T.text.substr(T.pos,n.length)==n}function s(){for(var n=T.text,e=T.pos,t=T.text.length;e<t;++e){var r=n[e];if(Me(r))return e}return-1}function c(n,e){var t=T.text.indexOf(n,T.pos);if(e&&t==-1)throw je;return t}function f(){T.tokline=T.line,T.tokcol=T.col,T.tokpos=T.pos}function l(t,r,i){T.regex_allowed="operator"==t&&!Ie(r)||"keyword"==t&&Be(r)||"punc"==t&&ze(r),O="punc"==t&&"."==r;var o={type:t,value:r,line:T.tokline,col:T.tokcol,pos:T.tokpos,endline:T.line,endcol:T.col,endpos:T.pos,nlb:T.newline_before,file:e};if(/^(?:num|string|regexp)$/i.test(t)&&(o.raw=n.substring(o.pos,o.endpos)),!i){o.comments_before=T.comments_before,T.comments_before=[];for(var a=0,u=o.comments_before.length;a<u;a++)o.nlb=o.nlb||o.comments_before[a].nlb}return T.newline_before=!1,new Y(o)}function p(){for(;qe(i());)o()}function d(n){for(var e,t="",r=0;(e=i())&&n(e,r++);)t+=o();return t}function h(n){q(n,e,T.tokline,T.tokcol,T.tokpos)}function v(n){var e=!1,t=!1,r=!1,i="."==n,o=d(function(o,a){var u=o.charCodeAt(0);switch(u){case 120:case 88:return!r&&(r=!0);case 101:case 69:return!!r||!e&&(e=t=!0);case 45:return t||0==a&&!n;case 43:return t;case t=!1,46:return!(i||r||e)&&(i=!0)}return D(u)});n&&(o=n+o),$e.test(o)&&C.has_directive("use strict")&&h("SyntaxError: Legacy octal literals are not allowed in strict mode");var a=$(o);return isNaN(a)?void h("SyntaxError: Invalid syntax: "+o):l("num",a)}function m(n){var e=o(!0,n);switch(e.charCodeAt(0)){case 110:return"\n";case 114:return"\r";case 116:return"\t";case 98:return"\b";case 118:return"\v";case 102:return"\f";case 120:return String.fromCharCode(g(2));case 117:return String.fromCharCode(g(4));case 10:return"";case 13:if("\n"==i())return o(!0,n),""}return e>="0"&&e<="7"?_(e):e}function _(n){var e=i();return e>="0"&&e<="7"&&(n+=o(!0),n[0]<="3"&&(e=i())>="0"&&e<="7"&&(n+=o(!0))),"0"===n?"\0":(n.length>0&&C.has_directive("use strict")&&h("SyntaxError: Legacy octal escape sequences are not allowed in strict mode"),String.fromCharCode(parseInt(n,8)))}function g(n){for(var e=0;n>0;--n){var t=parseInt(o(!0),16);isNaN(t)&&h("SyntaxError: Invalid hex-character pattern in string"),e=e<<4|t}return e}function b(n){var e,t=T.regex_allowed,r=s();return r==-1?(e=T.text.substr(T.pos),T.pos=T.text.length):(e=T.text.substring(T.pos,r),T.pos=r),T.col=T.tokcol+(T.pos-T.tokpos),T.comments_before.push(l(n,e,!0)),T.regex_allowed=t,C}function y(){for(var n,e,t=!1,r="",a=!1;null!=(n=i());)if(t)"u"!=n&&h("SyntaxError: Expecting UnicodeEscapeSequence -- uXXXX"),n=m(),S(n)||h("SyntaxError: Unicode char: "+n.charCodeAt(0)+" is not valid in identifier"),r+=n,t=!1;else if("\\"==n)a=t=!0,o();else{if(!S(n))break;r+=o()}return ke(r)&&a&&(e=r.charCodeAt(0).toString(16).toUpperCase(),r="\\u"+"0000".substr(e.length)+e+r.slice(1)),r}function A(n){function e(n){if(!i())return n;var t=n+i();return Oe(t)?(o(),e(t)):n}return l("operator",e(n||o()))}function w(){switch(o(),i()){case"/":return o(),b("comment1");case"*":return o(),z()}return T.regex_allowed?H(""):A("/")}function x(){return o(),E(i().charCodeAt(0))?v("."):l("punc",".")}function k(){var n=y();return O?l("name",n):Fe(n)?l("atom",n):ke(n)?Oe(n)?l("operator",n):l("keyword",n):l("name",n)}function F(n,e){return function(t){try{return e(t)}catch(e){if(e!==je)throw e;h(n)}}}function C(n){if(null!=n)return H(n);for(;;){if(p(),f(),t){if(u("<!--")){a(4),b("comment3");continue}if(u("-->")&&T.newline_before){a(3),b("comment4");continue}}var e=i();if(!e)return l("eof");var s=e.charCodeAt(0);switch(s){case 34:case 39:return M(e);case 46:return x();case 47:var c=w();if(c===C)continue;return c}if(E(s))return v();if(He(e))return l("punc",o());if(Se(e))return A();if(92==s||B(s))return k();if(!r||0!=T.pos||!u("#!"))break;a(2),b("comment5")}h("SyntaxError: Unexpected character '"+e+"'")}var T={text:n,filename:e,pos:0,tokpos:0,line:1,tokline:0,col:0,tokcol:0,newline_before:!1,regex_allowed:!1,comments_before:[],directives:{},directive_stack:[]},O=!1,M=F("SyntaxError: Unterminated string constant",function(n){for(var e=o(),t="";;){var r=o(!0,!0);if("\\"==r)r=m(!0);else if(Me(r))h("SyntaxError: Unterminated string constant");else if(r==e)break;t+=r}var i=l("string",t);return i.quote=n,i}),z=F("SyntaxError: Unterminated multiline comment",function(){var n=T.regex_allowed,e=c("*/",!0),t=T.text.substring(T.pos,e).replace(/\r\n|\r|\u2028|\u2029/g,"\n");return a(t.length+2),T.comments_before.push(l("comment2",t,!0)),T.regex_allowed=n,C}),H=F("SyntaxError: Unterminated regular expression",function(n){for(var e,t=!1,r=!1;e=o(!0);)if(Me(e))h("SyntaxError: Unexpected line terminator");else if(t)n+="\\"+e,t=!1;else if("["==e)r=!0,n+=e;else if("]"==e&&r)r=!1,n+=e;else{if("/"==e&&!r)break;"\\"==e?t=!0:n+=e}var i=y();try{return l("regexp",new RegExp(n,i))}catch(n){h("SyntaxError: "+n.message)}});return C.context=function(n){return n&&(T=n),T},C.add_directive=function(n){T.directive_stack[T.directive_stack.length-1].push(n),void 0===T.directives[n]?T.directives[n]=1:T.directives[n]++},C.push_directives_stack=function(){T.directive_stack.push([])},C.pop_directives_stack=function(){for(var n=T.directive_stack[T.directive_stack.length-1],e=0;e<n.length;e++)T.directives[n[e]]--;T.directive_stack.pop()},C.has_directive=function(n){return void 0!==T.directives[n]&&T.directives[n]>0},C}function H(n,e){function t(n,e){return M(U.token,n,e)}function r(){return U.peeked||(U.peeked=U.input())}function i(){return U.prev=U.token,U.peeked?(U.token=U.peeked,U.peeked=null):U.token=U.input(),U.in_directives=U.in_directives&&("string"==U.token.type||t("punc",";")),U.token}function a(){return U.prev}function u(n,e,t,r){var i=U.input.context();q(n,i.filename,null!=e?e:i.tokline,null!=t?t:i.tokcol,null!=r?r:i.tokpos)}function c(n,e){u(e,n.line,n.col)}function f(n){null==n&&(n=U.token),c(n,"SyntaxError: Unexpected token: "+n.type+" ("+n.value+")")}function l(n,e){return t(n,e)?i():void c(U.token,"SyntaxError: Unexpected token "+U.token.type+" "+U.token.value+", expected "+n+" "+e+"")}function p(n){return l("punc",n)}function d(){return!e.strict&&(U.token.nlb||t("eof")||t("punc","}"))}function h(n){t("punc",";")?i():n||d()||f()}function v(){p("(");var n=kn(!0);return p(")"),n}function m(n){return function(){var e=U.token,t=n(),r=a();return t.start=e,t.end=r,t}}function _(){(t("operator","/")||t("operator","/="))&&(U.peeked=null,U.token=U.input(U.token.value.substr(1)))}function g(){var n=N(ce);o(function(e){return e.name==n.name},U.labels)&&u("SyntaxError: Label "+n.name+" defined twice"),p(":"),U.labels.push(n);var e=L();return U.labels.pop(),e instanceof rn||n.references.forEach(function(e){e instanceof En&&(e=e.label.start,u("SyntaxError: Continue label `"+n.name+"` refers to non-IterationStatement.",e.line,e.col,e.pos))}),new tn({body:e,label:n})}function b(n){return new Z({body:(n=kn(!0),h(),n)})}function y(n){var e,t=null;d()||(t=N(le,!0)),null!=t?(e=o(function(n){return n.name==t.name},U.labels),e||u("SyntaxError: Undefined label "+t.name),t.thedef=e):0==U.in_loop&&u("SyntaxError: "+n.TYPE+" not inside a loop or switch"),h();var r=new n({label:t});return e&&e.references.push(r),r}function A(){p("(");var n=null;return!t("punc",";")&&(n=t("keyword","var")?(i(),Y(!0)):kn(!0,!0),t("operator","in"))?(n instanceof On&&n.definitions.length>1&&u("SyntaxError: Only one variable declaration allowed in for..in loop"),i(),E(n)):w(n)}function w(n){p(";");var e=t("punc",";")?null:kn(!0);p(";");var r=t("punc",")")?null:kn(!0);return p(")"),new sn({init:n,condition:e,step:r,body:P(L)})}function E(n){var e=n instanceof On?n.definitions[0].name:null,t=kn(!0);return p(")"),new cn({init:n,name:e,object:t,body:P(L)})}function D(){var n=v(),e=L(),r=null;return t("keyword","else")&&(i(),r=L()),new Dn({condition:n,body:e,alternative:r})}function x(){p("{");for(var n=[];!t("punc","}");)t("eof")&&f(),n.push(L());return i(),n}function k(){p("{");for(var n,e=[],r=null,o=null;!t("punc","}");)t("eof")&&f(),t("keyword","case")?(o&&(o.end=a()),r=[],o=new Cn({start:(n=U.token,i(),n),expression:kn(!0),body:r}),e.push(o),p(":")):t("keyword","default")?(o&&(o.end=a()),r=[],o=new Fn({start:(n=U.token,i(),p(":"),n),body:r}),e.push(o)):(r||f(),r.push(L()));return o&&(o.end=a()),i(),e}function F(){var n=x(),e=null,r=null;if(t("keyword","catch")){var o=U.token;i(),p("(");var s=N(se);p(")"),e=new Sn({start:o,argname:s,body:x(),end:a()})}if(t("keyword","finally")){var o=U.token;i(),r=new Tn({start:o,body:x(),end:a()})}return e||r||u("SyntaxError: Missing catch/finally blocks"),new Bn({body:n,bcatch:e,bfinally:r})}function C(n,e){for(var r=[];r.push(new Mn({start:U.token,name:N(e?ie:re),value:t("operator","=")?(i(),kn(!1,n)):null,end:a()})),t("punc",",");)i();return r}function B(){var n,e=U.token;switch(e.type){case"name":case"keyword":n=H(fe);break;case"num":n=new ve({start:e,end:e,value:e.value});break;case"string":n=new he({start:e,end:e,value:e.value,quote:e.quote});break;case"regexp":n=new me({start:e,end:e,value:e.value});break;case"atom":switch(e.value){case"false":n=new De({start:e,end:e});break;case"true":n=new xe({start:e,end:e});break;case"null":n=new ge({start:e,end:e})}break;case"operator":T(e.value)||u("SyntaxError: Invalid getter/setter name: "+e.value,e.line,e.col,e.pos),n=H(fe)}return i(),n}function S(n,e,r){for(var o=!0,a=[];!t("punc",n)&&(o?o=!1:p(","),!e||!t("punc",n));)t("punc",",")&&r?a.push(new Ae({start:U.token,end:U.token})):a.push(kn(!1));return i(),a}function $(){var n=U.token;switch(i(),n.type){case"num":case"string":case"name":case"operator":case"keyword":case"atom":return n.value;default:f()}}function O(){var n=U.token;switch(i(),n.type){case"name":case"operator":case"keyword":case"atom":return n.value;default:f()}}function H(n){var e=U.token.value;return new("this"==e?pe:n)({name:String(e),start:U.token,end:U.token})}function N(n,e){if(!t("name"))return e||u("SyntaxError: Name expected"),null;var r=H(n);return i(),r}function j(n,e,t){return"++"!=e&&"--"!=e||I(t)||u("SyntaxError: Invalid use of "+e+" operator"),new n({operator:e,expression:t})}function R(n){return _n(dn(!0),0,n)}function I(n){return!e.strict||!(n instanceof pe)&&(n instanceof jn||n instanceof ne)}function P(n){++U.in_loop;var e=n();return--U.in_loop,e}e=s(e,{strict:!1,filename:null,toplevel:null,expression:!1,html5_comments:!0,bare_returns:!1,shebang:!0});var U={input:"string"==typeof n?z(n,e.filename,e.html5_comments,e.shebang):n,token:null,prev:null,peeked:null,in_function:0,in_directives:!0,in_loop:0,labels:[]};U.token=i();var L=m(function(){var n;switch(_(),U.token.type){case"string":var o=!1;U.in_directives===!0&&((M(r(),"punc",";")||r().nlb)&&U.token.raw.indexOf("\\")===-1?U.input.add_directive(U.token.value):U.in_directives=!1);var o=U.in_directives,s=b();return o?new X({start:s.body.start,end:s.body.end,quote:s.body.quote,value:s.body.value}):s;case"num":case"regexp":case"operator":case"atom":return b();case"name":return M(r(),"punc",":")?g():b();case"punc":switch(U.token.value){case"{":return new Q({start:U.token,body:x(),end:a()});case"[":case"(":return b();case";":return U.in_directives=!1,i(),new nn;default:f()}case"keyword":switch(n=U.token.value,i(),n){case"break":return y(wn);case"continue":return y(En);case"debugger":return h(),new J;case"do":return new an({body:P(L),condition:(l("keyword","while"),n=v(),h(!0),n)});case"while":return new un({condition:v(),body:P(L)});case"for":return A();case"function":return V(mn);case"if":return D();case"return":return 0!=U.in_function||e.bare_returns||u("SyntaxError: 'return' outside of function"),new bn({value:t("punc",";")?(i(),null):d()?null:(n=kn(!0),h(),n)});case"switch":return new xn({expression:v(),body:P(k)});case"throw":return U.token.nlb&&u("SyntaxError: Illegal newline after 'throw'"),new yn({value:(n=kn(!0),h(),n)});case"try":return F();case"var":return n=Y(),h(),n;case"const":return n=W(),h(),n;case"with":return U.input.has_directive("use strict")&&u("SyntaxError: Strict mode may not include a with statement"),new fn({expression:v(),body:L()});default:f()}}}),V=function(n){var e=n===mn,r=t("name")?N(e?ae:ue):null;return e&&!r&&f(),p("("),new n({name:r,argnames:function(n,e){for(;!t("punc",")");)n?n=!1:p(","),e.push(N(oe));return i(),e}(!0,[]),body:function(n,e){++U.in_function,U.in_directives=!0,U.input.push_directives_stack(),U.in_loop=0,U.labels=[];var t=x();return U.input.pop_directives_stack(),--U.in_function,U.in_loop=n,U.labels=e,t}(U.in_loop,U.labels)})},Y=function(n){return new On({start:a(),definitions:C(n,!1),end:a()})},W=function(){return new qn({start:a(),definitions:C(!1,!0),end:a()})},G=function(n){var e=U.token;l("operator","new");var r,o=K(!1);return t("punc","(")?(i(),r=S(")")):r=[],ln(new Hn({start:e,expression:o,args:r,end:a()}),n)},K=function(n){if(t("operator","new"))return G(n);var e=U.token;if(t("punc")){switch(e.value){case"(":i();var r=kn(!0);return r.start=e,r.end=U.token,p(")"),ln(r,n);case"[":return ln(en(),n);case"{":return ln(on(),n)}f()}if(t("keyword","function")){i();var o=V(vn);return o.start=e,o.end=a(),ln(o,n)}return Le[U.token.type]?ln(B(),n):void f()},en=m(function(){return p("["),new Gn({elements:S("]",!e.strict,!0)})}),on=m(function(){p("{");for(var n=!0,r=[];!t("punc","}")&&(n?n=!1:p(","),e.strict||!t("punc","}"));){var o=U.token,u=o.type,s=$();if("name"==u&&!t("punc",":")){if("get"==s){r.push(new Qn({start:o,key:B(),value:V(hn),end:a()}));continue}if("set"==s){r.push(new Kn({start:o,key:B(),value:V(hn),end:a()}));continue}}p(":"),r.push(new Zn({start:o,quote:o.quote,key:s,value:kn(!1),end:a()}))}return i(),new Jn({properties:r})}),ln=function(n,e){var r=n.start;if(t("punc","."))return i(),ln(new Rn({start:r,expression:n,property:O(),end:a()}),e);if(t("punc","[")){i();var o=kn(!0);return p("]"),ln(new In({start:r,expression:n,property:o,end:a()}),e)}return e&&t("punc","(")?(i(),ln(new zn({start:r,expression:n,args:S(")"),end:a()}),!0)):n},dn=function(n){var e=U.token;if(t("operator")&&Re(e.value)){i(),_();var r=j(Un,e.value,dn(n));return r.start=e,r.end=a(),r}for(var o=K(n);t("operator")&&Ie(U.token.value)&&!U.token.nlb;)o=j(Ln,U.token.value,o),o.start=e,o.end=U.token,i();return o},_n=function(n,e,r){var o=t("operator")?U.token.value:null;"in"==o&&r&&(o=null);var a=null!=o?Ue[o]:null;if(null!=a&&a>e){i();var u=_n(dn(!0),a,r);return _n(new Vn({start:n.start,left:n,operator:o,right:u,end:u.end}),e,r)}return n},gn=function(n){var e=U.token,r=R(n);if(t("operator","?")){i();var o=kn(!1);return p(":"),new Yn({start:e,condition:r,consequent:o,alternative:kn(!1,n),end:a()})}return r},An=function(n){var e=U.token,r=gn(n),o=U.token.value;if(t("operator")&&Pe(o)){if(I(r))return i(),new Wn({start:e,left:r,operator:o,right:An(n),end:a()});u("SyntaxError: Invalid assignment")}return r},kn=function(n,e){var o=U.token,a=An(e);return n&&t("punc",",")?(i(),new Nn({start:o,car:a,cdr:kn(!0,e),end:r()})):a};return e.expression?kn(!0):function(){var n=U.token,r=[];for(U.input.push_directives_stack();!t("eof");)r.push(L());U.input.pop_directives_stack();var i=a(),o=e.toplevel;return o?(o.body=o.body.concat(r),o.end=i):o=new pn({start:n,body:r,end:i}),o}()}function N(n,e){A.call(this),this.before=n,this.after=e}function j(n,e,t){this.name=t.name,this.orig=[t],this.scope=n,this.references=[],this.global=!1,this.mangled_name=null,this.undeclared=!1,this.constant=!1,this.index=e,this.id=j.next_id++}function R(n){function e(n,e){return n.replace(/[\u0000-\u001f\u007f-\uffff]/g,function(n){var t=n.charCodeAt(0).toString(16);if(t.length<=2&&!e){for(;t.length<2;)t="0"+t;return"\\x"+t}for(;t.length<4;)t="0"+t;return"\\u"+t})}function t(t,r){function i(){return"'"+t.replace(/\x27/g,"\\'")+"'"}function o(){return'"'+t.replace(/\x22/g,'\\"')+'"'}var a=0,u=0;switch(t=t.replace(/[\\\b\f\n\r\v\t\x22\x27\u2028\u2029\0\ufeff]/g,function(e,r){switch(e){case'"':return++a,'"';case"'":return++u,"'";case"\\":return"\\\\";case"\n":return"\\n";case"\r":return"\\r";case"\t":return"\\t";case"\b":return"\\b";case"\f":return"\\f";case"\v":return n.screw_ie8?"\\v":"\\x0B";case"\u2028":return"\\u2028";case"\u2029":return"\\u2029";case"\ufeff":return"\\ufeff";case"\0":return/[0-7]/.test(t.charAt(r+1))?"\\x00":"\\0"}return e}),n.ascii_only&&(t=e(t)),n.quote_style){case 1:return i();case 2:return o();case 3:return"'"==r?i():o();default:return a>u?i():o()}}function r(e,r){var i=t(e,r);return n.inline_script&&(i=i.replace(/<\x2fscript([>\/\t\n\f\r ])/gi,"<\\/script$1"),i=i.replace(/\x3c!--/g,"\\x3c!--"),i=i.replace(/--\x3e/g,"--\\x3e")),i}function i(t){return t=t.toString(),n.ascii_only&&(t=e(t,!0)),t}function o(e){return a(" ",n.indent_start+w-e*n.indent_level)}function u(){return B.charAt(B.length-1)}function c(){n.max_line_len&&E>n.max_line_len&&l("\n")}function l(e){e=String(e);var t=e.charAt(0);if(C&&(C=!1,t&&!(";}".indexOf(t)<0)||/[;]$/.test(B)||(n.semicolons||T(t)?(k+=";",E++,x++):(k+="\n",x++,D++,E=0,/^\s+$/.test(e)&&(C=!0)),n.beautify||(F=!1))),!n.beautify&&n.preserve_line&&N[N.length-1])for(var r=N[N.length-1].start.line;D<r;)k+="\n",x++,D++,E=0,F=!1;if(F){var i=u();(S(i)&&(S(t)||"\\"==t)||/^[\+\-\/]$/.test(t)&&t==i)&&(k+=" ",E++,x++),F=!1}var o=e.split(/\r?\n/),a=o.length-1;D+=a,0==a?E+=o[a].length:E=o[a].length,x+=e.length,B=e,k+=e}function p(){C=!1,l(";")}function d(){return w+n.indent_level}function h(n){var e;return l("{"),M(),q(d(),function(){e=n()}),O(),l("}"),e}function m(n){l("(");var e=n();return l(")"),e}function _(n){l("[");var e=n();return l("]"),e}function g(){l(","),$()}function b(){l(":"),n.space_colon&&$()}function y(){return k}if(n=s(n,{indent_start:0,indent_level:4,quote_keys:!1,space_colon:!0,ascii_only:!1,unescape_regexps:!1,inline_script:!1,width:80,max_line_len:32e3,beautify:!1,source_map:null,bracketize:!1,semicolons:!0,comments:!1,shebang:!0,preserve_line:!1,screw_ie8:!0,preamble:null,quote_style:0,keep_quoted_props:!1,wrap_iife:!1},!0),"string"==typeof n.comments&&/^\/.*\/[a-zA-Z]*$/.test(n.comments)){var A=n.comments.lastIndexOf("/");n.comments=new RegExp(n.comments.substr(1,A-1),n.comments.substr(A+1))}n.comments instanceof RegExp?n.comments=function(n){return function(e){return"comment5"==e.type||n.test(e.value)}}(n.comments):"function"==typeof n.comments?n.comments=function(n){return function(e){return"comment5"==e.type||n(this,e)}}(n.comments):"some"===n.comments?n.comments=function(n){var e=n.value,t=n.type;return"comment2"==t?/@preserve|@license|@cc_on/i.test(e):"comment5"==t}:n.comments?n.comments=function(){return!0}:n.comments=function(n){return"comment5"==n.type};var w=0,E=0,D=1,x=0,k="",F=!1,C=!1,B=null,T=v("( [ + * / - , ."),$=n.beautify?function(){l(" ")}:function(){F=!0},O=n.beautify?function(e){n.beautify&&l(o(e?.5:0))}:f,q=n.beautify?function(n,e){n===!0&&(n=d());var t=w;w=n;var r=e();return w=t,r}:function(n,e){return e()},M=n.beautify?function(){l("\n")}:c,z=n.beautify?function(){l(";")}:function(){C=!0},H=n.source_map?function(e,t){try{e&&n.source_map.add(e.file||"?",D,E,e.line,e.col,t||"name"!=e.type?t:e.value)}catch(n){W.warn("Couldn't figure out mapping for {file}:{line},{col}  {cline},{ccol} [{name}]",{file:e.file,line:e.line,col:e.col,cline:D,ccol:E,name:t||""})}}:f;n.preamble&&l(n.preamble.replace(/\r\n?|[\n\u2028\u2029]|\s*$/g,"\n"));var N=[];return{get:y,toString:y,indent:O,indentation:function(){return w},current_width:function(){return E-w},should_break:function(){return n.width&&this.current_width()>=n.width},newline:M,print:l,space:$,comma:g,colon:b,last:function(){return B},semicolon:z,force_semicolon:p,to_ascii:e,print_name:function(n){l(i(n))},print_string:function(n,e,t){var i=r(n,e);t===!0&&i.indexOf("\\")===-1&&(Ye.test(k)||p(),p()),l(i)},encode_string:r,next_indent:d,with_indent:q,with_block:h,with_parens:m,with_square:_,add_mapping:H,option:function(e){return n[e]},line:function(){return D},col:function(){return E},pos:function(){return x},push_node:function(n){N.push(n)},pop_node:function(){return N.pop()},stack:function(){return N},parent:function(n){return N[N.length-2-(n||0)]}}}function I(n,e){if(!(this instanceof I))return new I(n,e);N.call(this,this.before,this.after),this.options=s(n,{sequences:!e,properties:!e,dead_code:!e,drop_debugger:!e,unsafe:!1,unsafe_comps:!1,conditionals:!e,comparisons:!e,evaluate:!e,booleans:!e,loops:!e,unused:!e,hoist_funs:!e,keep_fargs:!0,keep_fnames:!1,hoist_vars:!1,if_return:!e,join_vars:!e,collapse_vars:!1,reduce_vars:!1,cascade:!e,side_effects:!e,pure_getters:!1,pure_funcs:null,negate_iife:!e,screw_ie8:!0,drop_console:!1,angular:!1,warnings:!0,global_defs:{},passes:1},!0);var t=this.options.sequences;this.sequences_limit=1==t?200:0|t,this.warnings_produced={}}function P(n){function e(e,i,o,a,u,s){if(r){var c=r.originalPositionFor({line:a,column:u});if(null===c.source)return;e=c.source,a=c.line,u=c.column,s=c.name||s}t.addMapping({generated:{line:i+n.dest_line_diff,column:o},original:{line:a+n.orig_line_diff,column:u},source:e,name:s})}n=s(n,{file:null,root:null,orig:null,orig_line_diff:0,dest_line_diff:0});var t=new MOZ_SourceMap.SourceMapGenerator({file:n.file,sourceRoot:n.root}),r=n.orig&&new MOZ_SourceMap.SourceMapConsumer(n.orig);return r&&Array.isArray(n.orig.sources)&&n.orig.sources.forEach(function(n){var e=r.sourceContentFor(n,!0);e&&t.setSourceContent(n,e)}),{add:e,get:function(){return t},toString:function(){return JSON.stringify(t.toJSON())}}}function U(){function n(n){l(e,n)}var e=[];return[Object,Array,Function,Number,String,Boolean,Error,Math,Date,RegExp].forEach(function(e){Object.getOwnPropertyNames(e).map(n),e.prototype&&Object.getOwnPropertyNames(e.prototype).map(n)}),e}function L(n,e){function t(n){return!(v.indexOf(n)>=0)&&(!(c.indexOf(n)>=0)&&(e.only_cache?f.props.has(n):!/^[0-9.]+$/.test(n)))}function r(n){return!(d&&n in m)&&(!(p&&!p.test(n))&&(!(c.indexOf(n)>=0)&&(f.props.has(n)||h.indexOf(n)>=0)))}function i(n,e){return e?void(m[n]=!0):(t(n)&&l(h,n),void(r(n)||l(v,n)))}function o(n){if(!r(n))return n;var e=f.props.get(n);if(!e){do e=Ve(++f.cname);while(!t(e));f.props.set(n,e)}return e}function a(n,e){var t={};try{!function n(r){r.walk(new A(function(r){if(r instanceof Nn)return n(r.cdr),!0;if(r instanceof he)return i(r.value,e),!0;if(r instanceof Yn)return n(r.consequent),n(r.alternative),!0;throw t}))}(n)}catch(n){if(n!==t)throw n}}function u(n){return n.transform(new N(function(n){return n instanceof Nn?n.cdr=u(n.cdr):n instanceof he?n.value=o(n.value):n instanceof Yn&&(n.consequent=u(n.consequent),n.alternative=u(n.alternative)),n}))}e=s(e,{reserved:null,cache:null,only_cache:!1,regex:null,ignore_quoted:!1});var c=e.reserved;null==c&&(c=U());var f=e.cache;null==f&&(f={cname:-1,props:new _});var p=e.regex,d=e.ignore_quoted,h=[],v=[],m={};return n.walk(new A(function(n){n instanceof Zn?i(n.key,d&&n.quote):n instanceof Xn?i(n.key.name):n instanceof Rn?i(n.property):n instanceof In&&a(n.property,d)})),n.transform(new N(function(n){n instanceof Zn?d&&n.quote||(n.key=o(n.key)):n instanceof Xn?n.key.name=o(n.key.name):n instanceof Rn?n.property=o(n.property):n instanceof In&&(d||(n.property=u(n.property)))}))}u.prototype=Object.create(Error.prototype),u.prototype.constructor=u,u.croak=function(n,e){throw new u(n,e)};var V=function(){function n(n,o,a){function u(){var u=o(n[s],s),l=u instanceof r;return l&&(u=u.v),u instanceof e?(u=u.v,u instanceof t?f.push.apply(f,a?u.v.slice().reverse():u.v):f.push(u)):u!==i&&(u instanceof t?c.push.apply(c,a?u.v.slice().reverse():u.v):c.push(u)),l}var s,c=[],f=[];if(n instanceof Array)if(a){for(s=n.length;--s>=0&&!u(););c.reverse(),f.reverse()}else for(s=0;s<n.length&&!u();++s);else for(s in n)if(g(n,s)&&u())break;return f.concat(c)}function e(n){this.v=n}function t(n){this.v=n}function r(n){this.v=n}n.at_top=function(n){return new e(n)},n.splice=function(n){return new t(n)},n.last=function(n){return new r(n)};var i=n.skip={};return n}();_.prototype={set:function(n,e){return this.has(n)||++this._size,this._values["$"+n]=e,this},add:function(n,e){return this.has(n)?this.get(n).push(e):this.set(n,[e]),this},get:function(n){return this._values["$"+n]},del:function(n){return this.has(n)&&(--this._size,delete this._values["$"+n]),this},has:function(n){return"$"+n in this._values},each:function(n){for(var e in this._values)n(this._values[e],e.substr(1))},size:function(){return this._size},map:function(n){var e=[];for(var t in this._values)e.push(n(this._values[t],t.substr(1)));return e},toObject:function(){return this._values}},_.fromObject=function(n){var e=new _;return e._size=c(e._values,n),e};var Y=b("Token","type value line col pos endline endcol endpos nlb comments_before file raw",{},null),W=b("Node","start end",{clone:function(){return new this.CTOR(this)},$documentation:"Base class of all AST nodes",$propdoc:{start:"[AST_Token] The first token of this node",end:"[AST_Token] The last token of this node"},_walk:function(n){return n._visit(this)},walk:function(n){return this._walk(n)}},null);W.warn_function=null,W.warn=function(n,e){W.warn_function&&W.warn_function(p(n,e))};var G=b("Statement",null,{$documentation:"Base class of all statements"}),J=b("Debugger",null,{$documentation:"Represents a debugger statement"},G),X=b("Directive","value scope quote",{$documentation:'Represents a directive, like "use strict";',$propdoc:{value:"[string] The value of this directive as a plain string (it's not an AST_String!)",scope:"[AST_Scope/S] The scope that this directive affects",quote:"[string] the original quote character"}},G),Z=b("SimpleStatement","body",{$documentation:"A statement consisting of an expression, i.e. a = 1 + 2",$propdoc:{body:"[AST_Node] an expression node (should not be instanceof AST_Statement)"},_walk:function(n){return n._visit(this,function(){this.body._walk(n)})}},G),K=b("Block","body",{$documentation:"A body of statements (usually bracketed)",$propdoc:{body:"[AST_Statement*] an array of statements"},_walk:function(n){return n._visit(this,function(){y(this,n)})}},G),Q=b("BlockStatement",null,{$documentation:"A block statement"},K),nn=b("EmptyStatement",null,{$documentation:"The empty statement (empty block or simply a semicolon)",_walk:function(n){return n._visit(this)}},G),en=b("StatementWithBody","body",{$documentation:"Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`",$propdoc:{body:"[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement"},_walk:function(n){return n._visit(this,function(){this.body._walk(n)})}},G),tn=b("LabeledStatement","label",{$documentation:"Statement with a label",$propdoc:{label:"[AST_Label] a label definition"},_walk:function(n){return n._visit(this,function(){this.label._walk(n),this.body._walk(n)})}},en),rn=b("IterationStatement",null,{$documentation:"Internal class.  All loops inherit from it."},en),on=b("DWLoop","condition",{$documentation:"Base class for do/while statements",$propdoc:{condition:"[AST_Node] the loop condition.  Should not be instanceof AST_Statement"}},rn),an=b("Do",null,{$documentation:"A `do` statement",_walk:function(n){return n._visit(this,function(){this.body._walk(n),this.condition._walk(n)})}},on),un=b("While",null,{$documentation:"A `while` statement",_walk:function(n){return n._visit(this,function(){this.condition._walk(n),this.body._walk(n)})}},on),sn=b("For","init condition step",{$documentation:"A `for` statement",$propdoc:{init:"[AST_Node?] the `for` initialization code, or null if empty",condition:"[AST_Node?] the `for` termination clause, or null if empty",step:"[AST_Node?] the `for` update clause, or null if empty"},_walk:function(n){return n._visit(this,function(){this.init&&this.init._walk(n),this.condition&&this.condition._walk(n),this.step&&this.step._walk(n),this.body._walk(n)})}},rn),cn=b("ForIn","init name object",{$documentation:"A `for ... in` statement",$propdoc:{init:"[AST_Node] the `for/in` initialization code",
name:"[AST_SymbolRef?] the loop variable, only if `init` is AST_Var",object:"[AST_Node] the object that we're looping through"},_walk:function(n){return n._visit(this,function(){this.init._walk(n),this.object._walk(n),this.body._walk(n)})}},rn),fn=b("With","expression",{$documentation:"A `with` statement",$propdoc:{expression:"[AST_Node] the `with` expression"},_walk:function(n){return n._visit(this,function(){this.expression._walk(n),this.body._walk(n)})}},en),ln=b("Scope","directives variables functions uses_with uses_eval parent_scope enclosed cname",{$documentation:"Base class for all statements introducing a lexical scope",$propdoc:{directives:"[string*/S] an array of directives declared in this scope",variables:"[Object/S] a map of name -> SymbolDef for all variables/functions defined in this scope",functions:"[Object/S] like `variables`, but only lists function declarations",uses_with:"[boolean/S] tells whether this scope uses the `with` statement",uses_eval:"[boolean/S] tells whether this scope contains a direct call to the global `eval`",parent_scope:"[AST_Scope?/S] link to the parent scope",enclosed:"[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any subscopes",cname:"[integer/S] current index for mangling variables (used internally by the mangler)"}},K),pn=b("Toplevel","globals",{$documentation:"The toplevel scope",$propdoc:{globals:"[Object/S] a map of name -> SymbolDef for all undeclared names"},wrap_enclose:function(n){var e=this,t=[],r=[];n.forEach(function(n){var e=n.lastIndexOf(":");t.push(n.substr(0,e)),r.push(n.substr(e+1))});var i="(function("+r.join(",")+"){ '$ORIG'; })("+t.join(",")+")";return i=H(i),i=i.transform(new N(function(n){if(n instanceof X&&"$ORIG"==n.value)return V.splice(e.body)}))},wrap_commonjs:function(n,e){var t=this,r=[];e&&(t.figure_out_scope(),t.walk(new A(function(n){n instanceof te&&n.definition().global&&(o(function(e){return e.name==n.name},r)||r.push(n))})));var i="(function(exports, global){ '$ORIG'; '$EXPORTS'; global['"+n+"'] = exports; }({}, (function(){return this}())))";return i=H(i),i=i.transform(new N(function(n){if(n instanceof X)switch(n.value){case"$ORIG":return V.splice(t.body);case"$EXPORTS":var e=[];return r.forEach(function(n){e.push(new Z({body:new Wn({left:new In({expression:new fe({name:"exports"}),property:new he({value:n.name})}),operator:"=",right:new fe(n)})}))}),V.splice(e)}}))}},ln),dn=b("Lambda","name argnames uses_arguments",{$documentation:"Base class for functions",$propdoc:{name:"[AST_SymbolDeclaration?] the name of this function",argnames:"[AST_SymbolFunarg*] array of function arguments",uses_arguments:"[boolean/S] tells whether this function accesses the arguments array"},_walk:function(n){return n._visit(this,function(){this.name&&this.name._walk(n),this.argnames.forEach(function(e){e._walk(n)}),y(this,n)})}},ln),hn=b("Accessor",null,{$documentation:"A setter/getter function.  The `name` property is always null."},dn),vn=b("Function",null,{$documentation:"A function expression"},dn),mn=b("Defun",null,{$documentation:"A function definition"},dn),_n=b("Jump",null,{$documentation:"Base class for jumps (for now that's `return`, `throw`, `break` and `continue`)"},G),gn=b("Exit","value",{$documentation:"Base class for exits (`return` and `throw`)",$propdoc:{value:"[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return"},_walk:function(n){return n._visit(this,this.value&&function(){this.value._walk(n)})}},_n),bn=b("Return",null,{$documentation:"A `return` statement"},gn),yn=b("Throw",null,{$documentation:"A `throw` statement"},gn),An=b("LoopControl","label",{$documentation:"Base class for loop control statements (`break` and `continue`)",$propdoc:{label:"[AST_LabelRef?] the label, or null if none"},_walk:function(n){return n._visit(this,this.label&&function(){this.label._walk(n)})}},_n),wn=b("Break",null,{$documentation:"A `break` statement"},An),En=b("Continue",null,{$documentation:"A `continue` statement"},An),Dn=b("If","condition alternative",{$documentation:"A `if` statement",$propdoc:{condition:"[AST_Node] the `if` condition",alternative:"[AST_Statement?] the `else` part, or null if not present"},_walk:function(n){return n._visit(this,function(){this.condition._walk(n),this.body._walk(n),this.alternative&&this.alternative._walk(n)})}},en),xn=b("Switch","expression",{$documentation:"A `switch` statement",$propdoc:{expression:"[AST_Node] the `switch` discriminant"},_walk:function(n){return n._visit(this,function(){this.expression._walk(n),y(this,n)})}},K),kn=b("SwitchBranch",null,{$documentation:"Base class for `switch` branches"},K),Fn=b("Default",null,{$documentation:"A `default` switch branch"},kn),Cn=b("Case","expression",{$documentation:"A `case` switch branch",$propdoc:{expression:"[AST_Node] the `case` expression"},_walk:function(n){return n._visit(this,function(){this.expression._walk(n),y(this,n)})}},kn),Bn=b("Try","bcatch bfinally",{$documentation:"A `try` statement",$propdoc:{bcatch:"[AST_Catch?] the catch block, or null if not present",bfinally:"[AST_Finally?] the finally block, or null if not present"},_walk:function(n){return n._visit(this,function(){y(this,n),this.bcatch&&this.bcatch._walk(n),this.bfinally&&this.bfinally._walk(n)})}},K),Sn=b("Catch","argname",{$documentation:"A `catch` node; only makes sense as part of a `try` statement",$propdoc:{argname:"[AST_SymbolCatch] symbol for the exception"},_walk:function(n){return n._visit(this,function(){this.argname._walk(n),y(this,n)})}},K),Tn=b("Finally",null,{$documentation:"A `finally` node; only makes sense as part of a `try` statement"},K),$n=b("Definitions","definitions",{$documentation:"Base class for `var` or `const` nodes (variable declarations/initializations)",$propdoc:{definitions:"[AST_VarDef*] array of variable definitions"},_walk:function(n){return n._visit(this,function(){this.definitions.forEach(function(e){e._walk(n)})})}},G),On=b("Var",null,{$documentation:"A `var` statement"},$n),qn=b("Const",null,{$documentation:"A `const` statement"},$n),Mn=b("VarDef","name value",{$documentation:"A variable declaration; only appears in a AST_Definitions node",$propdoc:{name:"[AST_SymbolVar|AST_SymbolConst] name of the variable",value:"[AST_Node?] initializer, or null of there's no initializer"},_walk:function(n){return n._visit(this,function(){this.name._walk(n),this.value&&this.value._walk(n)})}}),zn=b("Call","expression args",{$documentation:"A function call expression",$propdoc:{expression:"[AST_Node] expression to invoke as function",args:"[AST_Node*] array of arguments"},_walk:function(n){return n._visit(this,function(){this.expression._walk(n),this.args.forEach(function(e){e._walk(n)})})}}),Hn=b("New",null,{$documentation:"An object instantiation.  Derives from a function call since it has exactly the same properties"},zn),Nn=b("Seq","car cdr",{$documentation:"A sequence expression (two comma-separated expressions)",$propdoc:{car:"[AST_Node] first element in sequence",cdr:"[AST_Node] second element in sequence"},$cons:function(n,e){var t=new Nn(n);return t.car=n,t.cdr=e,t},$from_array:function(n){if(0==n.length)return null;if(1==n.length)return n[0].clone();for(var e=null,t=n.length;--t>=0;)e=Nn.cons(n[t],e);for(var r=e;r;){if(r.cdr&&!r.cdr.cdr){r.cdr=r.cdr.car;break}r=r.cdr}return e},to_array:function(){for(var n=this,e=[];n;){if(e.push(n.car),n.cdr&&!(n.cdr instanceof Nn)){e.push(n.cdr);break}n=n.cdr}return e},add:function(n){for(var e=this;e;){if(!(e.cdr instanceof Nn)){var t=Nn.cons(e.cdr,n);return e.cdr=t}e=e.cdr}},len:function(){return this.cdr instanceof Nn?this.cdr.len()+1:2},_walk:function(n){return n._visit(this,function(){this.car._walk(n),this.cdr&&this.cdr._walk(n)})}}),jn=b("PropAccess","expression property",{$documentation:'Base class for property access expressions, i.e. `a.foo` or `a["foo"]`',$propdoc:{expression:"[AST_Node] the container expression",property:"[AST_Node|string] the property to access.  For AST_Dot this is always a plain string, while for AST_Sub it's an arbitrary AST_Node"}}),Rn=b("Dot",null,{$documentation:"A dotted property access expression",_walk:function(n){return n._visit(this,function(){this.expression._walk(n)})}},jn),In=b("Sub",null,{$documentation:'Index-style property access, i.e. `a["foo"]`',_walk:function(n){return n._visit(this,function(){this.expression._walk(n),this.property._walk(n)})}},jn),Pn=b("Unary","operator expression",{$documentation:"Base class for unary expressions",$propdoc:{operator:"[string] the operator",expression:"[AST_Node] expression that this unary operator applies to"},_walk:function(n){return n._visit(this,function(){this.expression._walk(n)})}}),Un=b("UnaryPrefix",null,{$documentation:"Unary prefix expression, i.e. `typeof i` or `++i`"},Pn),Ln=b("UnaryPostfix",null,{$documentation:"Unary postfix expression, i.e. `i++`"},Pn),Vn=b("Binary","left operator right",{$documentation:"Binary expression, i.e. `a + b`",$propdoc:{left:"[AST_Node] left-hand side expression",operator:"[string] the operator",right:"[AST_Node] right-hand side expression"},_walk:function(n){return n._visit(this,function(){this.left._walk(n),this.right._walk(n)})}}),Yn=b("Conditional","condition consequent alternative",{$documentation:"Conditional expression using the ternary operator, i.e. `a ? b : c`",$propdoc:{condition:"[AST_Node]",consequent:"[AST_Node]",alternative:"[AST_Node]"},_walk:function(n){return n._visit(this,function(){this.condition._walk(n),this.consequent._walk(n),this.alternative._walk(n)})}}),Wn=b("Assign",null,{$documentation:"An assignment expression  `a = b + 5`"},Vn),Gn=b("Array","elements",{$documentation:"An array literal",$propdoc:{elements:"[AST_Node*] array of elements"},_walk:function(n){return n._visit(this,function(){this.elements.forEach(function(e){e._walk(n)})})}}),Jn=b("Object","properties",{$documentation:"An object literal",$propdoc:{properties:"[AST_ObjectProperty*] array of properties"},_walk:function(n){return n._visit(this,function(){this.properties.forEach(function(e){e._walk(n)})})}}),Xn=b("ObjectProperty","key value",{$documentation:"Base class for literal object properties",$propdoc:{key:"[string] the property name converted to a string for ObjectKeyVal.  For setters and getters this is an arbitrary AST_Node.",value:"[AST_Node] property value.  For setters and getters this is an AST_Function."},_walk:function(n){return n._visit(this,function(){this.value._walk(n)})}}),Zn=b("ObjectKeyVal","quote",{$documentation:"A key: value object property",$propdoc:{quote:"[string] the original quote character"}},Xn),Kn=b("ObjectSetter",null,{$documentation:"An object setter property"},Xn),Qn=b("ObjectGetter",null,{$documentation:"An object getter property"},Xn),ne=b("Symbol","scope name thedef",{$propdoc:{name:"[string] name of this symbol",scope:"[AST_Scope/S] the current scope (not necessarily the definition scope)",thedef:"[SymbolDef/S] the definition of this symbol"},$documentation:"Base class for all symbols"}),ee=b("SymbolAccessor",null,{$documentation:"The name of a property accessor (setter/getter function)"},ne),te=b("SymbolDeclaration","init",{$documentation:"A declaration symbol (symbol in var/const, function name or argument, symbol in catch)",$propdoc:{init:"[AST_Node*/S] array of initializers for this declaration."}},ne),re=b("SymbolVar",null,{$documentation:"Symbol defining a variable"},te),ie=b("SymbolConst",null,{$documentation:"A constant declaration"},te),oe=b("SymbolFunarg",null,{$documentation:"Symbol naming a function argument"},re),ae=b("SymbolDefun",null,{$documentation:"Symbol defining a function"},te),ue=b("SymbolLambda",null,{$documentation:"Symbol naming a function expression"},te),se=b("SymbolCatch",null,{$documentation:"Symbol naming the exception in catch"},te),ce=b("Label","references",{$documentation:"Symbol naming a label (declaration)",$propdoc:{references:"[AST_LoopControl*] a list of nodes referring to this label"},initialize:function(){this.references=[],this.thedef=this}},ne),fe=b("SymbolRef",null,{$documentation:"Reference to some symbol (not definition/declaration)"},ne),le=b("LabelRef",null,{$documentation:"Reference to a label symbol"},ne),pe=b("This",null,{$documentation:"The `this` symbol"},ne),de=b("Constant",null,{$documentation:"Base class for all constants",getValue:function(){return this.value}}),he=b("String","value quote",{$documentation:"A string literal",$propdoc:{value:"[string] the contents of this string",quote:"[string] the original quote character"}},de),ve=b("Number","value literal",{$documentation:"A number literal",$propdoc:{value:"[number] the numeric value",literal:"[string] numeric value as string (optional)"}},de),me=b("RegExp","value",{$documentation:"A regexp literal",$propdoc:{value:"[RegExp] the actual regexp"}},de),_e=b("Atom",null,{$documentation:"Base class for atoms"},de),ge=b("Null",null,{$documentation:"The `null` atom",value:null},_e),be=b("NaN",null,{$documentation:"The impossible value",value:NaN},_e),ye=b("Undefined",null,{$documentation:"The `undefined` value",value:void 0},_e),Ae=b("Hole",null,{$documentation:"A hole in an array",value:void 0},_e),we=b("Infinity",null,{$documentation:"The `Infinity` value",value:1/0},_e),Ee=b("Boolean",null,{$documentation:"Base class for booleans"},_e),De=b("False",null,{$documentation:"The `false` atom",value:!1},Ee),xe=b("True",null,{$documentation:"The `true` atom",value:!0},Ee);A.prototype={_visit:function(n,e){this.push(n);var t=this.visit(n,e?function(){e.call(n)}:f);return!t&&e&&e.call(n),this.pop(n),t},parent:function(n){return this.stack[this.stack.length-2-(n||0)]},push:function(n){n instanceof dn?this.directives=Object.create(this.directives):n instanceof X&&(this.directives[n.value]=!this.directives[n.value]||"up"),this.stack.push(n)},pop:function(n){this.stack.pop(),n instanceof dn&&(this.directives=Object.getPrototypeOf(this.directives))},self:function(){return this.stack[this.stack.length-1]},find_parent:function(n){for(var e=this.stack,t=e.length;--t>=0;){var r=e[t];if(r instanceof n)return r}},has_directive:function(n){var e=this.directives[n];if(e)return e;var t=this.stack[this.stack.length-1];if(t instanceof ln)for(var r=0;r<t.body.length;++r){var i=t.body[r];if(!(i instanceof X))break;if(i.value==n)return!0}},in_boolean_context:function(){for(var n=this.stack,e=n.length,t=n[--e];e>0;){var r=n[--e];if(r instanceof Dn&&r.condition===t||r instanceof Yn&&r.condition===t||r instanceof on&&r.condition===t||r instanceof sn&&r.condition===t||r instanceof Un&&"!"==r.operator&&r.expression===t)return!0;if(!(r instanceof Vn)||"&&"!=r.operator&&"||"!=r.operator)return!1;t=r}},loopcontrol_target:function(n){var e=this.stack;if(n)for(var t=e.length;--t>=0;){var r=e[t];if(r instanceof tn&&r.label.name==n.name)return r.body}else for(var t=e.length;--t>=0;){var r=e[t];if(r instanceof xn||r instanceof rn)return r}}};var ke="break case catch const continue debugger default delete do else finally for function if in instanceof new return switch throw try typeof var void while with",Fe="false null true",Ce="abstract boolean byte char class double enum export extends final float goto implements import int interface let long native package private protected public short static super synchronized this throws transient volatile yield "+Fe+" "+ke,Be="return new delete throw else case";ke=v(ke),Ce=v(Ce),Be=v(Be),Fe=v(Fe);var Se=v(r("+-*&%=<>!?|~^")),Te=/^0x[0-9a-f]+$/i,$e=/^0[0-7]+$/,Oe=v(["in","instanceof","typeof","new","void","delete","++","--","+","-","!","~","&","|","^","*","/","%",">>","<<",">>>","<",">","<=",">=","==","===","!=","!==","?","=","+=","-=","/=","*=","%=",">>=","<<=",">>>=","|=","^=","&=","&&","||"]),qe=v(r(" \n\r\t\f\v\u2028\u2029\ufeff")),Me=v(r("\n\r\u2028\u2029")),ze=v(r("[{(,.;:")),He=v(r("[]{}(),;:")),Ne=(v(r("gmsiy")),{letter:new RegExp("[\\u0041-\\u005A\\u0061-\\u007A\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]"),digit:new RegExp("[\\u0030-\\u0039\\u0660-\\u0669\\u06F0-\\u06F9\\u07C0-\\u07C9\\u0966-\\u096F\\u09E6-\\u09EF\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0BE6-\\u0BEF\\u0C66-\\u0C6F\\u0CE6-\\u0CEF\\u0D66-\\u0D6F\\u0DE6-\\u0DEF\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u0F20-\\u0F29\\u1040-\\u1049\\u1090-\\u1099\\u17E0-\\u17E9\\u1810-\\u1819\\u1946-\\u194F\\u19D0-\\u19D9\\u1A80-\\u1A89\\u1A90-\\u1A99\\u1B50-\\u1B59\\u1BB0-\\u1BB9\\u1C40-\\u1C49\\u1C50-\\u1C59\\uA620-\\uA629\\uA8D0-\\uA8D9\\uA900-\\uA909\\uA9D0-\\uA9D9\\uA9F0-\\uA9F9\\uAA50-\\uAA59\\uABF0-\\uABF9\\uFF10-\\uFF19]"),non_spacing_mark:new RegExp("[\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065E\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0900-\\u0902\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09BC\\u09C1-\\u09C4\\u09CD\\u09E2\\u09E3\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0B01\\u0B3C\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B56\\u0B62\\u0B63\\u0B82\\u0BC0\\u0BCD\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0CBC\\u0CBF\\u0CC6\\u0CCC\\u0CCD\\u0CE2\\u0CE3\\u0D41-\\u0D44\\u0D4D\\u0D62\\u0D63\\u0DCA\\u0DD2-\\u0DD4\\u0DD6\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F90-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1B00-\\u1B03\\u1B34\\u1B36-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1DC0-\\u1DE6\\u1DFD-\\u1DFF\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F\\uA67C\\uA67D\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE26]"),space_combining_mark:new RegExp("[\\u0903\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u0982\\u0983\\u09BE-\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u09D7\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B3E\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0B57\\u0BBE\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0BD7\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0-\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0CD5\\u0CD6\\u0D02\\u0D03\\u0D3E-\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D57\\u0D82\\u0D83\\u0DCF-\\u0DD1\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0F3E\\u0F3F\\u0F7F\\u102B\\u102C\\u1031\\u1038\\u103B\\u103C\\u1056\\u1057\\u1062-\\u1064\\u1067-\\u106D\\u1083\\u1084\\u1087-\\u108C\\u108F\\u109A-\\u109C\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u19B0-\\u19C0\\u19C8\\u19C9\\u1A19-\\u1A1B\\u1A55\\u1A57\\u1A61\\u1A63\\u1A64\\u1A6D-\\u1A72\\u1B04\\u1B35\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF2\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BD-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAA7B\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]"),connector_punctuation:new RegExp("[\\u005F\\u203F\\u2040\\u2054\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF3F]")});O.prototype.toString=function(){return this.message+" (line: "+this.line+", col: "+this.col+", pos: "+this.pos+")\n\n"+this.stack};var je={},Re=v(["typeof","void","delete","--","++","!","~","-","+"]),Ie=v(["--","++"]),Pe=v(["=","+=","-=","/=","*=","%=",">>=","<<=",">>>=","|=","^=","&="]),Ue=function(n,e){for(var t=0;t<n.length;++t)for(var r=n[t],i=0;i<r.length;++i)e[r[i]]=t+1;return e}([["||"],["&&"],["|"],["^"],["&"],["==","===","!=","!=="],["<",">","<=",">=","in","instanceof"],[">>","<<",">>>"],["+","-"],["*","/","%"]],{}),Le=(t(["for","do","while","switch"]),t(["atom","num","string","regexp","name"]));N.prototype=new A,function(n){function e(e,t){e.DEFMETHOD("transform",function(e,r){var i,o;return e.push(this),e.before&&(i=e.before(this,t,r)),i===n&&(e.after?(e.stack[e.stack.length-1]=i=this,t(i,e),o=e.after(i,r),o!==n&&(i=o)):(i=this,t(i,e))),e.pop(this),i})}function t(n,e){return V(n,function(n){return n.transform(e,!0)})}e(W,f),e(tn,function(n,e){n.label=n.label.transform(e),n.body=n.body.transform(e)}),e(Z,function(n,e){n.body=n.body.transform(e)}),e(K,function(n,e){n.body=t(n.body,e)}),e(on,function(n,e){n.condition=n.condition.transform(e),n.body=n.body.transform(e)}),e(sn,function(n,e){n.init&&(n.init=n.init.transform(e)),n.condition&&(n.condition=n.condition.transform(e)),n.step&&(n.step=n.step.transform(e)),n.body=n.body.transform(e)}),e(cn,function(n,e){n.init=n.init.transform(e),n.object=n.object.transform(e),n.body=n.body.transform(e)}),e(fn,function(n,e){n.expression=n.expression.transform(e),n.body=n.body.transform(e)}),e(gn,function(n,e){n.value&&(n.value=n.value.transform(e))}),e(An,function(n,e){n.label&&(n.label=n.label.transform(e))}),e(Dn,function(n,e){n.condition=n.condition.transform(e),n.body=n.body.transform(e),n.alternative&&(n.alternative=n.alternative.transform(e))}),e(xn,function(n,e){n.expression=n.expression.transform(e),n.body=t(n.body,e)}),e(Cn,function(n,e){n.expression=n.expression.transform(e),n.body=t(n.body,e)}),e(Bn,function(n,e){n.body=t(n.body,e),n.bcatch&&(n.bcatch=n.bcatch.transform(e)),n.bfinally&&(n.bfinally=n.bfinally.transform(e))}),e(Sn,function(n,e){n.argname=n.argname.transform(e),n.body=t(n.body,e)}),e($n,function(n,e){n.definitions=t(n.definitions,e)}),e(Mn,function(n,e){n.name=n.name.transform(e),n.value&&(n.value=n.value.transform(e))}),e(dn,function(n,e){n.name&&(n.name=n.name.transform(e)),n.argnames=t(n.argnames,e),n.body=t(n.body,e)}),e(zn,function(n,e){n.expression=n.expression.transform(e),n.args=t(n.args,e)}),e(Nn,function(n,e){n.car=n.car.transform(e),n.cdr=n.cdr.transform(e)}),e(Rn,function(n,e){n.expression=n.expression.transform(e)}),e(In,function(n,e){n.expression=n.expression.transform(e),n.property=n.property.transform(e)}),e(Pn,function(n,e){n.expression=n.expression.transform(e)}),e(Vn,function(n,e){n.left=n.left.transform(e),n.right=n.right.transform(e)}),e(Yn,function(n,e){n.condition=n.condition.transform(e),n.consequent=n.consequent.transform(e),n.alternative=n.alternative.transform(e)}),e(Gn,function(n,e){n.elements=t(n.elements,e)}),e(Jn,function(n,e){n.properties=t(n.properties,e)}),e(Xn,function(n,e){n.value=n.value.transform(e)})}(),j.next_id=1,j.prototype={unmangleable:function(n){return n||(n={}),this.global&&!n.toplevel||this.undeclared||!n.eval&&(this.scope.uses_eval||this.scope.uses_with)||n.keep_fnames&&(this.orig[0]instanceof ue||this.orig[0]instanceof ae)},mangle:function(n){var e=n.cache&&n.cache.props;if(this.global&&e&&e.has(this.name))this.mangled_name=e.get(this.name);else if(!this.mangled_name&&!this.unmangleable(n)){var t=this.scope;!n.screw_ie8&&this.orig[0]instanceof ue&&(t=t.parent_scope),this.mangled_name=t.next_mangled(n,this),this.global&&e&&e.set(this.name,this.mangled_name)}}},pn.DEFMETHOD("figure_out_scope",function(n){n=s(n,{screw_ie8:!0,cache:null});var e=this,t=e.parent_scope=null,r=new _,i=null,o=!1,a=0,u=new A(function(e,s){if(n.screw_ie8&&e instanceof Sn){var c=t;return t=new ln(e),t.init_scope_vars(a),t.parent_scope=c,s(),t=c,!0}if(e instanceof ln){e.init_scope_vars(a);var c=e.parent_scope=t,f=i,l=r;return i=t=e,r=new _,++a,s(),--a,t=c,i=f,r=l,!0}if(e instanceof tn){var d=e.label;if(r.has(d.name))throw new Error(p("Label {name} defined twice",d));return r.set(d.name,d),s(),r.del(d.name),!0}if(e instanceof fn)for(var h=t;h;h=h.parent_scope)h.uses_with=!0;else if(e instanceof ne&&(e.scope=t),e instanceof ce&&(e.thedef=e,e.references=[]),e instanceof ue)i.def_function(e);else if(e instanceof ae)(e.scope=i.parent_scope).def_function(e);else if(e instanceof On)o=e.has_const_pragma();else if(e instanceof re||e instanceof ie){var v=i.def_variable(e);v.constant=e instanceof ie||o,v.init=u.parent().value}else if(e instanceof se)(n.screw_ie8?t:i).def_variable(e);else if(e instanceof le){var m=r.get(e.name);if(!m)throw new Error(p("Undefined label {name} [{line},{col}]",{name:e.name,line:e.start.line,col:e.start.col}));e.thedef=m}});e.walk(u);var c=null,f=e.globals=new _,u=new A(function(n,t){if(n instanceof dn){var r=c;return c=n,t(),c=r,!0}if(n instanceof An&&n.label)return n.label.thedef.references.push(n),!0;if(n instanceof fe){var i=n.name,o=u.parent();if("eval"==i&&o instanceof zn)for(var a=n.scope;a&&!a.uses_eval;a=a.parent_scope)a.uses_eval=!0;var s=n.scope.find_variable(i);if(n.scope instanceof dn&&"arguments"==i&&(n.scope.uses_arguments=!0),!s){var l;f.has(i)?l=f.get(i):(l=new j(e,f.size(),n),l.undeclared=!0,l.global=!0,f.set(i,l)),s=l}return n.thedef=s,(o instanceof Pn&&("++"===o.operator||"--"===o.operator)||o instanceof Wn&&o.left===n)&&(s.modified=!0),n.reference(),!0}});e.walk(u),n.cache&&(this.cname=n.cache.cname)}),ln.DEFMETHOD("init_scope_vars",function(n){this.variables=new _,this.functions=new _,this.uses_with=!1,this.uses_eval=!1,this.parent_scope=null,this.enclosed=[],this.cname=-1,this.nesting=n}),dn.DEFMETHOD("init_scope_vars",function(){ln.prototype.init_scope_vars.apply(this,arguments),this.uses_arguments=!1;var n=new Mn({name:"arguments",start:this.start,end:this.end}),e=new j(this,this.variables.size(),n);this.variables.set(n.name,e)}),fe.DEFMETHOD("reference",function(){var n=this.definition();n.references.push(this);for(var e=this.scope;e&&(l(e.enclosed,n),e!==n.scope);)e=e.parent_scope;this.frame=this.scope.nesting-n.scope.nesting}),ln.DEFMETHOD("find_variable",function(n){return n instanceof ne&&(n=n.name),this.variables.get(n)||this.parent_scope&&this.parent_scope.find_variable(n)}),ln.DEFMETHOD("def_function",function(n){this.functions.set(n.name,this.def_variable(n))}),ln.DEFMETHOD("def_variable",function(n){var e;return this.variables.has(n.name)?(e=this.variables.get(n.name),e.orig.push(n)):(e=new j(this,this.variables.size(),n),this.variables.set(n.name,e),e.global=!this.parent_scope),n.thedef=e}),ln.DEFMETHOD("next_mangled",function(n){var e=this.enclosed;n:for(;;){var t=Ve(++this.cname);if(C(t)&&!(n.except.indexOf(t)>=0)){for(var r=e.length;--r>=0;){var i=e[r],o=i.mangled_name||i.unmangleable(n)&&i.name;if(t==o)continue n}return t}}}),vn.DEFMETHOD("next_mangled",function(n,e){for(var t=e.orig[0]instanceof oe&&this.name&&this.name.definition(),r=t?t.mangled_name||t.name:null;;){
var i=dn.prototype.next_mangled.call(this,n,e);if(!r||r!=i)return i}}),ln.DEFMETHOD("references",function(n){return n instanceof ne&&(n=n.definition()),this.enclosed.indexOf(n)<0?null:n}),ne.DEFMETHOD("unmangleable",function(n){return this.definition().unmangleable(n)}),ee.DEFMETHOD("unmangleable",function(){return!0}),ce.DEFMETHOD("unmangleable",function(){return!1}),ne.DEFMETHOD("unreferenced",function(){return 0==this.definition().references.length&&!(this.scope.uses_eval||this.scope.uses_with)}),ne.DEFMETHOD("undeclared",function(){return this.definition().undeclared}),le.DEFMETHOD("undeclared",function(){return!1}),ce.DEFMETHOD("undeclared",function(){return!1}),ne.DEFMETHOD("definition",function(){return this.thedef}),ne.DEFMETHOD("global",function(){return this.definition().global}),On.DEFMETHOD("has_const_pragma",function(){var n=this.start&&this.start.comments_before,e=n&&n[n.length-1];return e&&/@const\b/.test(e.value)}),pn.DEFMETHOD("_default_mangler_options",function(n){return s(n,{except:[],eval:!1,sort:!1,toplevel:!1,screw_ie8:!0,keep_fnames:!1})}),pn.DEFMETHOD("mangle_names",function(n){n=this._default_mangler_options(n),n.except.push("arguments");var e=-1,t=[];n.cache&&this.globals.each(function(e){n.except.indexOf(e.name)<0&&t.push(e)});var r=new A(function(i,o){if(i instanceof tn){var a=e;return o(),e=a,!0}if(i instanceof ln){var u=(r.parent(),[]);return i.variables.each(function(e){n.except.indexOf(e.name)<0&&u.push(e)}),void t.push.apply(t,u)}if(i instanceof ce){var s;do s=Ve(++e);while(!C(s));return i.mangled_name=s,!0}if(n.screw_ie8&&i instanceof se)return void t.push(i.definition())});this.walk(r),t.forEach(function(e){e.mangle(n)}),n.cache&&(n.cache.cname=this.cname)}),pn.DEFMETHOD("compute_char_frequency",function(n){n=this._default_mangler_options(n);var e=new A(function(e){e instanceof de?Ve.consider(e.print_to_string()):e instanceof bn?Ve.consider("return"):e instanceof yn?Ve.consider("throw"):e instanceof En?Ve.consider("continue"):e instanceof wn?Ve.consider("break"):e instanceof J?Ve.consider("debugger"):e instanceof X?Ve.consider(e.value):e instanceof un?Ve.consider("while"):e instanceof an?Ve.consider("do while"):e instanceof Dn?(Ve.consider("if"),e.alternative&&Ve.consider("else")):e instanceof On?Ve.consider("var"):e instanceof qn?Ve.consider("const"):e instanceof dn?Ve.consider("function"):e instanceof sn?Ve.consider("for"):e instanceof cn?Ve.consider("for in"):e instanceof xn?Ve.consider("switch"):e instanceof Cn?Ve.consider("case"):e instanceof Fn?Ve.consider("default"):e instanceof fn?Ve.consider("with"):e instanceof Kn?Ve.consider("set"+e.key):e instanceof Qn?Ve.consider("get"+e.key):e instanceof Zn?Ve.consider(e.key):e instanceof Hn?Ve.consider("new"):e instanceof pe?Ve.consider("this"):e instanceof Bn?Ve.consider("try"):e instanceof Sn?Ve.consider("catch"):e instanceof Tn?Ve.consider("finally"):e instanceof ne&&e.unmangleable(n)?Ve.consider(e.name):e instanceof Pn||e instanceof Vn?Ve.consider(e.operator):e instanceof Rn&&Ve.consider(e.property)});this.walk(e),Ve.sort()});var Ve=function(){function n(){r=Object.create(null),t=i.split("").map(function(n){return n.charCodeAt(0)}),t.forEach(function(n){r[n]=0})}function e(n){var e="",r=54;n++;do n--,e+=String.fromCharCode(t[n%r]),n=Math.floor(n/r),r=64;while(n>0);return e}var t,r,i="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_0123456789";return e.consider=function(n){for(var e=n.length;--e>=0;){var t=n.charCodeAt(e);t in r&&++r[t]}},e.sort=function(){t=h(t,function(n,e){return E(n)&&!E(e)?1:E(e)&&!E(n)?-1:r[e]-r[n]})},e.reset=n,n(),e.get=function(){return t},e.freq=function(){return r},e}();pn.DEFMETHOD("scope_warnings",function(n){n=s(n,{undeclared:!1,unreferenced:!0,assign_to_global:!0,func_arguments:!0,nested_defuns:!0,eval:!0});var e=new A(function(t){if(n.undeclared&&t instanceof fe&&t.undeclared()&&W.warn("Undeclared symbol: {name} [{file}:{line},{col}]",{name:t.name,file:t.start.file,line:t.start.line,col:t.start.col}),n.assign_to_global){var r=null;t instanceof Wn&&t.left instanceof fe?r=t.left:t instanceof cn&&t.init instanceof fe&&(r=t.init),r&&(r.undeclared()||r.global()&&r.scope!==r.definition().scope)&&W.warn("{msg}: {name} [{file}:{line},{col}]",{msg:r.undeclared()?"Accidental global?":"Assignment to global",name:r.name,file:r.start.file,line:r.start.line,col:r.start.col})}n.eval&&t instanceof fe&&t.undeclared()&&"eval"==t.name&&W.warn("Eval is used [{file}:{line},{col}]",t.start),n.unreferenced&&(t instanceof te||t instanceof ce)&&!(t instanceof se)&&t.unreferenced()&&W.warn("{type} {name} is declared but not referenced [{file}:{line},{col}]",{type:t instanceof ce?"Label":"Symbol",name:t.name,file:t.start.file,line:t.start.line,col:t.start.col}),n.func_arguments&&t instanceof dn&&t.uses_arguments&&W.warn("arguments used in function {name} [{file}:{line},{col}]",{name:t.name?t.name.name:"anonymous",file:t.start.file,line:t.start.line,col:t.start.col}),n.nested_defuns&&t instanceof mn&&!(e.parent()instanceof ln)&&W.warn('Function {name} declared in nested statement "{type}" [{file}:{line},{col}]',{name:t.name.name,type:e.parent().TYPE,file:t.start.file,line:t.start.line,col:t.start.col})});this.walk(e)});var Ye=/^$|[;{][\s\n]*$/;!function(){function n(n,e){n.DEFMETHOD("_codegen",e)}function e(n,t){Array.isArray(n)?n.forEach(function(n){e(n,t)}):n.DEFMETHOD("needs_parens",t)}function t(n,e,t,r){var i=n.length-1;_=r,n.forEach(function(n,r){_!==!0||n instanceof X||n instanceof nn||n instanceof Z&&n.body instanceof he||(_=!1),n instanceof nn||(t.indent(),n.print(t),r==i&&e||(t.newline(),e&&t.newline())),_===!0&&n instanceof Z&&n.body instanceof he&&(_=!1)}),_=!1}function r(n,e,r){n.length>0?e.with_block(function(){t(n,!1,e,r)}):e.print("{}")}function i(n,e){if(e.option("bracketize"))return void d(n.body,e);if(!n.body)return e.force_semicolon();if(n.body instanceof an)return void d(n.body,e);for(var t=n.body;;)if(t instanceof Dn){if(!t.alternative)return void d(n.body,e);t=t.alternative}else{if(!(t instanceof en))break;t=t.body}u(n.body,e)}function o(n,e,t){if(t)try{n.walk(new A(function(n){if(n instanceof Vn&&"in"==n.operator)throw e})),n.print(e)}catch(t){if(t!==e)throw t;n.print(e,!0)}else n.print(e)}function a(n){return[92,47,46,43,42,63,40,41,91,93,123,125,36,94,58,124,33,10,13,0,65279,8232,8233].indexOf(n)<0}function u(n,e){e.option("bracketize")?!n||n instanceof nn?e.print("{}"):n instanceof Q?n.print(e):e.with_block(function(){e.indent(),n.print(e),e.newline()}):!n||n instanceof nn?e.force_semicolon():n.print(e)}function s(n){for(var e=n.stack(),t=e.length,r=e[--t],i=e[--t];t>0;){if(i instanceof G&&i.body===r)return!0;if(!(i instanceof Nn&&i.car===r||i instanceof zn&&i.expression===r&&!(i instanceof Hn)||i instanceof Rn&&i.expression===r||i instanceof In&&i.expression===r||i instanceof Yn&&i.condition===r||i instanceof Vn&&i.left===r||i instanceof Ln&&i.expression===r))return!1;r=i,i=e[--t]}}function c(n,e){return n.args.length>0||e.option("beautify")}function l(n){for(var e=n[0],t=e.length,r=1;r<n.length;++r)n[r].length<t&&(e=n[r],t=e.length);return e}function p(n){var e,t=n.toString(10),r=[t.replace(/^0\./,".").replace("e+","e")];return Math.floor(n)===n?(n>=0?r.push("0x"+n.toString(16).toLowerCase(),"0"+n.toString(8)):r.push("-0x"+(-n).toString(16).toLowerCase(),"-0"+(-n).toString(8)),(e=/^(.*?)(0+)$/.exec(n))&&r.push(e[1]+"e"+e[2].length)):(e=/^0?\.(0+)(.*)$/.exec(n))&&r.push(e[2]+"e-"+(e[1].length+e[2].length),t.substr(t.indexOf("."))),l(r)}function d(n,e){return n instanceof Q?void n.print(e):void e.with_block(function(){e.indent(),n.print(e),e.newline()})}function h(n,e){n.DEFMETHOD("add_source_map",function(n){e(this,n)})}function v(n,e){e.add_mapping(n.start)}var m=!1,_=!1;W.DEFMETHOD("print",function(n,e){function t(){r.add_comments(n),r.add_source_map(n),i(r,n)}var r=this,i=r._codegen,o=m;r instanceof X&&"use asm"==r.value&&n.parent()instanceof ln&&(m=!0),n.push_node(r),e||r.needs_parens(n)?n.with_parens(t):t(),n.pop_node(),r instanceof ln&&(m=o)}),W.DEFMETHOD("print_to_string",function(n){var e=R(n);return n||(e._readonly=!0),this.print(e),e.get()}),W.DEFMETHOD("add_comments",function(n){if(!n._readonly){var e=this,t=e.start;if(t&&!t._comments_dumped){t._comments_dumped=!0;var r=t.comments_before||[];e instanceof gn&&e.value&&e.value.walk(new A(function(n){if(n.start&&n.start.comments_before&&(r=r.concat(n.start.comments_before),n.start.comments_before=[]),n instanceof vn||n instanceof Gn||n instanceof Jn)return!0})),r=r.filter(n.option("comments"),e),!n.option("beautify")&&r.length>0&&/comment[134]/.test(r[0].type)&&0!==n.col()&&r[0].nlb&&n.print("\n"),r.forEach(function(e){/comment[134]/.test(e.type)?(n.print("//"+e.value+"\n"),n.indent()):"comment2"==e.type?(n.print("/*"+e.value+"*/"),t.nlb?(n.print("\n"),n.indent()):n.space()):0===n.pos()&&"comment5"==e.type&&n.option("shebang")&&(n.print("#!"+e.value+"\n"),n.indent())})}}}),e(W,function(){return!1}),e(vn,function(n){if(s(n))return!0;if(n.option("wrap_iife")){var e=n.parent();return e instanceof zn&&e.expression===this}return!1}),e(Jn,function(n){return s(n)}),e([Pn,ye],function(n){var e=n.parent();return e instanceof jn&&e.expression===this||e instanceof zn&&e.expression===this}),e(Nn,function(n){var e=n.parent();return e instanceof zn||e instanceof Pn||e instanceof Vn||e instanceof Mn||e instanceof jn||e instanceof Gn||e instanceof Xn||e instanceof Yn}),e(Vn,function(n){var e=n.parent();if(e instanceof zn&&e.expression===this)return!0;if(e instanceof Pn)return!0;if(e instanceof jn&&e.expression===this)return!0;if(e instanceof Vn){var t=e.operator,r=Ue[t],i=this.operator,o=Ue[i];if(r>o||r==o&&this===e.right)return!0}}),e(jn,function(n){var e=n.parent();if(e instanceof Hn&&e.expression===this)try{this.walk(new A(function(n){if(n instanceof zn)throw e}))}catch(n){if(n!==e)throw n;return!0}}),e(zn,function(n){var e,t=n.parent();return t instanceof Hn&&t.expression===this||this.expression instanceof vn&&t instanceof jn&&t.expression===this&&(e=n.parent(1))instanceof Wn&&e.left===t}),e(Hn,function(n){var e=n.parent();if(!c(this,n)&&(e instanceof jn||e instanceof zn&&e.expression===this))return!0}),e(ve,function(n){var e=n.parent();if(e instanceof jn&&e.expression===this){var t=this.getValue();if(t<0||/^0/.test(p(t)))return!0}}),e([Wn,Yn],function(n){var e=n.parent();return e instanceof Pn||(e instanceof Vn&&!(e instanceof Wn)||(e instanceof zn&&e.expression===this||(e instanceof Yn&&e.condition===this||(e instanceof jn&&e.expression===this||void 0))))}),n(X,function(n,e){e.print_string(n.value,n.quote),e.semicolon()}),n(J,function(n,e){e.print("debugger"),e.semicolon()}),en.DEFMETHOD("_do_print_body",function(n){u(this.body,n)}),n(G,function(n,e){n.body.print(e),e.semicolon()}),n(pn,function(n,e){t(n.body,!0,e,!0),e.print("")}),n(tn,function(n,e){n.label.print(e),e.colon(),n.body.print(e)}),n(Z,function(n,e){n.body.print(e),e.semicolon()}),n(Q,function(n,e){r(n.body,e)}),n(nn,function(n,e){e.semicolon()}),n(an,function(n,e){e.print("do"),e.space(),n._do_print_body(e),e.space(),e.print("while"),e.space(),e.with_parens(function(){n.condition.print(e)}),e.semicolon()}),n(un,function(n,e){e.print("while"),e.space(),e.with_parens(function(){n.condition.print(e)}),e.space(),n._do_print_body(e)}),n(sn,function(n,e){e.print("for"),e.space(),e.with_parens(function(){!n.init||n.init instanceof nn?e.print(";"):(n.init instanceof $n?n.init.print(e):o(n.init,e,!0),e.print(";"),e.space()),n.condition?(n.condition.print(e),e.print(";"),e.space()):e.print(";"),n.step&&n.step.print(e)}),e.space(),n._do_print_body(e)}),n(cn,function(n,e){e.print("for"),e.space(),e.with_parens(function(){n.init.print(e),e.space(),e.print("in"),e.space(),n.object.print(e)}),e.space(),n._do_print_body(e)}),n(fn,function(n,e){e.print("with"),e.space(),e.with_parens(function(){n.expression.print(e)}),e.space(),n._do_print_body(e)}),dn.DEFMETHOD("_do_print",function(n,e){var t=this;e||n.print("function"),t.name&&(n.space(),t.name.print(n)),n.with_parens(function(){t.argnames.forEach(function(e,t){t&&n.comma(),e.print(n)})}),n.space(),r(t.body,n,!0)}),n(dn,function(n,e){n._do_print(e)}),gn.DEFMETHOD("_do_print",function(n,e){n.print(e),this.value&&(n.space(),this.value.print(n)),n.semicolon()}),n(bn,function(n,e){n._do_print(e,"return")}),n(yn,function(n,e){n._do_print(e,"throw")}),An.DEFMETHOD("_do_print",function(n,e){n.print(e),this.label&&(n.space(),this.label.print(n)),n.semicolon()}),n(wn,function(n,e){n._do_print(e,"break")}),n(En,function(n,e){n._do_print(e,"continue")}),n(Dn,function(n,e){e.print("if"),e.space(),e.with_parens(function(){n.condition.print(e)}),e.space(),n.alternative?(i(n,e),e.space(),e.print("else"),e.space(),u(n.alternative,e)):n._do_print_body(e)}),n(xn,function(n,e){e.print("switch"),e.space(),e.with_parens(function(){n.expression.print(e)}),e.space(),n.body.length>0?e.with_block(function(){n.body.forEach(function(n,t){t&&e.newline(),e.indent(!0),n.print(e)})}):e.print("{}")}),kn.DEFMETHOD("_do_print_body",function(n){this.body.length>0&&(n.newline(),this.body.forEach(function(e){n.indent(),e.print(n),n.newline()}))}),n(Fn,function(n,e){e.print("default:"),n._do_print_body(e)}),n(Cn,function(n,e){e.print("case"),e.space(),n.expression.print(e),e.print(":"),n._do_print_body(e)}),n(Bn,function(n,e){e.print("try"),e.space(),r(n.body,e),n.bcatch&&(e.space(),n.bcatch.print(e)),n.bfinally&&(e.space(),n.bfinally.print(e))}),n(Sn,function(n,e){e.print("catch"),e.space(),e.with_parens(function(){n.argname.print(e)}),e.space(),r(n.body,e)}),n(Tn,function(n,e){e.print("finally"),e.space(),r(n.body,e)}),$n.DEFMETHOD("_do_print",function(n,e){n.print(e),n.space(),this.definitions.forEach(function(e,t){t&&n.comma(),e.print(n)});var t=n.parent(),r=t instanceof sn||t instanceof cn,i=r&&t.init===this;i||n.semicolon()}),n(On,function(n,e){n._do_print(e,"var")}),n(qn,function(n,e){n._do_print(e,"const")}),n(Mn,function(n,e){if(n.name.print(e),n.value){e.space(),e.print("="),e.space();var t=e.parent(1),r=t instanceof sn||t instanceof cn;o(n.value,e,r)}}),n(zn,function(n,e){n.expression.print(e),n instanceof Hn&&!c(n,e)||e.with_parens(function(){n.args.forEach(function(n,t){t&&e.comma(),n.print(e)})})}),n(Hn,function(n,e){e.print("new"),e.space(),zn.prototype._codegen(n,e)}),Nn.DEFMETHOD("_do_print",function(n){this.car.print(n),this.cdr&&(n.comma(),n.should_break()&&(n.newline(),n.indent()),this.cdr.print(n))}),n(Nn,function(n,e){n._do_print(e)}),n(Rn,function(n,e){var t=n.expression;t.print(e),t instanceof ve&&t.getValue()>=0&&(/[xa-f.)]/i.test(e.last())||e.print(".")),e.print("."),e.add_mapping(n.end),e.print_name(n.property)}),n(In,function(n,e){n.expression.print(e),e.print("["),n.property.print(e),e.print("]")}),n(Un,function(n,e){var t=n.operator;e.print(t),(/^[a-z]/i.test(t)||/[+-]$/.test(t)&&n.expression instanceof Un&&/^[+-]/.test(n.expression.operator))&&e.space(),n.expression.print(e)}),n(Ln,function(n,e){n.expression.print(e),e.print(n.operator)}),n(Vn,function(n,e){var t=n.operator;n.left.print(e),">"==t[0]&&n.left instanceof Ln&&"--"==n.left.operator?e.print(" "):e.space(),e.print(t),("<"==t||"<<"==t)&&n.right instanceof Un&&"!"==n.right.operator&&n.right.expression instanceof Un&&"--"==n.right.expression.operator?e.print(" "):e.space(),n.right.print(e)}),n(Yn,function(n,e){n.condition.print(e),e.space(),e.print("?"),e.space(),n.consequent.print(e),e.space(),e.colon(),n.alternative.print(e)}),n(Gn,function(n,e){e.with_square(function(){var t=n.elements,r=t.length;r>0&&e.space(),t.forEach(function(n,t){t&&e.comma(),n.print(e),t===r-1&&n instanceof Ae&&e.comma()}),r>0&&e.space()})}),n(Jn,function(n,e){n.properties.length>0?e.with_block(function(){n.properties.forEach(function(n,t){t&&(e.print(","),e.newline()),e.indent(),n.print(e)}),e.newline()}):e.print("{}")}),n(Zn,function(n,e){var t=n.key,r=n.quote;e.option("quote_keys")?e.print_string(t+""):("number"==typeof t||!e.option("beautify")&&+t+""==t)&&parseFloat(t)>=0?e.print(p(t)):(Ce(t)?e.option("screw_ie8"):T(t))?r&&e.option("keep_quoted_props")?e.print_string(t,r):e.print_name(t):e.print_string(t,r),e.colon(),n.value.print(e)}),n(Kn,function(n,e){e.print("set"),e.space(),n.key.print(e),n.value._do_print(e,!0)}),n(Qn,function(n,e){e.print("get"),e.space(),n.key.print(e),n.value._do_print(e,!0)}),n(ne,function(n,e){var t=n.definition();e.print_name(t?t.mangled_name||t.name:n.name)}),n(ye,function(n,e){e.print("void 0")}),n(Ae,f),n(we,function(n,e){e.print("Infinity")}),n(be,function(n,e){e.print("NaN")}),n(pe,function(n,e){e.print("this")}),n(de,function(n,e){e.print(n.getValue())}),n(he,function(n,e){e.print_string(n.getValue(),n.quote,_)}),n(ve,function(n,e){m&&n.start&&null!=n.start.raw?e.print(n.start.raw):e.print(p(n.getValue()))}),n(me,function(n,e){var t=n.getValue().toString();e.option("ascii_only")?t=e.to_ascii(t):e.option("unescape_regexps")&&(t=t.split("\\\\").map(function(n){return n.replace(/\\u[0-9a-fA-F]{4}|\\x[0-9a-fA-F]{2}/g,function(n){var e=parseInt(n.substr(2),16);return a(e)?String.fromCharCode(e):n})}).join("\\\\")),e.print(t);var r=e.parent();r instanceof Vn&&/^in/.test(r.operator)&&r.left===n&&e.print(" ")}),h(W,f),h(X,v),h(J,v),h(ne,v),h(_n,v),h(en,v),h(tn,f),h(dn,v),h(xn,v),h(kn,v),h(Q,v),h(pn,f),h(Hn,v),h(Bn,v),h(Sn,v),h(Tn,v),h($n,v),h(de,v),h(Kn,function(n,e){e.add_mapping(n.start,n.key.name)}),h(Qn,function(n,e){e.add_mapping(n.start,n.key.name)}),h(Xn,function(n,e){e.add_mapping(n.start,n.key)})}(),I.prototype=new N,c(I.prototype,{option:function(n){return this.options[n]},compress:function(n){for(var e=+this.options.passes||1,t=0;t<e&&t<3;++t)t>0&&n.clear_opt_flags(),n=n.transform(this);return n},warn:function(n,e){if(this.options.warnings){var t=p(n,e);t in this.warnings_produced||(this.warnings_produced[t]=!0,W.warn.apply(W,arguments))}},clear_warnings:function(){this.warnings_produced={}},before:function(n,e,t){if(n._squeezed)return n;var r=!1;return n instanceof ln&&(n=n.hoist_declarations(this),r=!0),e(n,this),n=n.optimize(this),r&&n instanceof ln&&(n.drop_unused(this),e(n,this)),n._squeezed=!0,n}}),function(){function n(n,e){n.DEFMETHOD("optimize",function(n){var t=this;if(t._optimized)return t;if(n.has_directive("use asm"))return t;var r=e(t,n);return r._optimized=!0,r===t?r:r.transform(n)})}function e(n,e,t){return t||(t={}),e&&(t.start||(t.start=e.start),t.end||(t.end=e.end)),new n(t)}function t(n,t,r){if(t instanceof W)return t.transform(n);switch(typeof t){case"string":return e(he,r,{value:t}).optimize(n);case"number":return isNaN(t)?e(be,r):1/t<0?e(Un,r,{operator:"-",expression:e(ve,r,{value:-t})}):e(ve,r,{value:t}).optimize(n);case"boolean":return e(t?xe:De,r).optimize(n);case"undefined":return e(ye,r).optimize(n);default:if(null===t)return e(ge,r,{value:null}).optimize(n);if(t instanceof RegExp)return e(me,r,{value:t}).optimize(n);throw new Error(p("Can't handle constant of type: {type}",{type:typeof t}))}}function r(n,t,r){return n instanceof zn&&n.expression===t&&(r instanceof jn||r instanceof fe&&"eval"===r.name)?e(Nn,t,{car:e(ve,t,{value:0}),cdr:r}):r}function a(n){if(null===n)return[];if(n instanceof Q)return n.body;if(n instanceof nn)return[];if(n instanceof G)return[n];throw new Error("Can't convert thing to statement array")}function u(n){return null===n||(n instanceof nn||n instanceof Q&&0==n.body.length)}function s(n){return n instanceof xn?n:(n instanceof sn||n instanceof cn||n instanceof on)&&n.body instanceof Q?n.body:n}function c(n,t){function i(n,t){function o(n,e){return n instanceof fe&&(e instanceof Wn&&n===e.left||e instanceof Pn&&e.expression===n&&("++"==e.operator||"--"==e.operator))}function a(i,a,c){if(o(i,a))return i;var p=r(a,i,y.value);return y.value=null,d.splice(g,1),0===d.length&&(n[l]=e(nn,u),s=!0),f.clear_opt_flags(),t.warn("Replacing "+(c?"constant":"variable")+" "+w+" [{file}:{line},{col}]",i.start),b=!0,p}for(var u=t.self(),s=!1,c=n.length;--c>=0;){var f=n[c];if(!(f instanceof $n)){if([f,f.body,f.alternative,f.bcatch,f.bfinally].forEach(function(n){n&&n.body&&i(n.body,t)}),c<=0)break;var l=c-1,p=n[l];if(p instanceof $n){var d=p.definitions;if(null!=d)for(var h={},v=!1,m=!1,_={},g=d.length;--g>=0;){var y=d[g];if(null==y.value)break;var w=y.name.name;if(!w||!w.length)break;if(w in h)break;h[w]=!0;var E=u.find_variable&&u.find_variable(w);if(E&&E.references&&1===E.references.length&&"arguments"!=w){var D=E.references[0];if(D.scope.uses_eval||D.scope.uses_with)break;if(y.value instanceof me||!y.value.is_constant(t)){if(!(v|=m))if(D.scope===u){var x=new A(function(n){n instanceof fe&&o(n,x.parent())&&(_[n.name]=m=!0)});y.value.walk(x);var k=!1,F=new N(function(n){if(k)return n;var e=F.parent();return n instanceof dn||n instanceof Bn||n instanceof fn||n instanceof Cn||n instanceof rn||e instanceof Dn&&n!==e.condition||e instanceof Yn&&n!==e.condition||e instanceof Vn&&("&&"==e.operator||"||"==e.operator)&&n===e.right||e instanceof xn&&n!==e.expression?(v=k=!0,n):void 0},function(n){return k?n:n===D?(k=!0,a(n,F.parent(),!1)):(v|=n.has_side_effects(t))?(k=!0,n):m&&n instanceof fe&&n.name in _?(v=!0,k=!0,n):void 0});f.transform(F)}else v|=y.value.has_side_effects(t)}else{var C=new N(function(n){if(n===D)return a(n,C.parent(),!0)});f.transform(C)}}else v=!0}}}}if(s)for(var B=n.length;--B>=0;)n.length>1&&n[B]instanceof nn&&n.splice(B,1);return n}function o(n){function r(n){return/@ngInject/.test(n.value)}function i(n){return n.argnames.map(function(n){return e(he,n,{value:n.name})})}function o(n,t){return e(Gn,n,{elements:t})}function a(n,t){return e(Z,n,{body:e(Wn,n,{operator:"=",left:e(Rn,t,{expression:e(fe,t,t),property:"$inject"}),right:o(n,i(n))})})}function u(n){n&&n.args&&(n.args.forEach(function(n,e,t){var a=n.start.comments_before;n instanceof dn&&a.length&&r(a[0])&&(t[e]=o(n,i(n).concat(n)))}),n.expression&&n.expression.expression&&u(n.expression.expression))}return n.reduce(function(n,e){if(n.push(e),e.body&&e.body.args)u(e.body);else{var i=e.start,o=i.comments_before;if(o&&o.length>0){var s=o.pop();r(s)&&(e instanceof mn?n.push(a(e,e.name)):e instanceof $n?e.definitions.forEach(function(e){e.value&&e.value instanceof dn&&n.push(a(e.value,e.name))}):t.warn("Unknown statement marked with @ngInject [{file}:{line},{col}]",i))}}return n},[])}function u(n){var e=[];return n.reduce(function(n,t){return t instanceof Q?(b=!0,n.push.apply(n,u(t.body))):t instanceof nn?b=!0:t instanceof X?e.indexOf(t.value)<0?(n.push(t),e.push(t.value)):b=!0:n.push(t),n},[])}function c(n,t){function r(n){for(var e=0,t=n.length;--t>=0;){var r=n[t];if(r instanceof Dn&&r.body instanceof bn&&++e>1)return!0}return!1}var i=t.self(),o=r(n),u=i instanceof dn,c=[];n:for(var l=n.length;--l>=0;){var p=n[l];switch(!0){case u&&p instanceof bn&&!p.value&&0==c.length:b=!0;continue n;case p instanceof Dn:if(p.body instanceof bn){if((u&&0==c.length||c[0]instanceof bn&&!c[0].value)&&!p.body.value&&!p.alternative){b=!0;var h=e(Z,p.condition,{body:p.condition});c.unshift(h);continue n}if(c[0]instanceof bn&&p.body.value&&c[0].value&&!p.alternative){b=!0,p=p.clone(),p.alternative=c[0],c[0]=p.transform(t);continue n}if(o&&(0==c.length||c[0]instanceof bn)&&p.body.value&&!p.alternative&&u){b=!0,p=p.clone(),p.alternative=c[0]||e(bn,p,{value:e(ye,p)}),c[0]=p.transform(t);continue n}if(!p.body.value&&u){b=!0,p=p.clone(),p.condition=p.condition.negate(t);var v=a(p.alternative).concat(c),m=f(v);p.body=e(Q,p,{body:v}),p.alternative=null,c=m.concat([p.transform(t)]);continue n}if(t.option("sequences")&&1==c.length&&u&&c[0]instanceof Z&&(!p.alternative||p.alternative instanceof Z)){b=!0,c.push(e(bn,c[0],{value:e(ye,c[0])}).transform(t)),c=a(p.alternative).concat(c),c.unshift(p);continue n}}var _=y(p.body),g=_ instanceof An?t.loopcontrol_target(_.label):null;if(_&&(_ instanceof bn&&!_.value&&u||_ instanceof En&&i===s(g)||_ instanceof wn&&g instanceof Q&&i===g)){_.label&&d(_.label.thedef.references,_),b=!0;var v=a(p.body).slice(0,-1);p=p.clone(),p.condition=p.condition.negate(t),p.body=e(Q,p,{body:a(p.alternative).concat(c)}),p.alternative=e(Q,p,{body:v}),c=[p.transform(t)];continue n}var _=y(p.alternative),g=_ instanceof An?t.loopcontrol_target(_.label):null;if(_&&(_ instanceof bn&&!_.value&&u||_ instanceof En&&i===s(g)||_ instanceof wn&&g instanceof Q&&i===g)){_.label&&d(_.label.thedef.references,_),b=!0,p=p.clone(),p.body=e(Q,p.body,{body:a(p.body).concat(c)}),p.alternative=e(Q,p.alternative,{body:a(p.alternative).slice(0,-1)}),c=[p.transform(t)];continue n}c.unshift(p);break;default:c.unshift(p)}}return c}function p(n,e){var t=!1,r=n.length,i=e.self();return n=n.reduce(function(n,r){if(t)l(e,r,n);else{if(r instanceof An){var o=e.loopcontrol_target(r.label);r instanceof wn&&o instanceof Q&&s(o)===i||r instanceof En&&s(o)===i?r.label&&d(r.label.thedef.references,r):n.push(r)}else n.push(r);y(r)&&(t=!0)}return n},[]),b=n.length!=r,n}function h(n,t){function r(){i=Nn.from_array(i),i&&o.push(e(Z,i,{body:i})),i=[]}if(n.length<2)return n;var i=[],o=[];return n.forEach(function(n){n instanceof Z&&v(i)<t.sequences_limit?i.push(n.body):(r(),o.push(n))}),r(),o=m(o,t),b=o.length!=n.length,o}function v(n){for(var e=0,t=0;t<n.length;++t){var r=n[t];r instanceof Nn?e+=r.len():e++}return e}function m(n,t){function r(n){i.pop();var e=o.body;return e instanceof Nn?e.add(n):e=Nn.cons(e,n),e.transform(t)}var i=[],o=null;return n.forEach(function(n){if(o)if(n instanceof sn){var t={};try{o.body.walk(new A(function(n){if(n instanceof Vn&&"in"==n.operator)throw t})),!n.init||n.init instanceof $n?n.init||(n.init=o.body,i.pop()):n.init=r(n.init)}catch(n){if(n!==t)throw n}}else n instanceof Dn?n.condition=r(n.condition):n instanceof fn?n.expression=r(n.expression):n instanceof gn&&n.value?n.value=r(n.value):n instanceof gn?n.value=r(e(ye,n)):n instanceof xn&&(n.expression=r(n.expression));i.push(n),o=n instanceof Z?n:null}),i}function _(n,e){var t=null;return n.reduce(function(n,e){return e instanceof $n&&t&&t.TYPE==e.TYPE?(t.definitions=t.definitions.concat(e.definitions),b=!0):e instanceof sn&&t instanceof On&&(!e.init||e.init.TYPE==t.TYPE)?(b=!0,n.pop(),e.init?e.init.definitions=t.definitions.concat(e.init.definitions):e.init=t,n.push(e),t=e):(t=e,n.push(e)),n},[])}function g(n,t){function r(n){return n instanceof zn&&(n.expression instanceof vn||r(n.expression))}n.forEach(function(n){n instanceof Z&&(n.body=function n(t){return t.transform(new N(function(t){if(t instanceof Hn)return t;if(r(t))return e(Un,t,{operator:"!",expression:t});if(t instanceof zn)t.expression=n(t.expression);else if(t instanceof Nn)t.car=n(t.car);else if(t instanceof Yn){var i=n(t.condition);if(i!==t.condition){t.condition=i;var o=t.consequent;t.consequent=t.alternative,t.alternative=o}}return t}))}(n.body))})}var b,w=10;do b=!1,t.option("angular")&&(n=o(n)),n=u(n),t.option("dead_code")&&(n=p(n,t)),t.option("if_return")&&(n=c(n,t)),t.sequences_limit>0&&(n=h(n,t)),t.option("join_vars")&&(n=_(n,t)),t.option("collapse_vars")&&(n=i(n,t));while(b&&w-- >0);return t.option("negate_iife")&&g(n,t),n}function f(n){for(var e=[],t=n.length-1;t>=0;--t){var r=n[t];r instanceof mn&&(n.splice(t,1),e.unshift(r))}return e}function l(n,e,t){e instanceof mn||n.warn("Dropping unreachable code [{file}:{line},{col}]",e.start),e.walk(new A(function(e){return e instanceof $n?(n.warn("Declarations in unreachable code! [{file}:{line},{col}]",e.start),e.remove_initializers(),t.push(e),!0):e instanceof mn?(t.push(e),!0):e instanceof ln||void 0}))}function b(n,e){return n.print_to_string().length>e.print_to_string().length?e:n}function y(n){return n&&n.aborts()}function w(n,t){function r(r){r=a(r),n.body instanceof Q?(n.body=n.body.clone(),n.body.body=r.concat(n.body.body.slice(1)),n.body=n.body.transform(t)):n.body=e(Q,n.body,{body:r}).transform(t),w(n,t)}var i=n.body instanceof Q?n.body.body[0]:n.body;i instanceof Dn&&(i.body instanceof wn&&t.loopcontrol_target(i.body.label)===n?(n.condition?n.condition=e(Vn,n.condition,{left:n.condition,operator:"&&",right:i.condition.negate(t)}):n.condition=i.condition.negate(t),r(i.alternative)):i.alternative instanceof wn&&t.loopcontrol_target(i.alternative.label)===n&&(n.condition?n.condition=e(Vn,n.condition,{left:n.condition,operator:"&&",right:i.condition}):n.condition=i.condition,r(i.body)))}function E(n,e){var t=e.option("pure_getters");e.options.pure_getters=!1;var r=n.has_side_effects(e);return e.options.pure_getters=t,r}function D(n,t){return t.option("booleans")&&t.in_boolean_context()&&!n.has_side_effects(t)?e(xe,n):n}n(W,function(n,e){return n}),W.DEFMETHOD("equivalent_to",function(n){return this.print_to_string()==n.print_to_string()}),W.DEFMETHOD("clear_opt_flags",function(){this.walk(new A(function(n){n instanceof X||n instanceof de||(n._squeezed=!1,n._optimized=!1)}))}),function(n){var e=["!","delete"],t=["in","instanceof","==","!=","===","!==","<","<=",">=",">"];n(W,function(){return!1}),n(Un,function(){return i(this.operator,e)}),n(Vn,function(){return i(this.operator,t)||("&&"==this.operator||"||"==this.operator)&&this.left.is_boolean()&&this.right.is_boolean()}),n(Yn,function(){return this.consequent.is_boolean()&&this.alternative.is_boolean()}),n(Wn,function(){return"="==this.operator&&this.right.is_boolean()}),n(Nn,function(){return this.cdr.is_boolean()}),n(xe,function(){return!0}),n(De,function(){return!0})}(function(n,e){n.DEFMETHOD("is_boolean",e)}),function(n){n(W,function(){return!1}),n(he,function(){return!0}),n(Un,function(){return"typeof"==this.operator}),n(Vn,function(n){return"+"==this.operator&&(this.left.is_string(n)||this.right.is_string(n))}),n(Wn,function(n){return("="==this.operator||"+="==this.operator)&&this.right.is_string(n)}),n(Nn,function(n){return this.cdr.is_string(n)}),n(Yn,function(n){return this.consequent.is_string(n)&&this.alternative.is_string(n)}),n(zn,function(n){return n.option("unsafe")&&this.expression instanceof fe&&"String"==this.expression.name&&this.expression.undeclared()})}(function(n,e){n.DEFMETHOD("is_string",e)}),function(n){function e(n,e){if(!e)throw new Error("Compressor must be passed");return n._eval(e)}W.DEFMETHOD("evaluate",function(e){if(!e.option("evaluate"))return[this];try{var r=this._eval(e);return[b(t(e,r,this),this),r]}catch(e){if(e!==n)throw e;return[this]}}),W.DEFMETHOD("is_constant",function(n){return this instanceof de||this instanceof Un&&"!"==this.operator&&this.expression instanceof de||this.evaluate(n).length>1}),W.DEFMETHOD("constant_value",function(n){if(this instanceof de)return this.value;if(this instanceof Un&&"!"==this.operator&&this.expression instanceof de)return!this.expression.value;var e=this.evaluate(n);return e.length>1?e[1]:void 0}),n(G,function(){throw new Error(p("Cannot evaluate a statement [{file}:{line},{col}]",this.start))}),n(vn,function(){throw n}),n(W,function(){throw n}),n(de,function(){return this.getValue()}),n(Un,function(t){var r=this.expression;switch(this.operator){case"!":return!e(r,t);case"typeof":if(r instanceof vn)return"function";if(r=e(r,t),r instanceof RegExp)throw n;return typeof r;case"void":return void e(r,t);case"~":return~e(r,t);case"-":return-e(r,t);case"+":return+e(r,t)}throw n}),n(Vn,function(t){var r,i=this.left,o=this.right;switch(this.operator){case"&&":r=e(i,t)&&e(o,t);break;case"||":r=e(i,t)||e(o,t);break;case"|":r=e(i,t)|e(o,t);break;case"&":r=e(i,t)&e(o,t);break;case"^":r=e(i,t)^e(o,t);break;case"+":r=e(i,t)+e(o,t);break;case"*":r=e(i,t)*e(o,t);break;case"/":r=e(i,t)/e(o,t);break;case"%":r=e(i,t)%e(o,t);break;case"-":r=e(i,t)-e(o,t);break;case"<<":r=e(i,t)<<e(o,t);break;case">>":r=e(i,t)>>e(o,t);break;case">>>":r=e(i,t)>>>e(o,t);break;case"==":r=e(i,t)==e(o,t);break;case"===":r=e(i,t)===e(o,t);break;case"!=":r=e(i,t)!=e(o,t);break;case"!==":r=e(i,t)!==e(o,t);break;case"<":r=e(i,t)<e(o,t);break;case"<=":r=e(i,t)<=e(o,t);break;case">":r=e(i,t)>e(o,t);break;case">=":r=e(i,t)>=e(o,t);break;default:throw n}if(isNaN(r)&&t.find_parent(fn))throw n;return r}),n(Yn,function(n){return e(this.condition,n)?e(this.consequent,n):e(this.alternative,n)}),n(fe,function(t){
if(this._evaluating)throw n;this._evaluating=!0;try{var r=this.definition();if(r&&(r.constant||t.option("reduce_vars")&&!r.modified)&&r.init)return e(r.init,t)}finally{this._evaluating=!1}throw n}),n(Rn,function(t){if(t.option("unsafe")&&"length"==this.property){var r=e(this.expression,t);if("string"==typeof r)return r.length}throw n})}(function(n,e){n.DEFMETHOD("_eval",e)}),function(n){function t(n){return e(Un,n,{operator:"!",expression:n})}n(W,function(){return t(this)}),n(G,function(){throw new Error("Cannot negate a statement")}),n(vn,function(){return t(this)}),n(Un,function(){return"!"==this.operator?this.expression:t(this)}),n(Nn,function(n){var e=this.clone();return e.cdr=e.cdr.negate(n),e}),n(Yn,function(n){var e=this.clone();return e.consequent=e.consequent.negate(n),e.alternative=e.alternative.negate(n),b(t(this),e)}),n(Vn,function(n){var e=this.clone(),r=this.operator;if(n.option("unsafe_comps"))switch(r){case"<=":return e.operator=">",e;case"<":return e.operator=">=",e;case">=":return e.operator="<",e;case">":return e.operator="<=",e}switch(r){case"==":return e.operator="!=",e;case"!=":return e.operator="==",e;case"===":return e.operator="!==",e;case"!==":return e.operator="===",e;case"&&":return e.operator="||",e.left=e.left.negate(n),e.right=e.right.negate(n),b(t(this),e);case"||":return e.operator="&&",e.left=e.left.negate(n),e.right=e.right.negate(n),b(t(this),e)}return t(this)})}(function(n,e){n.DEFMETHOD("negate",function(n){return e.call(this,n)})}),function(n){n(W,function(n){return!0}),n(nn,function(n){return!1}),n(de,function(n){return!1}),n(pe,function(n){return!1}),n(zn,function(n){var e=n.option("pure_funcs");return!e||("function"==typeof e?e(this):e.indexOf(this.expression.print_to_string())<0)}),n(K,function(n){for(var e=this.body.length;--e>=0;)if(this.body[e].has_side_effects(n))return!0;return!1}),n(Z,function(n){return this.body.has_side_effects(n)}),n(mn,function(n){return!0}),n(vn,function(n){return!1}),n(Vn,function(n){return this.left.has_side_effects(n)||this.right.has_side_effects(n)}),n(Wn,function(n){return!0}),n(Yn,function(n){return this.condition.has_side_effects(n)||this.consequent.has_side_effects(n)||this.alternative.has_side_effects(n)}),n(Pn,function(n){return"delete"==this.operator||"++"==this.operator||"--"==this.operator||this.expression.has_side_effects(n)}),n(fe,function(n){return this.global()&&this.undeclared()}),n(Jn,function(n){for(var e=this.properties.length;--e>=0;)if(this.properties[e].has_side_effects(n))return!0;return!1}),n(Xn,function(n){return this.value.has_side_effects(n)}),n(Gn,function(n){for(var e=this.elements.length;--e>=0;)if(this.elements[e].has_side_effects(n))return!0;return!1}),n(Rn,function(n){return!n.option("pure_getters")||this.expression.has_side_effects(n)}),n(In,function(n){return!n.option("pure_getters")||(this.expression.has_side_effects(n)||this.property.has_side_effects(n))}),n(jn,function(n){return!n.option("pure_getters")}),n(Nn,function(n){return this.car.has_side_effects(n)||this.cdr.has_side_effects(n)})}(function(n,e){n.DEFMETHOD("has_side_effects",e)}),function(n){function e(){var n=this.body.length;return n>0&&y(this.body[n-1])}n(G,function(){return null}),n(_n,function(){return this}),n(Q,e),n(kn,e),n(Dn,function(){return this.alternative&&y(this.body)&&y(this.alternative)&&this})}(function(n,e){n.DEFMETHOD("aborts",e)}),n(X,function(n,t){return"up"===t.has_directive(n.value)?e(nn,n):n}),n(J,function(n,t){return t.option("drop_debugger")?e(nn,n):n}),n(tn,function(n,t){return n.body instanceof wn&&t.loopcontrol_target(n.body.label)===n.body?e(nn,n):0==n.label.references.length?n.body:n}),n(K,function(n,e){return n.body=c(n.body,e),n}),n(Q,function(n,t){switch(n.body=c(n.body,t),n.body.length){case 1:return n.body[0];case 0:return e(nn,n)}return n}),ln.DEFMETHOD("drop_unused",function(n){var t=this;if(n.has_directive("use asm"))return t;if(n.option("unused")&&!(t instanceof pn)&&!t.uses_eval&&!t.uses_with){var r=[],i={},o=new _,a=this,u=new A(function(e,s){if(e!==t){if(e instanceof mn)return o.add(e.name.name,e),!0;if(e instanceof $n&&a===t)return e.definitions.forEach(function(e){e.value&&(o.add(e.name.name,e.value),e.value.has_side_effects(n)&&e.value.walk(u))}),!0;if(e instanceof fe){var c=e.definition();return c.id in i||(i[c.id]=!0,r.push(c)),!0}if(e instanceof ln){var f=a;return a=e,s(),a=f,!0}}});t.walk(u);for(var s=0;s<r.length;++s)r[s].orig.forEach(function(n){var e=o.get(n.name);e&&e.forEach(function(n){var e=new A(function(n){if(n instanceof fe){var e=n.definition();e.id in i||(i[e.id]=!0,r.push(e))}});n.walk(e)})});var c=new N(function(r,o,a){if(r instanceof dn&&!(r instanceof hn)&&!n.option("keep_fargs"))for(var u=r.argnames,s=u.length;--s>=0;){var f=u[s];if(!f.unreferenced())break;u.pop(),n.warn("Dropping unused function argument {name} [{file}:{line},{col}]",{name:f.name,file:f.start.file,line:f.start.line,col:f.start.col})}if(r instanceof mn&&r!==t)return r.name.definition().id in i?r:(n.warn("Dropping unused function {name} [{file}:{line},{col}]",{name:r.name.name,file:r.name.start.file,line:r.name.start.line,col:r.name.start.col}),e(nn,r));if(r instanceof $n&&!(c.parent()instanceof cn)){var l=r.definitions.filter(function(e){if(e.name.definition().id in i)return!0;var t={name:e.name.name,file:e.name.start.file,line:e.name.start.line,col:e.name.start.col};return e.value&&e.value.has_side_effects(n)?(e._unused_side_effects=!0,n.warn("Side effects in initialization of unused variable {name} [{file}:{line},{col}]",t),!0):(n.warn("Dropping unused variable {name} [{file}:{line},{col}]",t),!1)});l=h(l,function(n,e){return!n.value&&e.value?-1:!e.value&&n.value?1:0});for(var p=[],s=0;s<l.length;){var d=l[s];d._unused_side_effects?(p.push(d.value),l.splice(s,1)):(p.length>0&&(p.push(d.value),d.value=Nn.from_array(p),p=[]),++s)}return p=p.length>0?e(Q,r,{body:[e(Z,r,{body:Nn.from_array(p)})]}):null,0!=l.length||p?0==l.length?a?V.splice(p.body):p:(r.definitions=l,p?(p.body.unshift(r),a?V.splice(p.body):p):r):e(nn,r)}if(r instanceof sn&&(o(r,this),r.init instanceof Q)){var v=r.init.body.slice(0,-1);return r.init=r.init.body.slice(-1)[0].body,v.push(r),a?V.splice(v):e(Q,r,{body:v})}return r instanceof ln&&r!==t?r:void 0});t.transform(c)}}),ln.DEFMETHOD("hoist_declarations",function(n){var t=this;if(n.has_directive("use asm"))return t;var r=n.option("hoist_funs"),i=n.option("hoist_vars");if(r||i){var a=[],u=[],s=new _,c=0,f=0;t.walk(new A(function(n){return n instanceof ln&&n!==t||(n instanceof On?(++f,!0):void 0)})),i=i&&f>1;var l=new N(function(n){if(n!==t){if(n instanceof X)return a.push(n),e(nn,n);if(n instanceof mn&&r)return u.push(n),e(nn,n);if(n instanceof On&&i){n.definitions.forEach(function(n){s.set(n.name.name,n),++c});var o=n.to_assignments(),f=l.parent();if(f instanceof cn&&f.init===n){if(null==o){var p=n.definitions[0].name;return e(fe,p,p)}return o}return f instanceof sn&&f.init===n?o:o?e(Z,n,{body:o}):e(nn,n)}if(n instanceof ln)return n}});if(t=t.transform(l),c>0){var p=[];if(s.each(function(n,e){t instanceof dn&&o(function(e){return e.name==n.name.name},t.argnames)?s.del(e):(n=n.clone(),n.value=null,p.push(n),s.set(e,n))}),p.length>0){for(var h=0;h<t.body.length;){if(t.body[h]instanceof Z){var v,m,g=t.body[h].body;if(g instanceof Wn&&"="==g.operator&&(v=g.left)instanceof ne&&s.has(v.name)){var b=s.get(v.name);if(b.value)break;b.value=g.right,d(p,b),p.push(b),t.body.splice(h,1);continue}if(g instanceof Nn&&(m=g.car)instanceof Wn&&"="==m.operator&&(v=m.left)instanceof ne&&s.has(v.name)){var b=s.get(v.name);if(b.value)break;b.value=m.right,d(p,b),p.push(b),t.body[h].body=g.cdr;continue}}if(t.body[h]instanceof nn)t.body.splice(h,1);else{if(!(t.body[h]instanceof Q))break;var y=[h,1].concat(t.body[h].body);t.body.splice.apply(t.body,y)}}p=e(On,t,{definitions:p}),u.push(p)}}t.body=a.concat(u,t.body)}return t}),n(Z,function(n,t){return t.option("side_effects")&&!n.body.has_side_effects(t)?(t.warn("Dropping side-effect-free statement [{file}:{line},{col}]",n.start),e(nn,n)):n}),n(on,function(n,t){var r=n.condition.evaluate(t);if(n.condition=r[0],!t.option("loops"))return n;if(r.length>1){if(r[1])return e(sn,n,{body:n.body});if(n instanceof un&&t.option("dead_code")){var i=[];return l(t,n.body,i),e(Q,n,{body:i})}}return n}),n(un,function(n,t){return t.option("loops")?(n=on.prototype.optimize.call(n,t),n instanceof un&&(w(n,t),n=e(sn,n,n).transform(t)),n):n}),n(sn,function(n,t){var r=n.condition;if(r&&(r=r.evaluate(t),n.condition=r[0]),!t.option("loops"))return n;if(r&&r.length>1&&!r[1]&&t.option("dead_code")){var i=[];return n.init instanceof G?i.push(n.init):n.init&&i.push(e(Z,n.init,{body:n.init})),l(t,n.body,i),e(Q,n,{body:i})}return w(n,t),n}),n(Dn,function(n,t){if(!t.option("conditionals"))return n;var r=n.condition.evaluate(t);if(n.condition=r[0],r.length>1)if(r[1]){if(t.warn("Condition always true [{file}:{line},{col}]",n.condition.start),t.option("dead_code")){var i=[];return n.alternative&&l(t,n.alternative,i),i.push(n.body),e(Q,n,{body:i}).transform(t)}}else if(t.warn("Condition always false [{file}:{line},{col}]",n.condition.start),t.option("dead_code")){var i=[];return l(t,n.body,i),n.alternative&&i.push(n.alternative),e(Q,n,{body:i}).transform(t)}u(n.alternative)&&(n.alternative=null);var o=n.condition.negate(t),a=n.condition.print_to_string().length,s=o.print_to_string().length,c=s<a;if(n.alternative&&c){c=!1,n.condition=o;var f=n.body;n.body=n.alternative||e(nn),n.alternative=f}if(u(n.body)&&u(n.alternative))return e(Z,n.condition,{body:n.condition}).transform(t);if(n.body instanceof Z&&n.alternative instanceof Z)return e(Z,n,{body:e(Yn,n,{condition:n.condition,consequent:n.body.body,alternative:n.alternative.body})}).transform(t);if(u(n.alternative)&&n.body instanceof Z)return a===s&&!c&&n.condition instanceof Vn&&"||"==n.condition.operator&&(c=!0),c?e(Z,n,{body:e(Vn,n,{operator:"||",left:o,right:n.body.body})}).transform(t):e(Z,n,{body:e(Vn,n,{operator:"&&",left:n.condition,right:n.body.body})}).transform(t);if(n.body instanceof nn&&n.alternative&&n.alternative instanceof Z)return e(Z,n,{body:e(Vn,n,{operator:"||",left:n.condition,right:n.alternative.body})}).transform(t);if(n.body instanceof gn&&n.alternative instanceof gn&&n.body.TYPE==n.alternative.TYPE)return e(n.body.CTOR,n,{value:e(Yn,n,{condition:n.condition,consequent:n.body.value||e(ye,n.body).optimize(t),alternative:n.alternative.value||e(ye,n.alternative).optimize(t)})}).transform(t);if(n.body instanceof Dn&&!n.body.alternative&&!n.alternative&&(n.condition=e(Vn,n.condition,{operator:"&&",left:n.condition,right:n.body.condition}).transform(t),n.body=n.body.body),y(n.body)&&n.alternative){var p=n.alternative;return n.alternative=null,e(Q,n,{body:[n,p]}).transform(t)}if(y(n.alternative)){var d=n.body;return n.body=n.alternative,n.condition=c?o:n.condition.negate(t),n.alternative=null,e(Q,n,{body:[n,d]}).transform(t)}return n}),n(xn,function(n,t){if(0==n.body.length&&t.option("conditionals"))return e(Z,n,{body:n.expression}).transform(t);for(;;){var r=n.body[n.body.length-1];if(r){var i=r.body[r.body.length-1];if(i instanceof wn&&s(t.loopcontrol_target(i.label))===n&&r.body.pop(),r instanceof Fn&&0==r.body.length){n.body.pop();continue}}break}var o=n.expression.evaluate(t);n:if(2==o.length)try{if(n.expression=o[0],!t.option("dead_code"))break n;var a=o[1],u=!1,c=!1,f=!1,l=!1,p=!1,d=new N(function(r,i,o){if(r instanceof dn||r instanceof Z)return r;if(r instanceof xn&&r===n)return r=r.clone(),i(r,this),p?r:e(Q,r,{body:r.body.reduce(function(n,e){return n.concat(e.body)},[])}).transform(t);if(r instanceof Dn||r instanceof Bn){var s=u;return u=!c,i(r,this),u=s,r}if(r instanceof en||r instanceof xn){var s=c;return c=!0,i(r,this),c=s,r}if(r instanceof wn&&this.loopcontrol_target(r.label)===n)return u?(p=!0,r):c?r:(l=!0,o?V.skip:e(nn,r));if(r instanceof kn&&this.parent()===n){if(l)return V.skip;if(r instanceof Cn){var d=r.expression.evaluate(t);if(d.length<2)throw n;return d[1]===a||f?(f=!0,y(r)&&(l=!0),i(r,this),r):V.skip}return i(r,this),r}});d.stack=t.stack.slice(),n=n.transform(d)}catch(e){if(e!==n)throw e}return n}),n(Cn,function(n,e){return n.body=c(n.body,e),n}),n(Bn,function(n,e){return n.body=c(n.body,e),n}),$n.DEFMETHOD("remove_initializers",function(){this.definitions.forEach(function(n){n.value=null})}),$n.DEFMETHOD("to_assignments",function(){var n=this.definitions.reduce(function(n,t){if(t.value){var r=e(fe,t.name,t.name);n.push(e(Wn,t,{operator:"=",left:r,right:t.value}))}return n},[]);return 0==n.length?null:Nn.from_array(n)}),n($n,function(n,t){return 0==n.definitions.length?e(nn,n):n}),n(vn,function(n,e){return n=dn.prototype.optimize.call(n,e),e.option("unused")&&!e.option("keep_fnames")&&n.name&&n.name.unreferenced()&&(n.name=null),n}),n(zn,function(n,r){if(r.option("unsafe")){var i=n.expression;if(i instanceof fe&&i.undeclared())switch(i.name){case"Array":if(1!=n.args.length)return e(Gn,n,{elements:n.args}).transform(r);break;case"Object":if(0==n.args.length)return e(Jn,n,{properties:[]});break;case"String":if(0==n.args.length)return e(he,n,{value:""});if(n.args.length<=1)return e(Vn,n,{left:n.args[0],operator:"+",right:e(he,n,{value:""})}).transform(r);break;case"Number":if(0==n.args.length)return e(ve,n,{value:0});if(1==n.args.length)return e(Un,n,{expression:n.args[0],operator:"+"}).transform(r);case"Boolean":if(0==n.args.length)return e(De,n);if(1==n.args.length)return e(Un,n,{expression:e(Un,null,{expression:n.args[0],operator:"!"}),operator:"!"}).transform(r);break;case"Function":if(0==n.args.length)return e(vn,n,{argnames:[],body:[]});if(m(n.args,function(n){return n instanceof he}))try{var o="(function("+n.args.slice(0,-1).map(function(n){return n.value}).join(",")+"){"+n.args[n.args.length-1].value+"})()",a=H(o);a.figure_out_scope({screw_ie8:r.option("screw_ie8")});var u=new I(r.options);a=a.transform(u),a.figure_out_scope({screw_ie8:r.option("screw_ie8")}),a.mangle_names();var s;try{a.walk(new A(function(n){if(n instanceof dn)throw s=n,a}))}catch(n){if(n!==a)throw n}if(!s)return n;var c=s.argnames.map(function(t,r){return e(he,n.args[r],{value:t.print_to_string()})}),o=R();return Q.prototype._codegen.call(s,s,o),o=o.toString().replace(/^\{|\}$/g,""),c.push(e(he,n.args[n.args.length-1],{value:o})),n.args=c,n}catch(e){if(!(e instanceof O))throw console.log(e),e;r.warn("Error parsing code passed to new Function [{file}:{line},{col}]",n.args[n.args.length-1].start),r.warn(e.toString())}}else{if(i instanceof Rn&&"toString"==i.property&&0==n.args.length)return e(Vn,n,{left:e(he,n,{value:""}),operator:"+",right:i.expression}).transform(r);if(i instanceof Rn&&i.expression instanceof Gn&&"join"==i.property){var f=0==n.args.length?",":n.args[0].evaluate(r)[1];if(null!=f){var l=i.expression.elements.reduce(function(n,e){if(e=e.evaluate(r),0==n.length||1==e.length)n.push(e);else{var i=n[n.length-1];if(2==i.length){var o=""+i[1]+f+e[1];n[n.length-1]=[t(r,o,i[0]),o]}else n.push(e)}return n},[]);if(0==l.length)return e(he,n,{value:""});if(1==l.length)return l[0][0];if(""==f){var p;return p=l[0][0]instanceof he||l[1][0]instanceof he?l.shift()[0]:e(he,n,{value:""}),l.reduce(function(n,t){return e(Vn,t[0],{operator:"+",left:n,right:t[0]})},p).transform(r)}var d=n.clone();return d.expression=d.expression.clone(),d.expression.expression=d.expression.expression.clone(),d.expression.expression.elements=l.map(function(n){return n[0]}),b(n,d)}}}}if(r.option("side_effects")&&n.expression instanceof vn&&0==n.args.length&&!K.prototype.has_side_effects.call(n.expression,r))return e(ye,n).transform(r);if(r.option("drop_console")&&n.expression instanceof jn){for(var h=n.expression.expression;h.expression;)h=h.expression;if(h instanceof fe&&"console"==h.name&&h.undeclared())return e(ye,n).transform(r)}return n.evaluate(r)[0]}),n(Hn,function(n,t){if(t.option("unsafe")){var r=n.expression;if(r instanceof fe&&r.undeclared())switch(r.name){case"Object":case"RegExp":case"Function":case"Error":case"Array":return e(zn,n,n).transform(t)}}return n}),n(Nn,function(n,t){if(!t.option("side_effects"))return n;if(!n.car.has_side_effects(t))return r(t.parent(),n,n.cdr);if(t.option("cascade")){if(n.car instanceof Wn&&!n.car.left.has_side_effects(t)){if(n.car.left.equivalent_to(n.cdr))return n.car;if(n.cdr instanceof zn&&n.cdr.expression.equivalent_to(n.car.left))return n.cdr.expression=n.car,n.cdr}if(!n.car.has_side_effects(t)&&!n.cdr.has_side_effects(t)&&n.car.equivalent_to(n.cdr))return n.car}return n.cdr instanceof Un&&"void"==n.cdr.operator&&!n.cdr.expression.has_side_effects(t)?(n.cdr.expression=n.car,n.cdr):n.cdr instanceof ye?e(Un,n,{operator:"void",expression:n.car}):n}),Pn.DEFMETHOD("lift_sequences",function(n){if(n.option("sequences")&&this.expression instanceof Nn){var e=this.expression,t=e.to_array();return this.expression=t.pop(),t.push(this),e=Nn.from_array(t).transform(n)}return this}),n(Ln,function(n,e){return n.lift_sequences(e)}),n(Un,function(n,t){n=n.lift_sequences(t);var r=n.expression;if(t.option("booleans")&&t.in_boolean_context()){switch(n.operator){case"!":if(r instanceof Un&&"!"==r.operator)return r.expression;break;case"typeof":return t.warn("Boolean expression always true [{file}:{line},{col}]",n.start),n.expression.has_side_effects(t)?e(Nn,n,{car:n.expression,cdr:e(xe,n)}):e(xe,n)}r instanceof Vn&&"!"==n.operator&&(n=b(n,r.negate(t)))}return n.evaluate(t)[0]}),Vn.DEFMETHOD("lift_sequences",function(n){if(n.option("sequences")){if(this.left instanceof Nn){var e=this.left,t=e.to_array();return this.left=t.pop(),t.push(this),e=Nn.from_array(t).transform(n)}if(this.right instanceof Nn&&this instanceof Wn&&!E(this.left,n)){var e=this.right,t=e.to_array();return this.right=t.pop(),t.push(this),e=Nn.from_array(t).transform(n)}}return this});var x=v("== === != !== * & | ^");n(Vn,function(n,t){function i(e,r){if(r||!n.left.has_side_effects(t)&&!n.right.has_side_effects(t)){e&&(n.operator=e);var i=n.left;n.left=n.right,n.right=i}}if(x(n.operator)&&(n.right instanceof de&&!(n.left instanceof de)&&(n.left instanceof Vn&&Ue[n.left.operator]>=Ue[n.operator]||i(null,!0)),/^[!=]==?$/.test(n.operator))){if(n.left instanceof fe&&n.right instanceof Yn){if(n.right.consequent instanceof fe&&n.right.consequent.definition()===n.left.definition()){if(/^==/.test(n.operator))return n.right.condition;if(/^!=/.test(n.operator))return n.right.condition.negate(t)}if(n.right.alternative instanceof fe&&n.right.alternative.definition()===n.left.definition()){if(/^==/.test(n.operator))return n.right.condition.negate(t);if(/^!=/.test(n.operator))return n.right.condition}}if(n.right instanceof fe&&n.left instanceof Yn){if(n.left.consequent instanceof fe&&n.left.consequent.definition()===n.right.definition()){if(/^==/.test(n.operator))return n.left.condition;if(/^!=/.test(n.operator))return n.left.condition.negate(t)}if(n.left.alternative instanceof fe&&n.left.alternative.definition()===n.right.definition()){if(/^==/.test(n.operator))return n.left.condition.negate(t);if(/^!=/.test(n.operator))return n.left.condition}}}if(n=n.lift_sequences(t),t.option("comparisons"))switch(n.operator){case"===":case"!==":(n.left.is_string(t)&&n.right.is_string(t)||n.left.is_boolean()&&n.right.is_boolean())&&(n.operator=n.operator.substr(0,2));case"==":case"!=":n.left instanceof he&&"undefined"==n.left.value&&n.right instanceof Un&&"typeof"==n.right.operator&&t.option("unsafe")&&(n.right.expression instanceof fe&&n.right.expression.undeclared()||(n.right=n.right.expression,n.left=e(ye,n.left).optimize(t),2==n.operator.length&&(n.operator+="=")))}if(t.option("conditionals"))if("&&"==n.operator){var o=n.left.evaluate(t);if(o.length>1)return o[1]?(t.warn("Condition left of && always true [{file}:{line},{col}]",n.start),r(t.parent(),n,n.right.evaluate(t)[0])):(t.warn("Condition left of && always false [{file}:{line},{col}]",n.start),r(t.parent(),n,o[0]))}else if("||"==n.operator){var o=n.left.evaluate(t);if(o.length>1)return o[1]?(t.warn("Condition left of || always true [{file}:{line},{col}]",n.start),r(t.parent(),n,o[0])):(t.warn("Condition left of || always false [{file}:{line},{col}]",n.start),r(t.parent(),n,n.right.evaluate(t)[0]))}if(t.option("booleans")&&t.in_boolean_context())switch(n.operator){case"&&":var o=n.left.evaluate(t),a=n.right.evaluate(t);if(o.length>1&&!o[1]||a.length>1&&!a[1])return t.warn("Boolean && always false [{file}:{line},{col}]",n.start),n.left.has_side_effects(t)?e(Nn,n,{car:n.left,cdr:e(De)}).optimize(t):e(De,n);if(o.length>1&&o[1])return a[0];if(a.length>1&&a[1])return o[0];break;case"||":var o=n.left.evaluate(t),a=n.right.evaluate(t);if(o.length>1&&o[1]||a.length>1&&a[1])return t.warn("Boolean || always true [{file}:{line},{col}]",n.start),n.left.has_side_effects(t)?e(Nn,n,{car:n.left,cdr:e(xe)}).optimize(t):e(xe,n);if(o.length>1&&!o[1])return a[0];if(a.length>1&&!a[1])return o[0];break;case"+":var o=n.left.evaluate(t),a=n.right.evaluate(t);if(o.length>1&&o[0]instanceof he&&o[1]&&!n.right.has_side_effects(t)||a.length>1&&a[0]instanceof he&&a[1]&&!n.left.has_side_effects(t))return t.warn("+ in boolean context always true [{file}:{line},{col}]",n.start),e(xe,n)}if(t.option("comparisons")&&n.is_boolean()){if(!(t.parent()instanceof Vn)||t.parent()instanceof Wn){var u=e(Un,n,{operator:"!",expression:n.negate(t)});n=b(n,u)}if(t.option("unsafe_comps"))switch(n.operator){case"<":i(">");break;case"<=":i(">=")}}return"+"==n.operator&&n.right instanceof he&&""===n.right.getValue()&&n.left instanceof Vn&&"+"==n.left.operator&&n.left.is_string(t)?n.left:(t.option("evaluate")&&"+"==n.operator&&(n.left instanceof de&&n.right instanceof Vn&&"+"==n.right.operator&&n.right.left instanceof de&&n.right.is_string(t)&&(n=e(Vn,n,{operator:"+",left:e(he,null,{value:""+n.left.getValue()+n.right.left.getValue(),start:n.left.start,end:n.right.left.end}),right:n.right.right})),n.right instanceof de&&n.left instanceof Vn&&"+"==n.left.operator&&n.left.right instanceof de&&n.left.is_string(t)&&(n=e(Vn,n,{operator:"+",left:n.left.left,right:e(he,null,{value:""+n.left.right.getValue()+n.right.getValue(),start:n.left.right.start,end:n.right.end})})),n.left instanceof Vn&&"+"==n.left.operator&&n.left.is_string(t)&&n.left.right instanceof de&&n.right instanceof Vn&&"+"==n.right.operator&&n.right.left instanceof de&&n.right.is_string(t)&&(n=e(Vn,n,{operator:"+",left:e(Vn,n.left,{operator:"+",left:n.left.left,right:e(he,null,{value:""+n.left.right.getValue()+n.right.left.getValue(),start:n.left.right.start,end:n.right.left.end})}),right:n.right.right}))),n.right instanceof Vn&&n.right.operator==n.operator&&("&&"==n.operator||"||"==n.operator)?(n.left=e(Vn,n.left,{operator:n.operator,left:n.left,right:n.right.left}),n.right=n.right.right,n.transform(t)):n.evaluate(t)[0])}),n(fe,function(n,r){function i(n,e){return e instanceof Vn&&"="===e.operator&&e.left===n}if(n.undeclared()&&!i(n,r.parent())){var o=r.option("global_defs");if(o&&g(o,n.name))return t(r,o[n.name],n);if(!n.scope.uses_with||!r.find_parent(fn))switch(n.name){case"undefined":return e(ye,n);case"NaN":return e(be,n).transform(r);case"Infinity":return e(we,n).transform(r)}}return n}),n(we,function(n,t){return e(Vn,n,{operator:"/",left:e(ve,n,{value:1}),right:e(ve,n,{value:0})})}),n(ye,function(n,t){if(t.option("unsafe")){var r=t.find_parent(ln),i=r.find_variable("undefined");if(i){var o=e(fe,n,{name:"undefined",scope:r,thedef:i});return o.reference(),o}}return n});var k=["+","-","/","*","%",">>","<<",">>>","|","^","&"],F=["*","|","^","&"];n(Wn,function(n,e){return n=n.lift_sequences(e),"="==n.operator&&n.left instanceof fe&&n.right instanceof Vn&&(n.right.left instanceof fe&&n.right.left.name==n.left.name&&i(n.right.operator,k)?(n.operator=n.right.operator+"=",n.right=n.right.right):n.right.right instanceof fe&&n.right.right.name==n.left.name&&i(n.right.operator,F)&&!n.right.left.has_side_effects(e)&&(n.operator=n.right.operator+"=",n.right=n.right.left)),n}),n(Yn,function(n,i){function o(n){return n.is_boolean()?n:e(Un,n,{operator:"!",expression:n.negate(i)})}function a(n){return n instanceof xe||n instanceof Un&&"!"==n.operator&&n.expression instanceof de&&!n.expression.value}function u(n){return n instanceof De||n instanceof Un&&"!"==n.operator&&n.expression instanceof de&&!!n.expression.value}if(!i.option("conditionals"))return n;if(n.condition instanceof Nn){var s=n.condition.car;return n.condition=n.condition.cdr,Nn.cons(s,n)}var c=n.condition.evaluate(i);if(c.length>1)return c[1]?(i.warn("Condition always true [{file}:{line},{col}]",n.start),r(i.parent(),n,n.consequent)):(i.warn("Condition always false [{file}:{line},{col}]",n.start),r(i.parent(),n,n.alternative));var f=c[0].negate(i);b(c[0],f)===f&&(n=e(Yn,n,{condition:f,consequent:n.alternative,alternative:n.consequent}));var l=n.consequent,p=n.alternative;if(l instanceof Wn&&p instanceof Wn&&l.operator==p.operator&&l.left.equivalent_to(p.left)&&!l.left.has_side_effects(i))return e(Wn,n,{operator:l.operator,left:l.left,right:e(Yn,n,{condition:n.condition,consequent:l.right,alternative:p.right})});if(l instanceof zn&&p.TYPE===l.TYPE&&l.args.length==p.args.length&&!l.expression.has_side_effects(i)&&l.expression.equivalent_to(p.expression)){if(0==l.args.length)return e(Nn,n,{car:n.condition,cdr:l});if(1==l.args.length)return l.args[0]=e(Yn,n,{condition:n.condition,consequent:l.args[0],alternative:p.args[0]}),l}if(l instanceof Yn&&l.alternative.equivalent_to(p))return e(Yn,n,{condition:e(Vn,n,{left:n.condition,operator:"&&",right:l.condition}),consequent:l.consequent,alternative:p});if(l.is_constant(i)&&p.is_constant(i)&&l.equivalent_to(p)){var d=l.constant_value(i);return n.condition.has_side_effects(i)?Nn.from_array([n.condition,t(i,d,n)]):t(i,d,n)}return a(n.consequent)?u(n.alternative)?o(n.condition):e(Vn,n,{operator:"||",left:o(n.condition),right:n.alternative}):u(n.consequent)?a(n.alternative)?o(n.condition.negate(i)):e(Vn,n,{operator:"&&",left:o(n.condition.negate(i)),right:n.alternative}):a(n.alternative)?e(Vn,n,{operator:"||",left:o(n.condition.negate(i)),right:n.consequent}):u(n.alternative)?e(Vn,n,{operator:"&&",left:o(n.condition),right:n.consequent}):n}),n(Ee,function(n,t){if(t.option("booleans")){var r=t.parent();return r instanceof Vn&&("=="==r.operator||"!="==r.operator)?(t.warn("Non-strict equality against boolean: {operator} {value} [{file}:{line},{col}]",{operator:r.operator,value:n.value,file:r.start.file,line:r.start.line,col:r.start.col}),e(ve,n,{value:+n.value})):e(Un,n,{operator:"!",expression:e(ve,n,{value:1-n.value})})}return n}),n(In,function(n,t){var r=n.property;if(r instanceof he&&t.option("properties")){if(r=r.getValue(),Ce(r)?t.option("screw_ie8"):T(r))return e(Rn,n,{expression:n.expression,property:r}).optimize(t);var i=parseFloat(r);isNaN(i)||i.toString()!=r||(n.property=e(ve,n.property,{value:i}))}return n}),n(Rn,function(n,t){var r=n.property;return Ce(r)&&!t.option("screw_ie8")?e(In,n,{expression:n.expression,property:e(he,n,{value:r})}).optimize(t):n.evaluate(t)[0]}),n(Gn,D),n(Jn,D),n(me,D),n(bn,function(n,e){return n.value instanceof ye&&(n.value=null),n})}(),function(){function e(n){if("Literal"==n.type)return null!=n.raw?n.raw:n.value+""}function t(n){var t=n.loc,r=t&&t.start,i=n.range;return new Y({file:t&&t.source,line:r&&r.line,col:r&&r.column,pos:i?i[0]:n.start,endline:r&&r.line,endcol:r&&r.column,endpos:i?i[0]:n.start,raw:e(n)})}function r(n){var t=n.loc,r=t&&t.end,i=n.range;return new Y({file:t&&t.source,line:r&&r.line,col:r&&r.column,pos:i?i[1]:n.end,endline:r&&r.line,endcol:r&&r.column,endpos:i?i[1]:n.end,raw:e(n)})}function i(e,i,a){var f="function From_Moz_"+e+"(M){\n";f+="return new U2."+i.name+"({\nstart: my_start_token(M),\nend: my_end_token(M)";var p="function To_Moz_"+e+"(M){\n";p+="return {\ntype: "+JSON.stringify(e),a&&a.split(/\s*,\s*/).forEach(function(n){var e=/([a-z0-9$_]+)(=|@|>|%)([a-z0-9$_]+)/i.exec(n);if(!e)throw new Error("Can't understand property map: "+n);var t=e[1],r=e[2],i=e[3];switch(f+=",\n"+i+": ",p+=",\n"+t+": ",r){case"@":f+="M."+t+".map(from_moz)",p+="M."+i+".map(to_moz)";break;case">":f+="from_moz(M."+t+")",p+="to_moz(M."+i+")";break;case"=":f+="M."+t,p+="M."+i;break;case"%":f+="from_moz(M."+t+").body",p+="to_moz_block(M)";break;default:throw new Error("Can't understand operator in propmap: "+n)}}),f+="\n})\n}",p+="\n}\n}",f=new Function("U2","my_start_token","my_end_token","from_moz","return("+f+")")(n,t,r,o),p=new Function("to_moz","to_moz_block","return("+p+")")(s,c),l[e]=f,u(i,p)}function o(n){p.push(n);var e=null!=n?l[n.type](n):null;return p.pop(),e}function a(n,e,t){var r=n.start,i=n.end;return null!=r.pos&&null!=i.endpos&&(e.range=[r.pos,i.endpos]),r.line&&(e.loc={start:{line:r.line,column:r.col},end:i.endline?{line:i.endline,column:i.endcol}:null},r.file&&(e.loc.source=r.file)),e}function u(n,e){n.DEFMETHOD("to_mozilla_ast",function(){return a(this,e(this))})}function s(n){return null!=n?n.to_mozilla_ast():null}function c(n){return{type:"BlockStatement",body:n.body.map(s)}}var f=function(n){for(var e=!0,t=0;t<n.length;t++)e&&n[t]instanceof G&&n[t].body instanceof he?n[t]=new X({start:n[t].start,end:n[t].end,value:n[t].body.value}):!e||n[t]instanceof G&&n[t].body instanceof he||(e=!1);return n},l={Program:function(n){return new pn({start:t(n),end:r(n),body:f(n.body.map(o))})},FunctionDeclaration:function(n){return new mn({start:t(n),end:r(n),name:o(n.id),argnames:n.params.map(o),body:f(o(n.body).body)})},FunctionExpression:function(n){return new vn({start:t(n),end:r(n),name:o(n.id),argnames:n.params.map(o),body:f(o(n.body).body)})},ExpressionStatement:function(n){return new Z({start:t(n),end:r(n),body:o(n.expression)})},TryStatement:function(n){var e=n.handlers||[n.handler];if(e.length>1||n.guardedHandlers&&n.guardedHandlers.length)throw new Error("Multiple catch clauses are not supported.");return new Bn({start:t(n),end:r(n),body:o(n.block).body,bcatch:o(e[0]),bfinally:n.finalizer?new Tn(o(n.finalizer)):null})},Property:function(n){var e=n.key,i="Identifier"==e.type?e.name:e.value,a={start:t(e),end:r(n.value),key:i,value:o(n.value)};switch(n.kind){case"init":return new Zn(a);case"set":return a.value.name=o(e),new Kn(a);case"get":return a.value.name=o(e),new Qn(a)}},ArrayExpression:function(n){return new Gn({start:t(n),end:r(n),elements:n.elements.map(function(n){return null===n?new Ae:o(n)})})},ObjectExpression:function(n){return new Jn({start:t(n),end:r(n),properties:n.properties.map(function(n){return n.type="Property",o(n)})})},SequenceExpression:function(n){return Nn.from_array(n.expressions.map(o))},MemberExpression:function(n){return new(n.computed?In:Rn)({start:t(n),end:r(n),property:n.computed?o(n.property):n.property.name,expression:o(n.object)})},SwitchCase:function(n){return new(n.test?Cn:Fn)({start:t(n),end:r(n),expression:o(n.test),body:n.consequent.map(o)})},VariableDeclaration:function(n){return new("const"===n.kind?qn:On)({start:t(n),end:r(n),definitions:n.declarations.map(o)})},Literal:function(n){var e=n.value,i={start:t(n),end:r(n)};if(null===e)return new ge(i);switch(typeof e){case"string":return i.value=e,new he(i);case"number":return i.value=e,new ve(i);case"boolean":return new(e?xe:De)(i);default:var o=n.regex;return o&&o.pattern?i.value=new RegExp(o.pattern,o.flags).toString():i.value=n.regex&&n.raw?n.raw:e,new me(i)}},Identifier:function(n){var e=p[p.length-2];return new("LabeledStatement"==e.type?ce:"VariableDeclarator"==e.type&&e.id===n?"const"==e.kind?ie:re:"FunctionExpression"==e.type?e.id===n?ue:oe:"FunctionDeclaration"==e.type?e.id===n?ae:oe:"CatchClause"==e.type?se:"BreakStatement"==e.type||"ContinueStatement"==e.type?le:fe)({start:t(n),end:r(n),name:n.name})}};l.UpdateExpression=l.UnaryExpression=function(n){var e="prefix"in n?n.prefix:"UnaryExpression"==n.type;return new(e?Un:Ln)({start:t(n),end:r(n),operator:n.operator,expression:o(n.argument)})},i("EmptyStatement",nn),i("BlockStatement",Q,"body@body"),i("IfStatement",Dn,"test>condition, consequent>body, alternate>alternative"),i("LabeledStatement",tn,"label>label, body>body"),
i("BreakStatement",wn,"label>label"),i("ContinueStatement",En,"label>label"),i("WithStatement",fn,"object>expression, body>body"),i("SwitchStatement",xn,"discriminant>expression, cases@body"),i("ReturnStatement",bn,"argument>value"),i("ThrowStatement",yn,"argument>value"),i("WhileStatement",un,"test>condition, body>body"),i("DoWhileStatement",an,"test>condition, body>body"),i("ForStatement",sn,"init>init, test>condition, update>step, body>body"),i("ForInStatement",cn,"left>init, right>object, body>body"),i("DebuggerStatement",J),i("VariableDeclarator",Mn,"id>name, init>value"),i("CatchClause",Sn,"param>argname, body%body"),i("ThisExpression",pe),i("BinaryExpression",Vn,"operator=operator, left>left, right>right"),i("LogicalExpression",Vn,"operator=operator, left>left, right>right"),i("AssignmentExpression",Wn,"operator=operator, left>left, right>right"),i("ConditionalExpression",Yn,"test>condition, consequent>consequent, alternate>alternative"),i("NewExpression",Hn,"callee>expression, arguments@args"),i("CallExpression",zn,"callee>expression, arguments@args"),u(pn,function(n){return{type:"Program",body:n.body.map(s)}}),u(mn,function(n){return{type:"FunctionDeclaration",id:s(n.name),params:n.argnames.map(s),body:c(n)}}),u(vn,function(n){return{type:"FunctionExpression",id:s(n.name),params:n.argnames.map(s),body:c(n)}}),u(X,function(n){return{type:"ExpressionStatement",expression:{type:"Literal",value:n.value}}}),u(Z,function(n){return{type:"ExpressionStatement",expression:s(n.body)}}),u(kn,function(n){return{type:"SwitchCase",test:s(n.expression),consequent:n.body.map(s)}}),u(Bn,function(n){return{type:"TryStatement",block:c(n),handler:s(n.bcatch),guardedHandlers:[],finalizer:s(n.bfinally)}}),u(Sn,function(n){return{type:"CatchClause",param:s(n.argname),guard:null,body:c(n)}}),u($n,function(n){return{type:"VariableDeclaration",kind:n instanceof qn?"const":"var",declarations:n.definitions.map(s)}}),u(Nn,function(n){return{type:"SequenceExpression",expressions:n.to_array().map(s)}}),u(jn,function(n){var e=n instanceof In;return{type:"MemberExpression",object:s(n.expression),computed:e,property:e?s(n.property):{type:"Identifier",name:n.property}}}),u(Pn,function(n){return{type:"++"==n.operator||"--"==n.operator?"UpdateExpression":"UnaryExpression",operator:n.operator,prefix:n instanceof Un,argument:s(n.expression)}}),u(Vn,function(n){return{type:"&&"==n.operator||"||"==n.operator?"LogicalExpression":"BinaryExpression",left:s(n.left),operator:n.operator,right:s(n.right)}}),u(Gn,function(n){return{type:"ArrayExpression",elements:n.elements.map(s)}}),u(Jn,function(n){return{type:"ObjectExpression",properties:n.properties.map(s)}}),u(Xn,function(n){var e,t=C(n.key)?{type:"Identifier",name:n.key}:{type:"Literal",value:n.key};return n instanceof Zn?e="init":n instanceof Qn?e="get":n instanceof Kn&&(e="set"),{type:"Property",kind:e,key:t,value:s(n.value)}}),u(ne,function(n){var e=n.definition();return{type:"Identifier",name:e?e.mangled_name||e.name:n.name}}),u(me,function(n){var e=n.value;return{type:"Literal",value:e,raw:e.toString(),regex:{pattern:e.source,flags:e.toString().match(/[gimuy]*$/)[0]}}}),u(de,function(n){var e=n.value;return"number"==typeof e&&(e<0||0===e&&1/e<0)?{type:"UnaryExpression",operator:"-",prefix:!0,argument:{type:"Literal",value:-e,raw:n.start.raw}}:{type:"Literal",value:e,raw:n.start.raw}}),u(_e,function(n){return{type:"Identifier",name:String(n.value)}}),Ee.DEFMETHOD("to_mozilla_ast",de.prototype.to_mozilla_ast),ge.DEFMETHOD("to_mozilla_ast",de.prototype.to_mozilla_ast),Ae.DEFMETHOD("to_mozilla_ast",function(){return null}),K.DEFMETHOD("to_mozilla_ast",Q.prototype.to_mozilla_ast),dn.DEFMETHOD("to_mozilla_ast",vn.prototype.to_mozilla_ast);var p=null;W.from_mozilla_ast=function(n){var e=p;p=[];var t=o(n);return p=e,t}}(),n.Compressor=I,n.DefaultsError=u,n.Dictionary=_,n.JS_Parse_Error=O,n.MAP=V,n.OutputStream=R,n.SourceMap=P,n.TreeTransformer=N,n.TreeWalker=A,n.base54=Ve,n.defaults=s,n.mangle_properties=L,n.merge=c,n.parse=H,n.push_uniq=l,n.string_template=p,n.tokenizer=z,n.is_identifier=C,n.SymbolDef=j,"undefined"!=typeof DEBUG&&DEBUG&&(n.EXPECT_DIRECTIVE=Ye),module.exports=n}({},function(){return this}());

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {


/*!
 * Jade - Compiler
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var nodes = __webpack_require__(6)
  , filters = __webpack_require__(5)
  , doctypes = __webpack_require__(8)
  , selfClosing = __webpack_require__(12)
  , runtime = __webpack_require__(11)
  , utils = __webpack_require__(4)
  , parseJSExpression = __webpack_require__(13).parseMax

// if browser
//
// if (!Object.keys) {
//   Object.keys = function(obj){
//     var arr = [];
//     for (var key in obj) {
//       if (obj.hasOwnProperty(key)) {
//         arr.push(key);
//       }
//     }
//     return arr;
//   }
// }
//
// if (!String.prototype.trimLeft) {
//   String.prototype.trimLeft = function(){
//     return this.replace(/^\s+/, '');
//   }
// }
//
// end


/**
 * Initialize `Compiler` with the given `node`.
 *
 * @param {Node} node
 * @param {Object} options
 * @api public
 */

var Compiler = module.exports = function Compiler(node, options) {
  this.options = options = options || {};
  this.node = node;
  this.hasCompiledDoctype = false;
  this.hasCompiledTag = false;
  this.pp = options.pretty || false;
  this.debug = false !== options.compileDebug;
  this.indents = 0;
  this.parentIndents = 0;
  if (options.doctype) this.setDoctype(options.doctype);
};

/**
 * Compiler prototype.
 */

Compiler.prototype = {

  /**
   * Compile parse tree to JavaScript.
   *
   * @api public
   */

  compile: function(){
    this.buf = [];
    if (this.pp) this.buf.push("jade.indent = [];");
    this.lastBufferedIdx = -1;
    this.visit(this.node);
    return this.buf.join('\n');
  },

  /**
   * Sets the default doctype `name`. Sets terse mode to `true` when
   * html 5 is used, causing self-closing tags to end with ">" vs "/>",
   * and boolean attributes are not mirrored.
   *
   * @param {string} name
   * @api public
   */

  setDoctype: function(name){
    name = (name && name.toLowerCase()) || 'default';
    this.doctype = doctypes[name] || '<!DOCTYPE ' + name + '>';
    this.terse = this.doctype.toLowerCase() == '<!doctype html>';
    this.xml = 0 == this.doctype.indexOf('<?xml');
  },

  /**
   * Buffer the given `str` exactly as is or with interpolation
   *
   * @param {String} str
   * @param {Boolean} interpolate
   * @api public
   */

  buffer: function (str, interpolate) {
    var self = this;
    if (interpolate) {
      var match = /(\\)?([#!]){((?:.|\n)*)$/.exec(str);
      if (match) {
        this.buffer(str.substr(0, match.index), false);
        if (match[1]) { // escape
          this.buffer(match[2] + '{', false);
          this.buffer(match[3], true);
          return;
        } else {
          try {
            var rest = match[3];
            var range = parseJSExpression(rest);
            var code = ('!' == match[2] ? '' : 'jade.escape') + "((jade.interp = " + range.src + ") == null ? '' : jade.interp)";
          } catch (ex) {
            throw ex;
            //didn't match, just as if escaped
            this.buffer(match[2] + '{', false);
            this.buffer(match[3], true);
            return;
          }
          this.bufferExpression(code);
          this.buffer(rest.substr(range.end + 1), true);
          return;
        }
      }
    }

    str = JSON.stringify(str);
    str = str.substr(1, str.length - 2);

    if (this.lastBufferedIdx == this.buf.length) {
      if (this.lastBufferedType === 'code') this.lastBuffered += ' + "';
      this.lastBufferedType = 'text';
      this.lastBuffered += str;
      this.buf[this.lastBufferedIdx - 1] = 'buf.push(' + this.bufferStartChar + this.lastBuffered + '");'
    } else {
      this.buf.push('buf.push("' + str + '");');
      this.lastBufferedType = 'text';
      this.bufferStartChar = '"';
      this.lastBuffered = str;
      this.lastBufferedIdx = this.buf.length;
    }
  },

  /**
   * Buffer the given `src` so it is evaluated at run time
   *
   * @param {String} src
   * @api public
   */

  bufferExpression: function (src) {
    if (this.lastBufferedIdx == this.buf.length) {
      if (this.lastBufferedType === 'text') this.lastBuffered += '"';
      this.lastBufferedType = 'code';
      this.lastBuffered += ' + (' + src + ')';
      this.buf[this.lastBufferedIdx - 1] = 'buf.push(' + this.bufferStartChar + this.lastBuffered + ');'
    } else {
      this.buf.push('buf.push(' + src + ');');
      this.lastBufferedType = 'code';
      this.bufferStartChar = '';
      this.lastBuffered = '(' + src + ')';
      this.lastBufferedIdx = this.buf.length;
    }
  },

  /**
   * Buffer an indent based on the current `indent`
   * property and an additional `offset`.
   *
   * @param {Number} offset
   * @param {Boolean} newline
   * @api public
   */

  prettyIndent: function(offset, newline){
    offset = offset || 0;
    newline = newline ? '\n' : '';
    this.buffer(newline + Array(this.indents + offset).join('  '));
    if (this.parentIndents)
      this.buf.push("buf.push.apply(buf, jade.indent);");
  },

  /**
   * Visit `node`.
   *
   * @param {Node} node
   * @api public
   */

  visit: function(node){
    var debug = this.debug;

    if (debug) {
      this.buf.push('jade.debug.unshift({ lineno: ' + node.line
        + ', filename: ' + (node.filename
          ? JSON.stringify(node.filename)
          : 'jade.debug[0].filename')
        + ' });');
    }

    // Massive hack to fix our context
    // stack for - else[ if] etc
    if (false === node.debug && this.debug) {
      this.buf.pop();
      this.buf.pop();
    }

    this.visitNode(node);

    if (debug) this.buf.push('jade.debug.shift();');
  },

  /**
   * Visit `node`.
   *
   * @param {Node} node
   * @api public
   */

  visitNode: function(node){
    var name = node.constructor.name
      || node.constructor.toString().match(/function ([^(\s]+)()/)[1];
    return this['visit' + name](node);
  },

  /**
   * Visit case `node`.
   *
   * @param {Literal} node
   * @api public
   */

  visitCase: function(node){
    var _ = this.withinCase;
    this.withinCase = true;
    this.buf.push('switch (' + node.expr + '){');
    this.visit(node.block);
    this.buf.push('}');
    this.withinCase = _;
  },

  /**
   * Visit when `node`.
   *
   * @param {Literal} node
   * @api public
   */

  visitWhen: function(node){
    if ('default' == node.expr) {
      this.buf.push('default:');
    } else {
      this.buf.push('case ' + node.expr + ':');
    }
    this.visit(node.block);
    this.buf.push('  break;');
  },

  /**
   * Visit literal `node`.
   *
   * @param {Literal} node
   * @api public
   */

  visitLiteral: function(node){
    this.buffer(node.str);
  },

  /**
   * Visit all nodes in `block`.
   *
   * @param {Block} block
   * @api public
   */

  visitBlock: function(block){
    var len = block.nodes.length
      , escape = this.escape
      , pp = this.pp

    // Block keyword has a special meaning in mixins
    if (this.parentIndents && block.mode) {
      if (pp) this.buf.push("jade.indent.push('" + Array(this.indents + 1).join('  ') + "');")
      this.buf.push('block && block();');
      if (pp) this.buf.push("jade.indent.pop();")
      return;
    }

    // Pretty print multi-line text
    if (pp && len > 1 && !escape && block.nodes[0].isText && block.nodes[1].isText)
      this.prettyIndent(1, true);

    for (var i = 0; i < len; ++i) {
      // Pretty print text
      if (pp && i > 0 && !escape && block.nodes[i].isText && block.nodes[i-1].isText)
        this.prettyIndent(1, false);

      this.visit(block.nodes[i]);
      // Multiple text nodes are separated by newlines
      if (block.nodes[i+1] && block.nodes[i].isText && block.nodes[i+1].isText)
        this.buffer('\n');
    }
  },

  /**
   * Visit `doctype`. Sets terse mode to `true` when html 5
   * is used, causing self-closing tags to end with ">" vs "/>",
   * and boolean attributes are not mirrored.
   *
   * @param {Doctype} doctype
   * @api public
   */

  visitDoctype: function(doctype){
    if (doctype && (doctype.val || !this.doctype)) {
      this.setDoctype(doctype.val || 'default');
    }

    if (this.doctype) this.buffer(this.doctype);
    this.hasCompiledDoctype = true;
  },

  /**
   * Visit `mixin`, generating a function that
   * may be called within the template.
   *
   * @param {Mixin} mixin
   * @api public
   */

  visitMixin: function(mixin){
    var name = mixin.name.replace(/-/g, '_') + '_mixin'
      , args = mixin.args || ''
      , block = mixin.block
      , attrs = mixin.attrs
      , pp = this.pp;

    if (mixin.call) {
      if (pp) this.buf.push("jade.indent.push('" + Array(this.indents + 1).join('  ') + "');")
      if (block || attrs.length) {

        this.buf.push(name + '.call({');

        if (block) {
          this.buf.push('block: function(){');

          // Render block with no indents, dynamically added when rendered
          this.parentIndents++;
          var _indents = this.indents;
          this.indents = 0;
          this.visit(mixin.block);
          this.indents = _indents;
          this.parentIndents--;

          if (attrs.length) {
            this.buf.push('},');
          } else {
            this.buf.push('}');
          }
        }

        if (attrs.length) {
          var val = this.attrs(attrs);
          if (val.inherits) {
            this.buf.push('attributes: jade.merge({' + val.buf
                + '}, attributes), escaped: jade.merge(' + val.escaped + ', escaped, true)');
          } else {
            this.buf.push('attributes: {' + val.buf + '}, escaped: ' + val.escaped);
          }
        }

        if (args) {
          this.buf.push('}, ' + args + ');');
        } else {
          this.buf.push('});');
        }

      } else {
        this.buf.push(name + '(' + args + ');');
      }
      if (pp) this.buf.push("jade.indent.pop();")
    } else {
      this.buf.push('var ' + name + ' = function(' + args + '){');
      this.buf.push('var block = this.block, attributes = this.attributes || {}, escaped = this.escaped || {};');
      this.parentIndents++;
      this.visit(block);
      this.parentIndents--;
      this.buf.push('};');
    }
  },

  /**
   * Visit `tag` buffering tag markup, generating
   * attributes, visiting the `tag`'s code and block.
   *
   * @param {Tag} tag
   * @api public
   */

  visitTag: function(tag){
    this.indents++;
    var name = tag.name
      , pp = this.pp
      , self = this;

    function bufferName() {
      if (tag.buffer) self.bufferExpression(name);
      else self.buffer(name);
    }

    if (!this.hasCompiledTag) {
      if (!this.hasCompiledDoctype && 'html' == name) {
        this.visitDoctype();
      }
      this.hasCompiledTag = true;
    }

    // pretty print
    if (pp && !tag.isInline())
      this.prettyIndent(0, true);

    if ((~selfClosing.indexOf(name) || tag.selfClosing) && !this.xml) {
      this.buffer('<');
      bufferName();
      this.visitAttributes(tag.attrs);
      this.terse
        ? this.buffer('>')
        : this.buffer('/>');
    } else {
      // Optimize attributes buffering
      if (tag.attrs.length) {
        this.buffer('<');
        bufferName();
        if (tag.attrs.length) this.visitAttributes(tag.attrs);
        this.buffer('>');
      } else {
        this.buffer('<');
        bufferName();
        this.buffer('>');
      }
      if (tag.code) this.visitCode(tag.code);
      this.escape = 'pre' == tag.name;
      this.visit(tag.block);

      // pretty print
      if (pp && !tag.isInline() && 'pre' != tag.name && !tag.canInline())
        this.prettyIndent(0, true);

      this.buffer('</');
      bufferName();
      this.buffer('>');
    }
    this.indents--;
  },

  /**
   * Visit `filter`, throwing when the filter does not exist.
   *
   * @param {Filter} filter
   * @api public
   */

  visitFilter: function(filter){
    var text = filter.block.nodes.map(
      function(node){ return node.val; }
    ).join('\n');
    filter.attrs = filter.attrs || {};
    filter.attrs.filename = this.options.filename;
    this.buffer(filters(filter.name, text, filter.attrs), true);
  },

  /**
   * Visit `text` node.
   *
   * @param {Text} text
   * @api public
   */

  visitText: function(text){
    this.buffer(text.val, true);
  },

  /**
   * Visit a `comment`, only buffering when the buffer flag is set.
   *
   * @param {Comment} comment
   * @api public
   */

  visitComment: function(comment){
    if (!comment.buffer) return;
    if (this.pp) this.prettyIndent(1, true);
    this.buffer('<!--' + comment.val + '-->');
  },

  /**
   * Visit a `BlockComment`.
   *
   * @param {Comment} comment
   * @api public
   */

  visitBlockComment: function(comment){
    if (!comment.buffer) return;
    if (0 == comment.val.trim().indexOf('if')) {
      this.buffer('<!--[' + comment.val.trim() + ']>');
      this.visit(comment.block);
      this.buffer('<![endif]-->');
    } else {
      this.buffer('<!--' + comment.val);
      this.visit(comment.block);
      this.buffer('-->');
    }
  },

  /**
   * Visit `code`, respecting buffer / escape flags.
   * If the code is followed by a block, wrap it in
   * a self-calling function.
   *
   * @param {Code} code
   * @api public
   */

  visitCode: function(code){
    // Wrap code blocks with {}.
    // we only wrap unbuffered code blocks ATM
    // since they are usually flow control

    // Buffer code
    if (code.buffer) {
      var val = code.val.trimLeft();
      val = 'null == (jade.interp = '+val+') ? "" : jade.interp';
      if (code.escape) val = 'jade.escape(' + val + ')';
      this.bufferExpression(val);
    } else {
      this.buf.push(code.val);
    }

    // Block support
    if (code.block) {
      if (!code.buffer) this.buf.push('{');
      this.visit(code.block);
      if (!code.buffer) this.buf.push('}');
    }
  },

  /**
   * Visit `each` block.
   *
   * @param {Each} each
   * @api public
   */

  visitEach: function(each){
    this.buf.push(''
      + '// iterate ' + each.obj + '\n'
      + ';(function(){\n'
      + '  var $$obj = ' + each.obj + ';\n'
      + '  if (\'number\' == typeof $$obj.length) {\n');

    if (each.alternative) {
      this.buf.push('  if ($$obj.length) {');
    }

    this.buf.push(''
      + '    for (var ' + each.key + ' = 0, $$l = $$obj.length; ' + each.key + ' < $$l; ' + each.key + '++) {\n'
      + '      var ' + each.val + ' = $$obj[' + each.key + '];\n');

    this.visit(each.block);

    this.buf.push('    }\n');

    if (each.alternative) {
      this.buf.push('  } else {');
      this.visit(each.alternative);
      this.buf.push('  }');
    }

    this.buf.push(''
      + '  } else {\n'
      + '    var $$l = 0;\n'
      + '    for (var ' + each.key + ' in $$obj) {\n'
      + '      $$l++;'
       + '      if ($$obj.hasOwnProperty(' + each.key + ')){'
      + '      var ' + each.val + ' = $$obj[' + each.key + '];\n');

    this.visit(each.block);

    this.buf.push('      }\n');

    this.buf.push('    }\n');
    if (each.alternative) {
      this.buf.push('    if ($$l === 0) {');
      this.visit(each.alternative);
      this.buf.push('    }');
    }
    this.buf.push('  }\n}).call(this);\n');
  },

  /**
   * Visit `attrs`.
   *
   * @param {Array} attrs
   * @api public
   */

  visitAttributes: function(attrs){
    var val = this.attrs(attrs);
    if (val.inherits) {
      this.bufferExpression("jade.attrs(jade.merge({ " + val.buf +
          " }, attributes), jade.merge(" + val.escaped + ", escaped, true))");
    } else if (val.constant) {
      eval('var buf={' + val.buf + '};');
      this.buffer(runtime.attrs(buf, JSON.parse(val.escaped)));
    } else {
      this.bufferExpression("jade.attrs({ " + val.buf + " }, " + val.escaped + ")");
    }
  },

  /**
   * Compile attributes.
   */

  attrs: function(attrs){
    var buf = []
      , classes = []
      , escaped = {}
      , constant = attrs.every(function(attr){ return isConstant(attr.val) })
      , inherits = false;

    if (this.terse) buf.push('terse: true');

    attrs.forEach(function(attr){
      if (attr.name == 'attributes') return inherits = true;
      escaped[attr.name] = attr.escaped;
      if (attr.name == 'class') {
        classes.push('(' + attr.val + ')');
      } else {
        var pair = "'" + attr.name + "':(" + attr.val + ')';
        buf.push(pair);
      }
    });

    if (classes.length) {
      classes = classes.join(" + ' ' + ");
      buf.push('"class": ' + classes);
    }

    return {
      buf: buf.join(', '),
      escaped: JSON.stringify(escaped),
      inherits: inherits,
      constant: constant
    };
  }
};

/**
 * Check if expression can be evaluated to a constant
 *
 * @param {String} expression
 * @return {Boolean}
 * @api private
 */

function isConstant(val){
  // Check strings/literals
  if (/^ *("([^"\\]*(\\.[^"\\]*)*)"|'([^'\\]*(\\.[^'\\]*)*)'|true|false|null|undefined) *$/i.test(val))
    return true;

  // Check numbers
  if (!isNaN(Number(val)))
    return true;

  // Check arrays
  var matches;
  if (matches = /^ *\[(.*)\] *$/.exec(val))
    return matches[1].split(',').every(isConstant);

  return false;
}

/***/ },
/* 18 */
/***/ function(module, exports) {


/*!
 * Jade - inline tags
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

module.exports = [
    'a'
  , 'abbr'
  , 'acronym'
  , 'b'
  , 'br'
  , 'code'
  , 'em'
  , 'font'
  , 'i'
  , 'img'
  , 'ins'
  , 'kbd'
  , 'map'
  , 'samp'
  , 'small'
  , 'span'
  , 'strong'
  , 'sub'
  , 'sup'
];

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {


/*!
 * Jade - nodes - BlockComment
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Node = __webpack_require__(0);

/**
 * Initialize a `BlockComment` with the given `block`.
 *
 * @param {String} val
 * @param {Block} block
 * @param {Boolean} buffer
 * @api public
 */

var BlockComment = module.exports = function BlockComment(val, block, buffer) {
  this.block = block;
  this.val = val;
  this.buffer = buffer;
};

/**
 * Inherit from `Node`.
 */

BlockComment.prototype.__proto__ = Node.prototype;

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {


/*!
 * Jade - nodes - Case
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Node = __webpack_require__(0);

/**
 * Initialize a new `Case` with `expr`.
 *
 * @param {String} expr
 * @api public
 */

var Case = exports = module.exports = function Case(expr, block){
  this.expr = expr;
  this.block = block;
};

/**
 * Inherit from `Node`.
 */

Case.prototype.__proto__ = Node.prototype;

var When = exports.When = function When(expr, block){
  this.expr = expr;
  this.block = block;
  this.debug = false;
};

/**
 * Inherit from `Node`.
 */

When.prototype.__proto__ = Node.prototype;



/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {


/*!
 * Jade - nodes - Code
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Node = __webpack_require__(0);

/**
 * Initialize a `Code` node with the given code `val`.
 * Code may also be optionally buffered and escaped.
 *
 * @param {String} val
 * @param {Boolean} buffer
 * @param {Boolean} escape
 * @api public
 */

var Code = module.exports = function Code(val, buffer, escape) {
  this.val = val;
  this.buffer = buffer;
  this.escape = escape;
  if (val.match(/^ *else/)) this.debug = false;
};

/**
 * Inherit from `Node`.
 */

Code.prototype.__proto__ = Node.prototype;

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {


/*!
 * Jade - nodes - Comment
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Node = __webpack_require__(0);

/**
 * Initialize a `Comment` with the given `val`, optionally `buffer`,
 * otherwise the comment may render in the output.
 *
 * @param {String} val
 * @param {Boolean} buffer
 * @api public
 */

var Comment = module.exports = function Comment(val, buffer) {
  this.val = val;
  this.buffer = buffer;
};

/**
 * Inherit from `Node`.
 */

Comment.prototype.__proto__ = Node.prototype;

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {


/*!
 * Jade - nodes - Doctype
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Node = __webpack_require__(0);

/**
 * Initialize a `Doctype` with the given `val`. 
 *
 * @param {String} val
 * @api public
 */

var Doctype = module.exports = function Doctype(val) {
  this.val = val;
};

/**
 * Inherit from `Node`.
 */

Doctype.prototype.__proto__ = Node.prototype;

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {


/*!
 * Jade - nodes - Each
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Node = __webpack_require__(0);

/**
 * Initialize an `Each` node, representing iteration
 *
 * @param {String} obj
 * @param {String} val
 * @param {String} key
 * @param {Block} block
 * @api public
 */

var Each = module.exports = function Each(obj, val, key, block) {
  this.obj = obj;
  this.val = val;
  this.key = key;
  this.block = block;
};

/**
 * Inherit from `Node`.
 */

Each.prototype.__proto__ = Node.prototype;

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {


/*!
 * Jade - nodes - Filter
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Node = __webpack_require__(0)
  , Block = __webpack_require__(3);

/**
 * Initialize a `Filter` node with the given
 * filter `name` and `block`.
 *
 * @param {String} name
 * @param {Block|Node} block
 * @api public
 */

var Filter = module.exports = function Filter(name, block, attrs) {
  this.name = name;
  this.block = block;
  this.attrs = attrs;
};

/**
 * Inherit from `Node`.
 */

Filter.prototype.__proto__ = Node.prototype;

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {


/*!
 * Jade - nodes - Literal
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Node = __webpack_require__(0);

/**
 * Initialize a `Literal` node with the given `str.
 *
 * @param {String} str
 * @api public
 */

var Literal = module.exports = function Literal(str) {
  this.str = str;
};

/**
 * Inherit from `Node`.
 */

Literal.prototype.__proto__ = Node.prototype;


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {


/*!
 * Jade - nodes - Mixin
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Attrs = __webpack_require__(10);

/**
 * Initialize a new `Mixin` with `name` and `block`.
 *
 * @param {String} name
 * @param {String} args
 * @param {Block} block
 * @api public
 */

var Mixin = module.exports = function Mixin(name, args, block, call){
  this.name = name;
  this.args = args;
  this.block = block;
  this.attrs = [];
  this.call = call;
};

/**
 * Inherit from `Attrs`.
 */

Mixin.prototype.__proto__ = Attrs.prototype;



/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {


/*!
 * Jade - nodes - Tag
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Attrs = __webpack_require__(10),
    Block = __webpack_require__(3),
    inlineTags = __webpack_require__(18);

/**
 * Initialize a `Tag` node with the given tag `name` and optional `block`.
 *
 * @param {String} name
 * @param {Block} block
 * @api public
 */

var Tag = module.exports = function Tag(name, block) {
  this.name = name;
  this.attrs = [];
  this.block = block || new Block;
};

/**
 * Inherit from `Attrs`.
 */

Tag.prototype.__proto__ = Attrs.prototype;

/**
 * Clone this tag.
 *
 * @return {Tag}
 * @api private
 */

Tag.prototype.clone = function(){
  var clone = new Tag(this.name, this.block.clone());
  clone.line = this.line;
  clone.attrs = this.attrs;
  clone.textOnly = this.textOnly;
  return clone;
};

/**
 * Check if this tag is an inline tag.
 *
 * @return {Boolean}
 * @api private
 */

Tag.prototype.isInline = function(){
  return ~inlineTags.indexOf(this.name);
};

/**
 * Check if this tag's contents can be inlined.  Used for pretty printing.
 *
 * @return {Boolean}
 * @api private
 */

Tag.prototype.canInline = function(){
  var nodes = this.block.nodes;

  function isInline(node){
    // Recurse if the node is a block
    if (node.isBlock) return node.nodes.every(isInline);
    return node.isText || (node.isInline && node.isInline());
  }
  
  // Empty tag
  if (!nodes.length) return true;
  
  // Text-only or inline-only tag
  if (1 == nodes.length) return isInline(nodes[0]);
  
  // Multi-line inline-only tag
  if (this.block.nodes.every(isInline)) {
    for (var i = 1, len = nodes.length; i < len; ++i) {
      if (nodes[i-1].isText && nodes[i].isText)
        return false;
    }
    return true;
  }
  
  // Mixed tag
  return false;
};

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {


/*!
 * Jade - nodes - Text
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Node = __webpack_require__(0);

/**
 * Initialize a `Text` node with optional `line`.
 *
 * @param {String} line
 * @api public
 */

var Text = module.exports = function Text(line) {
  this.val = '';
  if ('string' == typeof line) this.val = line;
};

/**
 * Inherit from `Node`.
 */

Text.prototype.__proto__ = Node.prototype;

/**
 * Flag as text.
 */

Text.prototype.isText = true;

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

/*!
 * Jade - Parser
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Lexer = __webpack_require__(9)
  , nodes = __webpack_require__(6)
  , utils = __webpack_require__(4)
  , filters = __webpack_require__(5)
  , path = __webpack_require__(1)
  , extname = path.extname;

/**
 * Initialize `Parser` with the given input `str` and `filename`.
 *
 * @param {String} str
 * @param {String} filename
 * @param {Object} options
 * @api public
 */

var Parser = exports = module.exports = function Parser(str, filename, options){
  this.input = str;
  this.lexer = new Lexer(str, options);
  this.filename = filename;
  this.blocks = [];
  this.mixins = {};
  this.options = options;
  this.contexts = [this];
};

/**
 * Tags that may not contain tags.
 */

var textOnly = exports.textOnly = ['script', 'style'];

/**
 * Parser prototype.
 */

Parser.prototype = {

  /**
   * Push `parser` onto the context stack,
   * or pop and return a `Parser`.
   */

  context: function(parser){
    if (parser) {
      this.contexts.push(parser);
    } else {
      return this.contexts.pop();
    }
  },

  /**
   * Return the next token object.
   *
   * @return {Object}
   * @api private
   */

  advance: function(){
    return this.lexer.advance();
  },

  /**
   * Skip `n` tokens.
   *
   * @param {Number} n
   * @api private
   */

  skip: function(n){
    while (n--) this.advance();
  },

  /**
   * Single token lookahead.
   *
   * @return {Object}
   * @api private
   */

  peek: function() {
    return this.lookahead(1);
  },

  /**
   * Return lexer lineno.
   *
   * @return {Number}
   * @api private
   */

  line: function() {
    return this.lexer.lineno;
  },

  /**
   * `n` token lookahead.
   *
   * @param {Number} n
   * @return {Object}
   * @api private
   */

  lookahead: function(n){
    return this.lexer.lookahead(n);
  },

  /**
   * Parse input returning a string of js for evaluation.
   *
   * @return {String}
   * @api public
   */

  parse: function(){
    var block = new nodes.Block, parser;
    block.line = this.line();

    while ('eos' != this.peek().type) {
      if ('newline' == this.peek().type) {
        this.advance();
      } else {
        block.push(this.parseExpr());
      }
    }

    if (parser = this.extending) {
      this.context(parser);
      var ast = parser.parse();
      this.context();

      // hoist mixins
      for (var name in this.mixins)
        ast.unshift(this.mixins[name]);
      return ast;
    } else {
      this.handleBlocks();
    }

    return block;
  },

  /**
   * Handle blocks, appends and prepends. Must be called from must deep parser (which parses template that does not extends another template).
   * @api private
   */

  handleBlocks: function() {
    this.blocks.reverse();
    var blocksHash = {}; // blockName: block object
    for (var i in this.blocks) {
      if (!( ({}).hasOwnProperty.call(blocksHash, [this.blocks[i].name]) )) { // just safe call to blocksHash.hasOwnProperty
        blocksHash[this.blocks[i].name] = this.blocks[i];
      } else {
        switch (this.blocks[i].mode) {
          case 'append':
            blocksHash[this.blocks[i].name].nodes = blocksHash[this.blocks[i].name].nodes.concat(this.blocks[i].nodes);
            break;
          case 'prepend':
            blocksHash[this.blocks[i].name].nodes = this.blocks[i].nodes.concat(blocksHash[this.blocks[i].name].nodes);
            break;
          default:
            blocksHash[this.blocks[i].name].nodes = this.blocks[i].nodes;
        }
        this.blocks[i] = blocksHash[this.blocks[i].name];
      }
    }
  },

  /**
   * Expect the given type, or throw an exception.
   *
   * @param {String} type
   * @api private
   */

  expect: function(type){
    if (this.peek().type === type) {
      return this.advance();
    } else {
      throw new Error('expected "' + type + '", but got "' + this.peek().type + '"');
    }
  },

  /**
   * Accept the given `type`.
   *
   * @param {String} type
   * @api private
   */

  accept: function(type){
    if (this.peek().type === type) {
      return this.advance();
    }
  },

  /**
   *   tag
   * | doctype
   * | mixin
   * | include
   * | filter
   * | comment
   * | text
   * | each
   * | code
   * | yield
   * | id
   * | class
   * | interpolation
   */

  parseExpr: function(){
    switch (this.peek().type) {
      case 'tag':
        return this.parseTag();
      case 'mixin':
        return this.parseMixin();
      case 'block':
        return this.parseBlock();
      case 'case':
        return this.parseCase();
      case 'when':
        return this.parseWhen();
      case 'default':
        return this.parseDefault();
      case 'extends':
        return this.parseExtends();
      case 'include':
        return this.parseInclude();
      case 'doctype':
        return this.parseDoctype();
      case 'filter':
        return this.parseFilter();
      case 'comment':
        return this.parseComment();
      case 'text':
        return this.parseText();
      case 'each':
        return this.parseEach();
      case 'code':
        return this.parseCode();
      case 'call':
        return this.parseCall();
      case 'interpolation':
        return this.parseInterpolation();
      case 'yield':
        this.advance();
        var block = new nodes.Block;
        block.yield = true;
        return block;
      case 'id':
      case 'class':
        var tok = this.advance();
        this.lexer.defer(this.lexer.tok('tag', 'div'));
        this.lexer.defer(tok);
        return this.parseExpr();
      default:
        throw new Error('unexpected token "' + this.peek().type + '"');
    }
  },

  /**
   * Text
   */

  parseText: function(){
    var tok = this.expect('text');
    var node = new nodes.Text(tok.val);
    node.line = this.line();
    return node;
  },

  /**
   *   ':' expr
   * | block
   */

  parseBlockExpansion: function(){
    if (':' == this.peek().type) {
      this.advance();
      return new nodes.Block(this.parseExpr());
    } else {
      return this.block();
    }
  },

  /**
   * case
   */

  parseCase: function(){
    var val = this.expect('case').val;
    var node = new nodes.Case(val);
    node.line = this.line();
    node.block = this.block();
    return node;
  },

  /**
   * when
   */

  parseWhen: function(){
    var val = this.expect('when').val
    return new nodes.Case.When(val, this.parseBlockExpansion());
  },

  /**
   * default
   */

  parseDefault: function(){
    this.expect('default');
    return new nodes.Case.When('default', this.parseBlockExpansion());
  },

  /**
   * code
   */

  parseCode: function(){
    var tok = this.expect('code');
    var node = new nodes.Code(tok.val, tok.buffer, tok.escape);
    var block;
    var i = 1;
    node.line = this.line();
    while (this.lookahead(i) && 'newline' == this.lookahead(i).type) ++i;
    block = 'indent' == this.lookahead(i).type;
    if (block) {
      this.skip(i-1);
      node.block = this.block();
    }
    return node;
  },

  /**
   * comment
   */

  parseComment: function(){
    var tok = this.expect('comment');
    var node;

    if ('indent' == this.peek().type) {
      node = new nodes.BlockComment(tok.val, this.block(), tok.buffer);
    } else {
      node = new nodes.Comment(tok.val, tok.buffer);
    }

    node.line = this.line();
    return node;
  },

  /**
   * doctype
   */

  parseDoctype: function(){
    var tok = this.expect('doctype');
    var node = new nodes.Doctype(tok.val);
    node.line = this.line();
    return node;
  },

  /**
   * filter attrs? text-block
   */

  parseFilter: function(){
    var tok = this.expect('filter');
    var attrs = this.accept('attrs');
    var block;

    this.lexer.pipeless = true;
    block = this.parseTextBlock();
    this.lexer.pipeless = false;

    var node = new nodes.Filter(tok.val, block, attrs && attrs.attrs);
    node.line = this.line();
    return node;
  },

  /**
   * each block
   */

  parseEach: function(){
    var tok = this.expect('each');
    var node = new nodes.Each(tok.code, tok.val, tok.key);
    node.line = this.line();
    node.block = this.block();
    if (this.peek().type == 'code' && this.peek().val == 'else') {
      this.advance();
      node.alternative = this.block();
    }
    return node;
  },

  /**
   * Resolves a path relative to the template for use in
   * includes and extends
   *
   * @param {String}  path
   * @param {String}  purpose  Used in error messages.
   * @return {String}
   * @api private
   */

  resolvePath: function (path, purpose) {
    var p = __webpack_require__(1);
    var dirname = p.dirname;
    var basename = p.basename;
    var join = p.join;

    if (path[0] !== '/' && !this.filename)
      throw new Error('the "filename" option is required to use "' + purpose + '" with "relative" paths');

    if (path[0] === '/' && !this.options.basedir) 
      throw new Error('the "basedir" option is required to use "' + purpose + '" with "absolute" paths');

    path = join(path[0] === '/' ? this.options.basedir : dirname(this.filename), path);

    if (basename(path).indexOf('.') === -1) path += '.jade';

    return path;
  },

  /**
   * 'extends' name
   */

  parseExtends: function(){
    var fs = __webpack_require__(2);

    var path = this.resolvePath(this.expect('extends').val.trim(), 'extends');
    if ('.jade' != path.substr(-5)) path += '.jade';

    var str = fs.readFileSync(path, 'utf8');
    var parser = new Parser(str, path, this.options);

    parser.blocks = this.blocks.reverse();
    parser.contexts = this.contexts;
    this.extending = parser;

    // TODO: null node
    return new nodes.Literal('');
  },

  /**
   * 'block' name block
   */

  parseBlock: function(){
    var block = this.expect('block');
    var mode = block.mode;
    var name = block.val.trim();

    block = 'indent' == this.peek().type
      ? this.block()
      : new nodes.Block(new nodes.Literal(''));

    block.mode = mode;
    block.name = name;
    this.blocks.push(block);
    return block;
  },

  /**
   * include block?
   */

  parseInclude: function(){
    var fs = __webpack_require__(2);

    var path = this.resolvePath(this.expect('include').val.trim(), 'include');

    // non-jade
    if ('.jade' != path.substr(-5)) {
      var str = fs.readFileSync(path, 'utf8').replace(/\r/g, '');
      var ext = extname(path).slice(1);
      if (filters.exists(ext)) str = filters(ext, str, { filename: path });
      return new nodes.Literal(str);
    }

    var str = fs.readFileSync(path, 'utf8');
    var parser = new Parser(str, path, this.options);
    parser.blocks = utils.merge([], this.blocks);

    parser.mixins = this.mixins;

    this.context(parser);
    var ast = parser.parse();
    this.context();
    ast.filename = path;

    if ('indent' == this.peek().type) {
      ast.includeBlock().push(this.block());
    }

    return ast;
  },

  /**
   * call ident block
   */

  parseCall: function(){
    var tok = this.expect('call');
    var name = tok.val;
    var args = tok.args;
    var mixin = new nodes.Mixin(name, args, new nodes.Block, true);

    this.tag(mixin);
    if (mixin.block.isEmpty()) mixin.block = null;
    return mixin;
  },

  /**
   * mixin block
   */

  parseMixin: function(){
    var tok = this.expect('mixin');
    var name = tok.val;
    var args = tok.args;
    var mixin;

    // definition
    if ('indent' == this.peek().type) {
      mixin = new nodes.Mixin(name, args, this.block(), false);
      this.mixins[name] = mixin;
      return mixin;
    // call
    } else {
      return new nodes.Mixin(name, args, null, true);
    }
  },

  /**
   * indent (text | newline)* outdent
   */

  parseTextBlock: function(){
    var block = new nodes.Block;
    block.line = this.line();
    var spaces = this.expect('indent').val;
    if (null == this._spaces) this._spaces = spaces;
    var indent = Array(spaces - this._spaces + 1).join(' ');
    while ('outdent' != this.peek().type) {
      switch (this.peek().type) {
        case 'newline':
          this.advance();
          break;
        case 'indent':
          this.parseTextBlock().nodes.forEach(function(node){
            block.push(node);
          });
          break;
        default:
          var text = new nodes.Text(indent + this.advance().val);
          text.line = this.line();
          block.push(text);
      }
    }

    if (spaces == this._spaces) this._spaces = null;
    this.expect('outdent');
    return block;
  },

  /**
   * indent expr* outdent
   */

  block: function(){
    var block = new nodes.Block;
    block.line = this.line();
    this.expect('indent');
    while ('outdent' != this.peek().type) {
      if ('newline' == this.peek().type) {
        this.advance();
      } else {
        block.push(this.parseExpr());
      }
    }
    this.expect('outdent');
    return block;
  },

  /**
   * interpolation (attrs | class | id)* (text | code | ':')? newline* block?
   */

  parseInterpolation: function(){
    var tok = this.advance();
    var tag = new nodes.Tag(tok.val);
    tag.buffer = true;
    return this.tag(tag);
  },

  /**
   * tag (attrs | class | id)* (text | code | ':')? newline* block?
   */

  parseTag: function(){
    // ast-filter look-ahead
    var i = 2;
    if ('attrs' == this.lookahead(i).type) ++i;

    var tok = this.advance();
    var tag = new nodes.Tag(tok.val);

    tag.selfClosing = tok.selfClosing;

    return this.tag(tag);
  },

  /**
   * Parse tag.
   */

  tag: function(tag){
    var dot;

    tag.line = this.line();

    // (attrs | class | id)*
    out:
      while (true) {
        switch (this.peek().type) {
          case 'id':
          case 'class':
            var tok = this.advance();
            tag.setAttribute(tok.type, "'" + tok.val + "'");
            continue;
          case 'attrs':
            var tok = this.advance()
              , obj = tok.attrs
              , escaped = tok.escaped
              , names = Object.keys(obj);

            if (tok.selfClosing) tag.selfClosing = true;

            for (var i = 0, len = names.length; i < len; ++i) {
              var name = names[i]
                , val = obj[name];
              tag.setAttribute(name, val, escaped[name]);
            }
            continue;
          default:
            break out;
        }
      }

    // check immediate '.'
    if ('.' == this.peek().val) {
      dot = tag.textOnly = true;
      this.advance();
    }

    // (text | code | ':')?
    switch (this.peek().type) {
      case 'text':
        tag.block.push(this.parseText());
        break;
      case 'code':
        tag.code = this.parseCode();
        break;
      case ':':
        this.advance();
        tag.block = new nodes.Block;
        tag.block.push(this.parseExpr());
        break;
    }

    // newline*
    while ('newline' == this.peek().type) this.advance();

    tag.textOnly = tag.textOnly || ~textOnly.indexOf(tag.name);

    // script special-case
    if ('script' == tag.name) {
      var type = tag.getAttribute('type');
      if (!dot && type && 'text/javascript' != type.replace(/^['"]|['"]$/g, '')) {
        tag.textOnly = false;
      }
    }

    // block?
    if ('indent' == this.peek().type) {
      if (tag.textOnly) {
        this.lexer.pipeless = true;
        tag.block = this.parseTextBlock();
        this.lexer.pipeless = false;
      } else {
        var block = this.block();
        if (tag.block) {
          for (var i = 0, len = block.nodes.length; i < len; ++i) {
            tag.block.push(block.nodes[i]);
          }
        } else {
          tag.block = block;
        }
      }
    }

    return tag;
  }
};


/***/ },
/* 31 */
/***/ function(module, exports) {


module.exports = function(css){

  /**
   * Parse stylesheet.
   */

  function stylesheet() {
    return { stylesheet: { rules: rules() }};
  }

  /**
   * Opening brace.
   */

  function open() {
    return match(/^{\s*/);
  }

  /**
   * Closing brace.
   */

  function close() {
    return match(/^}\s*/);
  }

  /**
   * Parse ruleset.
   */

  function rules() {
    var node;
    var rules = [];
    whitespace();
    comments();
    while (css[0] != '}' && (node = atrule() || rule())) {
      comments();
      rules.push(node);
    }
    return rules;
  }

  /**
   * Match `re` and return captures.
   */

  function match(re) {
    var m = re.exec(css);
    if (!m) return;
    css = css.slice(m[0].length);
    return m;
  }

  /**
   * Parse whitespace.
   */

  function whitespace() {
    match(/^\s*/);
  }

  /**
   * Parse comments;
   */

  function comments() {
    while (comment()) ;
  }

  /**
   * Parse comment.
   */

  function comment() {
    if ('/' == css[0] && '*' == css[1]) {
      var i = 2;
      while ('*' != css[i] || '/' != css[i + 1]) ++i;
      i += 2;
      css = css.slice(i);
      whitespace();
      return true;
    }
  }

  /**
   * Parse selector.
   */

  function selector() {
    var m = match(/^([^{]+)/);
    if (!m) return;
    return m[0].trim().split(/\s*,\s*/);
  }

  /**
   * Parse declaration.
   */

  function declaration() {
    // prop
    var prop = match(/^(\*?[-\w]+)\s*/);
    if (!prop) return;
    prop = prop[0];

    // :
    if (!match(/^:\s*/)) return;

    // val
    var val = match(/^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^\)]*?\)|[^};])+)\s*/);
    if (!val) return;
    val = val[0].trim();

    // ;
    match(/^[;\s]*/);

    return { property: prop, value: val };
  }

  /**
   * Parse keyframe.
   */

  function keyframe() {
    var m;
    var vals = [];

    while (m = match(/^(from|to|\d+%|\.\d+%|\d+\.\d+%)\s*/)) {
      vals.push(m[1]);
      match(/^,\s*/);
    }

    if (!vals.length) return;

    return {
      values: vals,
      declarations: declarations()
    };
  }

  /**
   * Parse keyframes.
   */

  function keyframes() {
    var m = match(/^@([-\w]+)?keyframes */);
    if (!m) return;
    var vendor = m[1];

    // identifier
    var m = match(/^([-\w]+)\s*/);
    if (!m) return;
    var name = m[1];

    if (!open()) return;
    comments();

    var frame;
    var frames = [];
    while (frame = keyframe()) {
      frames.push(frame);
      comments();
    }

    if (!close()) return;

    return {
      name: name,
      vendor: vendor,
      keyframes: frames
    };
  }

  /**
   * Parse media.
   */

  function media() {
    var m = match(/^@media *([^{]+)/);
    if (!m) return;
    var media = m[1].trim();

    if (!open()) return;
    comments();

    var style = rules();

    if (!close()) return;

    return { media: media, rules: style };
  }

  /**
   * Parse import
   */

  function atimport() {
    return _atrule('import')
  }

  /**
   * Parse charset
   */

  function atcharset() {
    return _atrule('charset');
  }

  /**
   * Parse non-block at-rules
   */

  function _atrule(name) {
    var m = match(new RegExp('^@' + name + ' *([^;\\n]+);\\s*'));
    if (!m) return;
    var ret = {}
    ret[name] = m[1].trim();
    return ret;
  }

  /**
   * Parse declarations.
   */

  function declarations() {
    var decls = [];

    if (!open()) return;
    comments();
  
    // declarations
    var decl;
    while (decl = declaration()) {
      decls.push(decl);
      comments();
    }
  
    if (!close()) return;
    return decls;
  }

  /**
   * Parse at rule.
   */
   
  function atrule() {
    return keyframes()
      || media()
      || atimport()
      || atcharset();
  }

  /**
   * Parse rule.
   */
  
  function rule() {
    var sel = selector();
    if (!sel) return;
    comments();
    return { selectors: sel, declarations: declarations() };
  }
  
  return stylesheet();
};


/***/ },
/* 32 */
/***/ function(module, exports) {


/**
 * Stringfy the given AST `node`.
 *
 * @param {Object} node
 * @param {Object} options
 * @return {String}
 * @api public
 */

module.exports = function(node, options){
  return new Compiler(options).compile(node);
};

/**
 * Initialize a new `Compiler`.
 */

function Compiler(options) {
  options = options || {};
  this.compress = options.compress;
  this.indentation = options.indent;
}

/**
 * Compile `node`.
 */

Compiler.prototype.compile = function(node){
  return node.stylesheet.rules.map(this.visit, this)
    .join(this.compress ? '' : '\n\n');
};

/**
 * Visit `node`.
 */

Compiler.prototype.visit = function(node){
  if (node.charset) return this.charset(node);
  if (node.keyframes) return this.keyframes(node);
  if (node.media) return this.media(node);
  if (node.import) return this.import(node);
  return this.rule(node);
};

/**
 * Visit import node.
 */

Compiler.prototype.import = function(node){
  return '@import ' + node.import + ';';
};

/**
 * Visit media node.
 */

Compiler.prototype.media = function(node){
  if (this.compress) {
    return '@media '
      + node.media
      + '{'
      + node.rules.map(this.visit, this).join('')
      + '}';
  }

  return '@media '
    + node.media
    + ' {\n'
    + this.indent(1)
    + node.rules.map(this.visit, this).join('\n\n')
    + this.indent(-1)
    + '\n}';
};

/**
 * Visit charset node.
 */

Compiler.prototype.charset = function(node){
  if (this.compress) {
    return '@charset ' + node.charset + ';';
  }

  return '@charset ' + node.charset + ';\n';
};

/**
 * Visit keyframes node.
 */

Compiler.prototype.keyframes = function(node){
  if (this.compress) {
    return '@'
      + (node.vendor || '')
      + 'keyframes '
      + node.name
      + '{'
      + node.keyframes.map(this.keyframe, this).join('')
      + '}';
  }

  return '@'
    + (node.vendor || '')
    + 'keyframes '
    + node.name
    + ' {\n'
    + this.indent(1)
    + node.keyframes.map(this.keyframe, this).join('\n')
    + this.indent(-1)
    + '}';
};

/**
 * Visit keyframe node.
 */

Compiler.prototype.keyframe = function(node){
  if (this.compress) {
    return node.values.join(',')
      + '{'
      + node.declarations.map(this.declaration, this).join(';')
      + '}';
  }

  return this.indent()
    + node.values.join(', ')
    + ' {\n'
    + this.indent(1)
    + node.declarations.map(this.declaration, this).join(';\n')
    + this.indent(-1)
    + '\n' + this.indent() + '}\n';
};

/**
 * Visit rule node.
 */

Compiler.prototype.rule = function(node){
  var indent = this.indent();

  if (this.compress) {
    return node.selectors.join(',')
      + '{'
      + node.declarations.map(this.declaration, this).join(';')
      + '}';
  }

  return node.selectors.map(function(s){ return indent + s }).join(',\n')
    + ' {\n'
    + this.indent(1)
    + node.declarations.map(this.declaration, this).join(';\n')
    + this.indent(-1)
    + '\n' + this.indent() + '}';
};

/**
 * Visit declaration node.
 */

Compiler.prototype.declaration = function(node){
  if (this.compress) {
    return node.property + ':' + node.value;
  }

  return this.indent() + node.property + ': ' + node.value;
};

/**
 * Increase, decrease or return current indentation.
 */

Compiler.prototype.indent = function(level) {
  this.level = this.level || 1;

  if (null != level) {
    this.level += level;
    return '';
  }

  return Array(this.level).join(this.indentation || '  ');
};


/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {


exports.parse = __webpack_require__(31);
exports.stringify = __webpack_require__(32);


/***/ },
/* 34 */
/***/ function(module, exports) {

module.exports = isPromise;

function isPromise(obj) {
  return obj && typeof obj.then === 'function';
}

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {var isPromise = __webpack_require__(34)

var nextTick
if (typeof setImediate === 'function') nextTick = setImediate
else if (typeof process === 'object' && process && process.nextTick) nextTick = process.nextTick
else nextTick = function (cb) { setTimeout(cb, 0) }

var extensions = []

module.exports = Promise
function Promise(fn) {
  if (!(this instanceof Promise)) {
    return fn ? new Promise(fn) : defer()
  }
  if (typeof fn !== 'function') {
    throw new TypeError('fn is not a function')
  }

  var state = {
    isResolved: false,
    isSettled: false,
    isFulfilled: false,
    value: null,
    waiting: [],
    running: false
  }

  function _resolve(val) {
    resolve(state, val);
  }
  function _reject(err) {
    reject(state, err);
  }
  this.then = function _then(onFulfilled, onRejected) {
    return then(state, onFulfilled, onRejected);
  }

  _resolve.fulfill = deprecate(_resolve, 'resolver.fulfill(x)', 'resolve(x)')
  _resolve.reject = deprecate(_reject, 'resolver.reject', 'reject(x)')

  try {
    fn(_resolve, _reject)
  } catch (ex) {
    _reject(ex)
  }
}

function resolve(promiseState, value) {
  if (promiseState.isResolved) return
  if (isPromise(value)) {
    assimilate(promiseState, value)
  } else {
    settle(promiseState, true, value)
  }
}

function reject(promiseState, reason) {
  if (promiseState.isResolved) return
  settle(promiseState, false, reason)
}

function then(promiseState, onFulfilled, onRejected) {
  return new Promise(function (resolve, reject) {
    function done(next, skipTimeout) {
      var callback = promiseState.isFulfilled ? onFulfilled : onRejected
      if (typeof callback === 'function') {
        function timeoutDone() {
          var val
          try {
            val = callback(promiseState.value)
          } catch (ex) {
            reject(ex)
            return next(true)
          }
          resolve(val)
          next(true)
        }
        if (skipTimeout) timeoutDone()
        else nextTick(timeoutDone)
      } else if (promiseState.isFulfilled) {
        resolve(promiseState.value)
        next(skipTimeout)
      } else {
        reject(promiseState.value)
        next(skipTimeout)
      }
    }
    promiseState.waiting.push(done)
    if (promiseState.isSettled && !promiseState.running) processQueue(promiseState)
  })
}

function processQueue(promiseState) {
  function next(skipTimeout) {
    if (promiseState.waiting.length) {
      promiseState.running = true
      promiseState.waiting.shift()(next, skipTimeout)
    } else {
      promiseState.running = false
    }
  }
  next(false)
}

function settle(promiseState, isFulfilled, value) {
  if (promiseState.isSettled) return

  promiseState.isResolved = promiseState.isSettled = true
  promiseState.value = value
  promiseState.isFulfilled = isFulfilled

  processQueue(promiseState)
}

function assimilate(promiseState, thenable) {
  try {
    promiseState.isResolved = true
    thenable.then(function (res) {
      if (isPromise(res)) {
        assimilate(promiseState, res)
      } else {
        settle(promiseState, true, res)
      }
    }, function (err) {
      settle(promiseState, false, err)
    })
  } catch (ex) {
    settle(promiseState, false, ex)
  }
}

Promise.use = function (extension) {
  extensions.push(extension)
}


function deprecate(method, name, alternative) {
  return function () {
    var err = new Error(name + ' is deprecated use ' + alternative)
    if (typeof console !== 'undefined' && console && typeof console.warn === 'function') {
      console.warn(name + ' is deprecated use ' + alternative)
      if (err.stack) console.warn(err.stack)
    } else {
      nextTick(function () {
        throw err
      })
    }
    method.apply(this, arguments)
  }
}
function defer() {
  var err = new Error('promise.defer() is deprecated')
  if (typeof console !== 'undefined' && console && typeof console.warn === 'function') {
    console.warn('promise.defer() is deprecated')
    if (err.stack) console.warn(err.stack)
  } else {
    nextTick(function () {
      throw err
    })
  }
  var resolver
  var promise = new Promise(function (res) { resolver = res })
  return {resolver: resolver, promise: promise}
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {var Promise = __webpack_require__(35);
var fs = __webpack_require__(2);
var path = __webpack_require__(1);
var normalize = path.normalize;


Promise.prototype.nodeify = function (cb) {
  if (typeof cb === 'function') {
    this.then(function (res) { process.nextTick(function () { cb(null, res); }); },
              function (err) { process.nextTick(function () { cb(err); }); });
    return undefined;
  } else {
    return this;
  }
}

var minifiers = {};

module.exports = Transformer;
function Transformer(obj) {
  this.name = obj.name;
  this.engines = obj.engines;
  this.isBinary = obj.isBinary || false;
  this.isMinifier = obj.isMinifier || false;
  this.outputFormat = obj.outputFormat;
  this._cache = {};
  if (typeof obj.async === 'function') {
    this._renderAsync = obj.async;
    this.sudoSync = obj.sudoSync || false;
  }
  if (typeof obj.sync === 'function') {
    this._renderSync = obj.sync;
    this.sync = true;
  } else {
    this.sync = obj.sudoSync || false;
  }

  if (this.isMinifier)
    minifiers[this.outputFormat] = this;
  else {
    var minifier = minifiers[this.outputFormat];
    if (minifier) {
      this.minify = function(str, options) {
        if (options && options.minify)
          return minifier.renderSync(str, typeof options.minify === 'object' && options.minify || {});
        return str;
      }
    }
  }
}

Transformer.prototype.cache = function (options, data) {
  if (options.cache && options.filename) {
    if (data) return this.cache[options.filename] = data;
    else return this.cache[options.filename];
  } else {
    return data;
  }
};
Transformer.prototype.loadModule = function () {
  if (this.engine) return this.engine;
  for (var i = 0; i < this.engines.length; i++) {
    try {
      var res = this.engines[i] === '.' ? null : (this.engine = !(function webpackMissingModule() { var e = new Error("Cannot find module \".\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
      this.engineName = this.engines[i];
      return res;
    } catch (ex) {
      if (this.engines.length === 1) {
        throw ex;
      }
    }
  }
  throw new Error('In order to apply the transform ' + this.name + ' you must install one of ' + this.engines.map(function (e) { return '"' + e + '"'; }).join());
};
Transformer.prototype.minify = function(str, options) {
  return str;
}
Transformer.prototype.renderSync = function (str, options) {
  options = options || {};
  options = clone(options);
  this.loadModule();
  if (this._renderSync) {
    return this.minify(this._renderSync((this.isBinary ? str : fixString(str)), options), options);
  } else if (this.sudoSync) {
    options.sudoSync = true;
    var res, err;
    this._renderAsync((this.isBinary ? str : fixString(str)), options, function (e, val) {
      if (e) err = e;
      else res = val;
    });
    if (err) throw err;
    else if (res != undefined) return this.minify(res, options);
    else if (typeof this.sudoSync === 'string') throw new Error(this.sudoSync.replace(/FILENAME/g, options.filename || ''));
    else throw new Error('There was a problem transforming ' + (options.filename || '') + ' syncronously using ' + this.name);
  } else {
    throw new Error(this.name + ' does not support transforming syncronously.');
  }
};
Transformer.prototype.render = function (str, options, cb) {
  options = options || {};
  var self = this;
  return new Promise(function (resolve, reject) {
    self.loadModule();
    if (self._renderAsync) {
      self._renderAsync((self.isBinary ? str : fixString(str)), clone(options), function (err, val) {
        if (err) reject(err);
        else resolve(self.minify(val, options));
      })
    } else {
      resolve(self.renderSync(str, options));
    }
  })
  .nodeify(cb);
};
Transformer.prototype.renderFile = function (path, options, cb) {
  options = options || {};
  var self = this;
  return new Promise(function (resolve, reject) {
    options.filename = (path = normalize(path));
    if (self._cache[path])
      resolve(null);
    else
      fs.readFile(path, function (err, data) {
        if (err) reject(err);
        else resolve(data);
      })
  })
  .then(function (str) {
    return self.render(str, options);
  })
  .nodeify(cb);
};
Transformer.prototype.renderFileSync = function (path, options) {
  options = options || {};
  options.filename = (path = normalize(path));
  return this.renderSync((this._cache[path] ? null : fs.readFileSync(path)), options);
};
function fixString(str) {
  if (str == null) return str;
  //convert buffer to string
  str = str.toString();
  // Strip UTF-8 BOM if it exists
  str = (0xFEFF == str.charCodeAt(0) 
    ? str.substring(1)
    : str);
  //remove `\r` added by windows
  return str.replace(/\r/g, '');
}

function clone(obj) {
  if (Array.isArray(obj)) {
    return obj.map(clone);
  } else if (obj && typeof obj === 'object') {
    var res = {};
    for (var key in obj) {
      res[key] = clone(obj[key]);
    }
    return res;
  } else {
    return obj;
  }
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var dirname = __webpack_require__(1).dirname;
var Transformer = __webpack_require__(36);

/**
 * minifiers must be first in order to be incorporated inside instances of respective output formats
 */
var uglifyJS = __webpack_require__(16);
exports.uglify = exports.uglifyJS = exports['uglify-js'] = new Transformer({
  name: 'uglify-js',
  engines: ['.'],
  outputFormat: 'js',
  isMinifier: true,
  sync: function (str, options) {
    options.fromString = true;
    return this.cache(options) || this.cache(options, uglifyJS.minify(str, options).code);
  }
});
var uglifyCSS = __webpack_require__(33);
exports.uglifyCSS = exports['uglify-css'] = new Transformer({
  name: 'uglify-css',
  engines: ['.'],
  outputFormat: 'css',
  isMinifier: true,
  sync: function (str, options) {
    options.compress = options.compress != false && options.beautify != true;
    return this.cache(options) || this.cache(options, uglifyCSS.stringify(uglifyCSS.parse(str), options));
  }
});

exports.uglifyJSON = exports['uglify-json'] = new Transformer({
  name: 'uglify-json',
  engines: ['.'],
  outputFormat: 'json',
  isMinifier: true,
  sync: function (str, options) {
    return JSON.stringify(JSON.parse(str), null, options.beautify);
  }
});


/**
 * Syncronous Templating Languages
 */

function sync(str, options) {
  var tmpl = this.cache(options) || this.cache(options, this.engine.compile(str, options));
  return tmpl(options);
}

exports.swig = new Transformer({
  name: 'swig',
  engines: ['swig'],
  outputFormat: 'xml',
  sync: sync
});

exports.atpl = new Transformer({
  name: 'atpl',
  engines: ['atpl'],
  outputFormat: 'xml',
  sync: function sync(str, options) {
    var tmpl = this.cache(options);
    if (!tmpl) {
      var cInfo = {cache: options.cache, filename: options.filename};
      if (options.filename) {
        delete options.filename; //atpl can't handle absolute windows file paths properly
      }
      tmpl = this.cache(cInfo, this.engine.compile(str, options));
    }
    return tmpl(options);
  }
});

exports.dot = new Transformer({
  name: 'dot',
  engines: ['dot'],
  outputFormat: 'xml',
  sync: function sync(str, options) {
    var tmpl = this.cache(options) || this.cache(options, this.engine.template(str));
    return tmpl(options);
  }
});

exports.liquor = new Transformer({
  name: 'liquor',
  engines: ['liquor'],
  outputFormat: 'xml',
  sync: sync
});

exports.ejs = new Transformer({
  name: 'ejs',
  engines: ['ejs'],
  outputFormat: 'xml',
  sync: sync
});

exports.eco = new Transformer({
  name: 'eco',
  engines: ['eco'],
  outputFormat: 'xml',
  sync: sync//N.B. eco's internal this.cache isn't quite right but this bypasses it
});

exports.jqtpl = new Transformer({
  name: 'jqtpl',
  engines: ['jqtpl'],
  outputFormat: 'xml',
  sync: function (str, options) {
    var engine = this.engine;
    var key = (options.cache && options.filename) ? options.filename : '@';
    engine.compile(str, key);
    var res = this.engine.render(key, options);
    if (!(options.cache && options.filename)) {
      delete engine.cache[key];
    }
    this.cache(options, true); // caching handled internally
    return res;
  }
});

exports.haml = new Transformer({
  name: 'haml',
  engines: ['hamljs'],
  outputFormat: 'xml',
  sync: sync
});

exports['haml-coffee'] = new Transformer({
  name: 'haml-coffee',
  engines: ['haml-coffee'],
  outputFormat: 'xml',
  sync: sync
});

exports.whiskers = new Transformer({
  name: 'whiskers',
  engines: ['whiskers'],
  outputFormat: 'xml',
  sync: sync
});

exports.hogan = new Transformer({
  name: 'hogan',
  engines: ['hogan.js'],
  outputFormat: 'xml',
  sync: function(str, options){
    var tmpl = this.cache(options) || this.cache(options, this.engine.compile(str, options));
    return tmpl.render(options, options.partials);
  }
});

exports.handlebars = new Transformer({
  name: 'handlebars',
  engines: ['handlebars'],
  outputFormat: 'xml',
  sync: function(str, options){
    for (var partial in options.partials) {
      this.engine.registerPartial(partial, options.partials[partial]);
    }
    var tmpl = this.cache(options) || this.cache(options, this.engine.compile(str, options));
    return tmpl(options);
  }
});

exports.underscore = new Transformer({
  name: 'underscore',
  engines: ['underscore'],
  outputFormat: 'xml',
  sync: function(str, options){
    var tmpl = this.cache(options) || this.cache(options, this.engine.template(str));
    return tmpl(options);
  }
});

exports.walrus = new Transformer({
  name: 'walrus',
  engines: ['walrus'],
  outputFormat: 'xml',
  sync: function(str, options){
    var tmpl = this.cache(options) || this.cache(options, this.engine.parse(str));
    return tmpl.compile(options);
  }
});

exports.mustache = new Transformer({
  name: 'mustache',
  engines: ['mustache'],
  outputFormat: 'xml',
  sync: function(str, options){
    var tmpl = this.cache(options) || this.cache(options, this.engine.compile(str));
    return tmpl(options, options.partials);
  }
});

exports.templayed = new Transformer({
  name: 'templayed',
  engines: ['templayed'],
  outputFormat: 'xml',
  sync: function(str, options){
    var tmpl = this.cache(options) || this.cache(options, this.engine(str));
    return tmpl(options);
  }
});

exports.plates = new Transformer({
  name: 'plates',
  engines: ['plates'],
  outputFormat: 'xml',
  sync: function(str, options){
    str = this.cache(options) || this.cache(options, str);
    return this.engine.bind(str, options, options.map);
  }
});

exports.mote = new Transformer({
  name: 'mote',
  engines: ['mote'],
  outputFormat: 'xml',
  sync: sync
});

exports.toffee = new Transformer({
  name: 'toffee',
  engines: ['toffee'],
  outputFormat: 'xml',
  sync: function (str, options) {
    var View = this.engine.view;
    var v = this.cache(options) || this.cache(options, new View(str, options));
    var res = v.run(options, __webpack_require__(39).createContext({}));
    if (res[0]) throw res[0];
    else return res[1];
  }
});

exports.coffeekup = exports.coffeecup = new Transformer({
  name: 'coffeecup',
  engines: ['coffeecup', 'coffeekup'],
  outputFormat: 'xml',
  sync: function (str, options) {
    var compiled = this.cache(options) || this.cache(options, this.engine.compile(str, options));
    return compiled(options);
  }
});

/**
 * Asyncronous Templating Languages
 */

exports.just = new Transformer({
  name: 'just',
  engines: ['just'],
  outputFormat: 'xml',
  sudoSync: true,
  async: function (str, options, cb) {
    var JUST = this.engine;
    var tmpl = this.cache(options) || this.cache(options, new JUST({ root: { page: str }}));
    tmpl.render('page', options, cb);
  }
});

exports.ect = new Transformer({
  name: 'ect',
  engines: ['ect'],
  outputFormat: 'xml',
  sudoSync: true, // Always runs syncronously
  async: function (str, options, cb) {
    var ECT = this.engine;
    var tmpl = this.cache(options) || this.cache(options, new ECT({ root: { page: str }}));
    tmpl.render('page', options, cb);
  }
});

exports.jade = new Transformer({
  name: 'jade',
  engines: ['jade', 'then-jade'],
  outputFormat: 'xml',
  sudoSync: 'The jade file FILENAME could not be rendered syncronously.  N.B. then-jade does not support syncronous rendering.',
  async: function (str, options, cb) {
    this.cache(options, true);//jade handles this.cache internally
    this.engine.render(str, options, cb);
  }
})

exports.dust = new Transformer({
  name: 'dust',
  engines: ['dust', 'dustjs-linkedin'],
  outputFormat: 'xml',
  sudoSync: false,
  async: function (str, options, cb) {
    var ext = 'dust'
      , views = '.';

    if (options) {
      if (options.ext) ext = options.ext;
      if (options.views) views = options.views;
      if (options.settings && options.settings.views) views = options.settings.views;
    }

    this.engine.onLoad = function(path, callback){
      if ('' == extname(path)) path += '.' + ext;
      if ('/' !== path[0]) path = views + '/' + path;
      read(path, options, callback);
    };

    var tmpl = this.cache(options) || this.cache(options, this.engine.compileFn(str));
    if (options && !options.cache) this.engine.cache = {};//invalidate dust's internal cache
    tmpl(options, cb);
  }
});

exports.jazz = new Transformer({
  name: 'jazz',
  engines: ['jazz'],
  outputFormat: 'xml',
  sudoSync: true, // except when an async function is passed to locals
  async: function (str, options, cb) {
    var tmpl = this.cache(options) || this.cache(options, this.engine.compile(str, options));
    tmpl.eval(options, function(str){
      cb(null, str);
    });
  }
});

exports.qejs = new Transformer({
  name: 'qejs',
  engines: ['qejs'],
  outputFormat: 'xml',
  sudoSync: false,
  async: function (str, options, cb) {
    var tmpl = this.cache(options) || this.cache(options, this.engine.compile(str, options));
    tmpl(options).done(function (result) {
        cb(null, result);
    }, function (err) {
        cb(err);
    });
  }
});

/**
 * Stylsheet Languages
 */

exports.less = new Transformer({
  name: 'less',
  engines: ['less'],
  outputFormat: 'css',
  sudoSync: 'The less file FILENAME could not be rendered syncronously.  This is usually because the file contains `@import url` statements.',
  async: function (str, options, cb) {
    var self = this;
    if (self.cache(options)) return cb(null, self.cache(options));
    if (options.filename) {
      options.paths = options.paths || [dirname(options.filename)];
    }
    //If this.cache is enabled, compress by default
    if (options.compress !== true && options.compress !== false) {
      options.compress = options.cache || false;
    }
    if (options.sudoSync) {
      options.syncImport = true;
    }
    var parser = new(this.engine.Parser)(options);
    parser.parse(str, function (err, tree) {
      try {
        if (err) throw err;
        var res = tree.toCSS(options);
        self.cache(options, res);
        cb(null, res);
      } catch (ex) {
        if (!(ex instanceof Error) && typeof ex === 'object') {
          ex.filename = ex.filename || '"Unkown Source"';
          var err = new Error(self.engine.formatError(ex, options).replace(/^[^:]+:/, ''), ex.filename, ex.line);
          err.name = ex.type;
          ex = err;
        }
        console.log('\n\n' + ex.stack + '\n\n');
        return cb(ex);
      }
    });
  }
});

exports.styl = exports.stylus = new Transformer({
  name: 'stylus',
  engines: ['stylus'],
  outputFormat: 'css',
  sudoSync: true,// always runs syncronously
  async: function (str, options, cb) {
    var self = this;
    if (self.cache(options)) return cb(null, self.cache(options));
    if (options.filename) {
      options.paths = options.paths || [dirname(options.filename)];
    }
    //If this.cache is enabled, compress by default
    if (options.compress !== true && options.compress !== false) {
      options.compress = options.cache || false;
    }
    this.engine.render(str, options, function (err, res) {
      if (err) return cb(err);
      self.cache(options, res);
      cb(null, res);
    });
  }
})

exports.sass = new Transformer({
  name: 'sass',
  engines: ['sass'],
  outputFormat: 'css',
  sync: function (str, options) {
    try {
      return this.cache(options) || this.cache(options, this.engine.render(str));
    } catch (ex) {
      if (options.filename) ex.message += ' in ' + options.filename;
      throw ex;
    }
  }
});

/**
 * Miscelaneous
 */

exports.md = exports.markdown = new Transformer({
  name: 'markdown',
  engines: ['marked', 'supermarked', 'markdown-js', 'markdown'],
  outputFormat: 'html',
  sync: function (str, options) {
    var arg = options;
    if (this.engineName === 'markdown') arg = options.dialect; //even if undefined
    return this.cache(options) || this.cache(options, this.engine.parse(str, arg));
  }
});


exports.coffee = exports['coffee-script'] = exports.coffeescript = exports.coffeeScript = new Transformer({
  name: 'coffee-script',
  engines: ['coffee-script'],
  outputFormat: 'js',
  sync: function (str, options) {
    return this.cache(options) || this.cache(options, this.engine.compile(str, options));
  }
});

exports.cson = new Transformer({
  name: 'cson',
  engines: ['cson'],
  outputFormat: 'json',
  sync: function (str, options) {
    //todo: remove once https://github.com/rstacruz/js2coffee/pull/174 accepted & released
    if (global.Narcissus) delete global.Narcissus; //prevent global leak
    return this.cache(options) || this.cache(options, JSON.stringify(this.engine.parseSync(str)));
  }
});

exports.cdata = new Transformer({
  name: 'cdata',
  engines: ['.'],// `.` means "no dependency"
  outputFormat: 'xml',
  sync: function (str, options) {
    return this.cache(options) || this.cache(options, '<![CDATA[\n' + str + '\n]]>');
  }
});

exports.component = exports['component-js'] = new Transformer({
  name: 'component-js',
  engines: ['component-builder'],
  outputFormat: 'js',
  async: function (str, options, cb) {
    if (this.cache(options)) return this.cache(options);
    var self = this;
    var builder = new this.engine(dirname(options.filename));
    if (options.development) {
      builder.development();
    }
    if (options.sourceURLs === true || (options.sourceURLs !== false && options.development)) {
      builder.addSourceURLs();
    }
    var path = __webpack_require__(1);
    builder.paths = (options.paths || ['components']).map(function (p) {
      if (path.resolve(p) === p) {
        return p;
      } else {
        return path.join(dirname(options.filename), p);
      }
    });
    builder.build(function (err, obj) {
      if (err) return cb(err);
      else return cb(null, self.cache(options, obj.require + obj.js));
    });
  }
});

exports['component-css'] = new Transformer({
  name: 'component-css',
  engines: ['component-builder'],
  outputFormat: 'css',
  async: function (str, options, cb) {
    if (this.cache(options)) return this.cache(options);
    var self = this;
    var builder = new this.engine(dirname(options.filename));
    if (options.development) {
      builder.development();
    }
    if (options.sourceURLs === true || (options.sourceURLs !== false && options.development)) {
      builder.addSourceURLs();
    }
    var path = __webpack_require__(1);
    builder.paths = (options.paths || ['components']).map(function (p) {
      if (path.resolve(p) === p) {
        return p;
      } else {
        return path.join(dirname(options.filename), p);
      }
    });
    builder.build(function (err, obj) {
      if (err) return cb(err);
      else return cb(null, self.cache(options, obj.css));
    });
  }
});

exports['html2jade'] = new Transformer({
  name: 'html2jade',
  engines: ['html2jade'],
  outputFormat: 'jade',
  async: function (str, options, cb) {
    return this.cache(options) || this.cache(options, this.engine.convertHtml(str, options, cb));
  }
});

exports['highlight'] = new Transformer({
  name: 'highlight',
  engines: ['highlight.js'],
  outputFormat: 'xml',
  sync: function (str, options, cb) {
    if (this.cache(options)) return this.cache(options);
    if (options.lang) {
      try {
        return this.cache(options, this.engine.highlight(options.lang, str).value);
      } catch (ex) {}
    }
    if (options.auto || !options.lang) {
      try {
        return this.cache(options, this.engine.highlightAuto(str).value);
      } catch (ex) {}
    }
    return this.cache(options, str);
  }
});


/**
 * Marker transformers (they don't actually apply a transformation, but let you declare the 'outputFormat')
 */

exports.css = new Transformer({
  name: 'css',
  engines: ['.'],// `.` means "no dependency"
  outputFormat: 'css',
  sync: function (str, options) {
    return this.cache(options) || this.cache(options, str);
  }
});

exports.js = new Transformer({
  name: 'js',
  engines: ['.'],// `.` means "no dependency"
  outputFormat: 'js',
  sync: function (str, options) {
    return this.cache(options) || this.cache(options, str);
  }
});



/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(40)))

/***/ },
/* 38 */
/***/ function(module, exports) {


var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

var indexOf = __webpack_require__(38);

var Object_keys = function (obj) {
    if (Object.keys) return Object.keys(obj)
    else {
        var res = [];
        for (var key in obj) res.push(key)
        return res;
    }
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

var defineProp = (function() {
    try {
        Object.defineProperty({}, '_', {});
        return function(obj, name, value) {
            Object.defineProperty(obj, name, {
                writable: true,
                enumerable: false,
                configurable: true,
                value: value
            })
        };
    } catch(e) {
        return function(obj, name, value) {
            obj[name] = value;
        };
    }
}());

var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

function Context() {}
Context.prototype = {};

var Script = exports.Script = function NodeScript (code) {
    if (!(this instanceof Script)) return new Script(code);
    this.code = code;
};

Script.prototype.runInContext = function (context) {
    if (!(context instanceof Context)) {
        throw new TypeError("needs a 'context' argument.");
    }
    
    var iframe = document.createElement('iframe');
    if (!iframe.style) iframe.style = {};
    iframe.style.display = 'none';
    
    document.body.appendChild(iframe);
    
    var win = iframe.contentWindow;
    var wEval = win.eval, wExecScript = win.execScript;

    if (!wEval && wExecScript) {
        // win.eval() magically appears when this is called in IE:
        wExecScript.call(win, 'null');
        wEval = win.eval;
    }
    
    forEach(Object_keys(context), function (key) {
        win[key] = context[key];
    });
    forEach(globals, function (key) {
        if (context[key]) {
            win[key] = context[key];
        }
    });
    
    var winKeys = Object_keys(win);

    var res = wEval.call(win, this.code);
    
    forEach(Object_keys(win), function (key) {
        // Avoid copying circular objects like `top` and `window` by only
        // updating existing context properties or new properties in the `win`
        // that was only introduced after the eval.
        if (key in context || indexOf(winKeys, key) === -1) {
            context[key] = win[key];
        }
    });

    forEach(globals, function (key) {
        if (!(key in context)) {
            defineProp(context, key, win[key]);
        }
    });
    
    document.body.removeChild(iframe);
    
    return res;
};

Script.prototype.runInThisContext = function () {
    return eval(this.code); // maybe...
};

Script.prototype.runInNewContext = function (context) {
    var ctx = Script.createContext(context);
    var res = this.runInContext(ctx);

    forEach(Object_keys(ctx), function (key) {
        context[key] = ctx[key];
    });

    return res;
};

forEach(Object_keys(Script.prototype), function (name) {
    exports[name] = Script[name] = function (code) {
        var s = Script(code);
        return s[name].apply(s, [].slice.call(arguments, 1));
    };
});

exports.createScript = function (code) {
    return exports.Script(code);
};

exports.createContext = Script.createContext = function (context) {
    var copy = new Context();
    if(typeof context === 'object') {
        forEach(Object_keys(context), function (key) {
            copy[key] = context[key];
        });
    }
    return copy;
};


/***/ },
/* 40 */
/***/ function(module, exports) {

var g;

// This works in non-strict mode
g = (function() { return this; })();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

self.Jade  = __webpack_require__(14);

self.onmessage = function(ev) {
  var data = JSON.parse(ev.data);
  var html = data.html;
  var opts = data.options || {};

  self.Jade.render(html, opts, function(err, result) {
    self.postMessage(JSON.stringify({err: err, html: result}))
  })
};


/***/ }
/******/ ]);
//# sourceMappingURL=jade-0.30.0.min.js.map