/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmory imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmory exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		Object.defineProperty(exports, name, {
/******/ 			configurable: false,
/******/ 			enumerable: true,
/******/ 			get: getter
/******/ 		});
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 33);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports) {

"use strict";
'use strict';

var Node = module.exports = function Node(){};

/**
 * Clone this node (return itself)
 *
 * @return {Node}
 * @api private
 */

Node.prototype.clone = function(){
  var err = new Error('node.clone is deprecated and will be removed in v2.0.0');
  console.warn(err.stack);
  return this;
};

Node.prototype.type = '';


/***/ },
/* 1 */
/***/ function(module, exports) {

"use strict";
'use strict';

/**
 * Merge `b` into `a`.
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object}
 * @api public
 */

exports.merge = function(a, b) {
  for (var key in b) a[key] = b[key];
  return a;
};

exports.walkAST = function walkAST(ast, before, after) {
  before && before(ast);
  switch (ast.type) {
    case 'Block':
      ast.nodes.forEach(function (node) {
        walkAST(node, before, after);
      });
      break;
    case 'Case':
    case 'Each':
    case 'Mixin':
    case 'Tag':
    case 'When':
      ast.block && walkAST(ast.block, before, after);
      break;
    case 'Attrs':
    case 'BlockComment':
    case 'Code':
    case 'Comment':
    case 'Doctype':
    case 'Filter':
    case 'Literal':
    case 'MixinBlock':
    case 'Text':
      break;
    default:
      throw new Error('Unexpected node type ' + ast.type);
      break;
  }
  after && after(ast);
};

/***/ },
/* 2 */
/***/ function(module, exports) {



/***/ },
/* 3 */
/***/ function(module, exports) {

"use strict";
'use strict';

module.exports = filter;
function filter(name, str, options) {
  if (typeof filter[name] === 'function') {
    var res = filter[name](str, options);
  } else {
    throw new Error('unknown filter ":' + name + '"');
  }
  return res;
}


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

exports.Node = __webpack_require__(0);
exports.Tag = __webpack_require__(28);
exports.Code = __webpack_require__(20);
exports.Each = __webpack_require__(23);
exports.Case = __webpack_require__(19);
exports.Text = __webpack_require__(29);
exports.Block = __webpack_require__(10);
exports.MixinBlock = __webpack_require__(26);
exports.Mixin = __webpack_require__(27);
exports.Filter = __webpack_require__(24);
exports.Comment = __webpack_require__(21);
exports.Literal = __webpack_require__(25);
exports.BlockComment = __webpack_require__(18);
exports.Doctype = __webpack_require__(22);


/***/ },
/* 5 */
/***/ function(module, exports) {

exports = (module.exports = parse);
exports.parse = parse;
function parse(src, state, options) {
  options = options || {};
  state = state || exports.defaultState();
  var start = options.start || 0;
  var end = options.end || src.length;
  var index = start;
  while (index < end) {
    if (state.roundDepth < 0 || state.curlyDepth < 0 || state.squareDepth < 0) {
      throw new SyntaxError('Mismatched Bracket: ' + src[index - 1]);
    }
    exports.parseChar(src[index++], state);
  }
  return state;
}

exports.parseMax = parseMax;
function parseMax(src, options) {
  options = options || {};
  var start = options.start || 0;
  var index = start;
  var state = exports.defaultState();
  while (state.roundDepth >= 0 && state.curlyDepth >= 0 && state.squareDepth >= 0) {
    if (index >= src.length) {
      throw new Error('The end of the string was reached with no closing bracket found.');
    }
    exports.parseChar(src[index++], state);
  }
  var end = index - 1;
  return {
    start: start,
    end: end,
    src: src.substring(start, end)
  };
}

exports.parseUntil = parseUntil;
function parseUntil(src, delimiter, options) {
  options = options || {};
  var includeLineComment = options.includeLineComment || false;
  var start = options.start || 0;
  var index = start;
  var state = exports.defaultState();
  while (state.isString() || state.regexp || state.blockComment ||
         (!includeLineComment && state.lineComment) || !startsWith(src, delimiter, index)) {
    exports.parseChar(src[index++], state);
  }
  var end = index;
  return {
    start: start,
    end: end,
    src: src.substring(start, end)
  };
}


exports.parseChar = parseChar;
function parseChar(character, state) {
  if (character.length !== 1) throw new Error('Character must be a string of length 1');
  state = state || exports.defaultState();
  var wasComment = state.blockComment || state.lineComment;
  var lastChar = state.history ? state.history[0] : '';
  if (state.lineComment) {
    if (character === '\n') {
      state.lineComment = false;
    }
  } else if (state.blockComment) {
    if (state.lastChar === '*' && character === '/') {
      state.blockComment = false;
    }
  } else if (state.singleQuote) {
    if (character === '\'' && !state.escaped) {
      state.singleQuote = false;
    } else if (character === '\\' && !state.escaped) {
      state.escaped = true;
    } else {
      state.escaped = false;
    }
  } else if (state.doubleQuote) {
    if (character === '"' && !state.escaped) {
      state.doubleQuote = false;
    } else if (character === '\\' && !state.escaped) {
      state.escaped = true;
    } else {
      state.escaped = false;
    }
  } else if (state.regexp) {
    if (character === '/' && !state.escaped) {
      state.regexp = false;
    } else if (character === '\\' && !state.escaped) {
      state.escaped = true;
    } else {
      state.escaped = false;
    }
  } else if (lastChar === '/' && character === '/') {
    state.history = state.history.substr(1);
    state.lineComment = true;
  } else if (lastChar === '/' && character === '*') {
    state.history = state.history.substr(1);
    state.blockComment = true;
  } else if (character === '/' && isRegexp(state.history)) {
    state.regexp = true;
  } else if (character === '\'') {
    state.singleQuote = true;
  } else if (character === '"') {
    state.doubleQuote = true;
  } else if (character === '(') {
    state.roundDepth++;
  } else if (character === ')') {
    state.roundDepth--;
  } else if (character === '{') {
    state.curlyDepth++;
  } else if (character === '}') {
    state.curlyDepth--;
  } else if (character === '[') {
    state.squareDepth++;
  } else if (character === ']') {
    state.squareDepth--;
  }
  if (!state.blockComment && !state.lineComment && !wasComment) state.history = character + state.history;
  return state;
}

exports.defaultState = function () { return new State() };
function State() {
  this.lineComment = false;
  this.blockComment = false;

  this.singleQuote = false;
  this.doubleQuote = false;
  this.regexp = false;
  this.escaped = false;

  this.roundDepth = 0;
  this.curlyDepth = 0;
  this.squareDepth = 0;

  this.history = ''
}
State.prototype.isString = function () {
  return this.singleQuote || this.doubleQuote;
}
State.prototype.isComment = function () {
  return this.lineComment || this.blockComment;
}
State.prototype.isNesting = function () {
  return this.isString() || this.isComment() || this.regexp || this.roundDepth > 0 || this.curlyDepth > 0 || this.squareDepth > 0
}

function startsWith(str, start, i) {
  return str.substr(i || 0, start.length) === start;
}

exports.isPunctuator = isPunctuator
function isPunctuator(c) {
  var code = c.charCodeAt(0)

  switch (code) {
    case 46:   // . dot
    case 40:   // ( open bracket
    case 41:   // ) close bracket
    case 59:   // ; semicolon
    case 44:   // , comma
    case 123:  // { open curly brace
    case 125:  // } close curly brace
    case 91:   // [
    case 93:   // ]
    case 58:   // :
    case 63:   // ?
    case 126:  // ~
    case 37:   // %
    case 38:   // &
    case 42:   // *:
    case 43:   // +
    case 45:   // -
    case 47:   // /
    case 60:   // <
    case 62:   // >
    case 94:   // ^
    case 124:  // |
    case 33:   // !
    case 61:   // =
      return true;
    default:
      return false;
  }
}
exports.isKeyword = isKeyword
function isKeyword(id) {
  return (id === 'if') || (id === 'in') || (id === 'do') || (id === 'var') || (id === 'for') || (id === 'new') ||
         (id === 'try') || (id === 'let') || (id === 'this') || (id === 'else') || (id === 'case') ||
         (id === 'void') || (id === 'with') || (id === 'enum') || (id === 'while') || (id === 'break') || (id === 'catch') ||
         (id === 'throw') || (id === 'const') || (id === 'yield') || (id === 'class') || (id === 'super') ||
         (id === 'return') || (id === 'typeof') || (id === 'delete') || (id === 'switch') || (id === 'export') ||
         (id === 'import') || (id === 'default') || (id === 'finally') || (id === 'extends') || (id === 'function') ||
         (id === 'continue') || (id === 'debugger') || (id === 'package') || (id === 'private') || (id === 'interface') ||
         (id === 'instanceof') || (id === 'implements') || (id === 'protected') || (id === 'public') || (id === 'static') ||
         (id === 'yield') || (id === 'let');
}

function isRegexp(history) {
  //could be start of regexp or divide sign

  history = history.replace(/^\s*/, '');

  //unless its an `if`, `while`, `for` or `with` it's a divide, so we assume it's a divide
  if (history[0] === ')') return false;
  //unless it's a function expression, it's a regexp, so we assume it's a regexp
  if (history[0] === '}') return true;
  //any punctuation means it's a regexp
  if (isPunctuator(history[0])) return true;
  //if the last thing was a keyword then it must be a regexp (e.g. `typeof /foo/`)
  if (/^\w+\b/.test(history) && isKeyword(/^\w+\b/.exec(history)[0].split('').reverse().join(''))) return true;

  return false;
}


/***/ },
/* 6 */
/***/ function(module, exports) {

!function(n,e){"use strict";function t(n){for(var e=Object.create(null),t=0;t<n.length;++t)e[n[t]]=!0;return e}function r(n){return n.split("")}function i(n,e){return e.indexOf(n)>=0}function o(n,e){for(var t=0,r=e.length;t<r;++t)if(n(e[t]))return e[t]}function a(n,e){if(e<=0)return"";if(1==e)return n;var t=a(n,e>>1);return t+=t,1&e&&(t+=n),t}function u(n,e){Error.call(this,n),this.msg=n,this.defs=e}function s(n,e,t){n===!0&&(n={});var r=n||{};if(t)for(var i in r)g(r,i)&&!g(e,i)&&u.croak("`"+i+"` is not a supported option",e);for(var i in e)g(e,i)&&(r[i]=n&&g(n,i)?n[i]:e[i]);return r}function c(n,e){var t=0;for(var r in e)g(e,r)&&(n[r]=e[r],t++);return t}function f(){}function l(n,e){n.indexOf(e)<0&&n.push(e)}function p(n,e){return n.replace(/\{(.+?)\}/g,function(n,t){return e[t]})}function d(n,e){for(var t=n.length;--t>=0;)n[t]===e&&n.splice(t,1)}function h(n,e){function t(n,t){for(var r=[],i=0,o=0,a=0;i<n.length&&o<t.length;)e(n[i],t[o])<=0?r[a++]=n[i++]:r[a++]=t[o++];return i<n.length&&r.push.apply(r,n.slice(i)),o<t.length&&r.push.apply(r,t.slice(o)),r}function r(n){if(n.length<=1)return n;var e=Math.floor(n.length/2),i=n.slice(0,e),o=n.slice(e);return i=r(i),o=r(o),t(i,o)}return n.length<2?n.slice():r(n)}function v(n){function e(n){return JSON.stringify(n).replace(/[\u2028\u2029]/g,function(n){switch(n){case"\u2028":return"\\u2028";case"\u2029":return"\\u2029"}return n})}function t(n){if(1==n.length)return r+="return str === "+e(n[0])+";";r+="switch(str){";for(var t=0;t<n.length;++t)r+="case "+e(n[t])+":";r+="return true}return false;"}n instanceof Array||(n=n.split(" "));var r="",i=[];n:for(var o=0;o<n.length;++o){for(var a=0;a<i.length;++a)if(i[a][0].length==n[o].length){i[a].push(n[o]);continue n}i.push([n[o]])}if(i.length>3){i.sort(function(n,e){return e.length-n.length}),r+="switch(str.length){";for(var o=0;o<i.length;++o){var u=i[o];r+="case "+u[0].length+":",t(u)}r+="}"}else t(n);return new Function("str",r)}function m(n,e){for(var t=n.length;--t>=0;)if(!e(n[t]))return!1;return!0}function _(){this._values=Object.create(null),this._size=0}function g(n,e){return Object.prototype.hasOwnProperty.call(n,e)}function b(e,t,r,i){arguments.length<4&&(i=W),t=t?t.split(/\s+/):[];var o=t;i&&i.PROPS&&(t=t.concat(i.PROPS));for(var a="return function AST_"+e+"(props){ if (props) { ",u=t.length;--u>=0;)a+="this."+t[u]+" = props."+t[u]+";";var s=i&&new i;(s&&s.initialize||r&&r.initialize)&&(a+="this.initialize();"),a+="}}";var c=new Function(a)();if(s&&(c.prototype=s,c.BASE=i),i&&i.SUBCLASSES.push(c),c.prototype.CTOR=c,c.PROPS=t||null,c.SELF_PROPS=o,c.SUBCLASSES=[],e&&(c.prototype.TYPE=c.TYPE=e),r)for(u in r)g(r,u)&&(/^\$/.test(u)?c[u.substr(1)]=r[u]:c.prototype[u]=r[u]);return c.DEFMETHOD=function(n,e){this.prototype[n]=e},n["AST_"+e]=c,c}function y(n,e){n.body instanceof G?n.body._walk(e):n.body.forEach(function(n){n._walk(e)})}function A(n){this.visit=n,this.stack=[],this.directives=Object.create(null)}function w(n){return n>=97&&n<=122||n>=65&&n<=90||n>=170&&Ne.letter.test(String.fromCharCode(n))}function E(n){return n>=48&&n<=57}function D(n){return E(n)||w(n)}function x(n){return Ne.digit.test(String.fromCharCode(n))}function k(n){return Ne.non_spacing_mark.test(n)||Ne.space_combining_mark.test(n)}function F(n){return Ne.connector_punctuation.test(n)}function C(n){return!Ce(n)&&/^[a-z_$][a-z0-9_$]*$/i.test(n)}function B(n){return 36==n||95==n||w(n)}function S(n){var e=n.charCodeAt(0);return B(e)||E(e)||8204==e||8205==e||k(n)||F(n)||x(e)}function T(n){return/^[a-z_$][a-z0-9_$]*$/i.test(n)}function $(n){if(Te.test(n))return parseInt(n.substr(2),16);if($e.test(n))return parseInt(n.substr(1),8);var e=parseFloat(n);return e==n?e:void 0}function O(n,e,t,r,i){this.message=n,this.filename=e,this.line=t,this.col=r,this.pos=i,this.stack=(new Error).stack}function q(n,e,t,r,i){throw new O(n,e,t,r,i)}function M(n,e,t){return n.type==e&&(null==t||n.value==t)}function z(n,e,t,r){function i(){return T.text.charAt(T.pos)}function o(n,e){var t=T.text.charAt(T.pos++);if(n&&!t)throw je;return Me(t)?(T.newline_before=T.newline_before||!e,++T.line,T.col=0,e||"\r"!=t||"\n"!=i()||(++T.pos,t="\n")):++T.col,t}function a(n){for(;n-- >0;)o()}function u(n){return T.text.substr(T.pos,n.length)==n}function s(){for(var n=T.text,e=T.pos,t=T.text.length;e<t;++e){var r=n[e];if(Me(r))return e}return-1}function c(n,e){var t=T.text.indexOf(n,T.pos);if(e&&t==-1)throw je;return t}function f(){T.tokline=T.line,T.tokcol=T.col,T.tokpos=T.pos}function l(t,r,i){T.regex_allowed="operator"==t&&!Ie(r)||"keyword"==t&&Be(r)||"punc"==t&&ze(r),O="punc"==t&&"."==r;var o={type:t,value:r,line:T.tokline,col:T.tokcol,pos:T.tokpos,endline:T.line,endcol:T.col,endpos:T.pos,nlb:T.newline_before,file:e};if(/^(?:num|string|regexp)$/i.test(t)&&(o.raw=n.substring(o.pos,o.endpos)),!i){o.comments_before=T.comments_before,T.comments_before=[];for(var a=0,u=o.comments_before.length;a<u;a++)o.nlb=o.nlb||o.comments_before[a].nlb}return T.newline_before=!1,new Y(o)}function p(){for(;qe(i());)o()}function d(n){for(var e,t="",r=0;(e=i())&&n(e,r++);)t+=o();return t}function h(n){q(n,e,T.tokline,T.tokcol,T.tokpos)}function v(n){var e=!1,t=!1,r=!1,i="."==n,o=d(function(o,a){var u=o.charCodeAt(0);switch(u){case 120:case 88:return!r&&(r=!0);case 101:case 69:return!!r||!e&&(e=t=!0);case 45:return t||0==a&&!n;case 43:return t;case t=!1,46:return!(i||r||e)&&(i=!0)}return D(u)});n&&(o=n+o),$e.test(o)&&C.has_directive("use strict")&&h("SyntaxError: Legacy octal literals are not allowed in strict mode");var a=$(o);return isNaN(a)?void h("SyntaxError: Invalid syntax: "+o):l("num",a)}function m(n){var e=o(!0,n);switch(e.charCodeAt(0)){case 110:return"\n";case 114:return"\r";case 116:return"\t";case 98:return"\b";case 118:return"\v";case 102:return"\f";case 120:return String.fromCharCode(g(2));case 117:return String.fromCharCode(g(4));case 10:return"";case 13:if("\n"==i())return o(!0,n),""}return e>="0"&&e<="7"?_(e):e}function _(n){var e=i();return e>="0"&&e<="7"&&(n+=o(!0),n[0]<="3"&&(e=i())>="0"&&e<="7"&&(n+=o(!0))),"0"===n?"\0":(n.length>0&&C.has_directive("use strict")&&h("SyntaxError: Legacy octal escape sequences are not allowed in strict mode"),String.fromCharCode(parseInt(n,8)))}function g(n){for(var e=0;n>0;--n){var t=parseInt(o(!0),16);isNaN(t)&&h("SyntaxError: Invalid hex-character pattern in string"),e=e<<4|t}return e}function b(n){var e,t=T.regex_allowed,r=s();return r==-1?(e=T.text.substr(T.pos),T.pos=T.text.length):(e=T.text.substring(T.pos,r),T.pos=r),T.col=T.tokcol+(T.pos-T.tokpos),T.comments_before.push(l(n,e,!0)),T.regex_allowed=t,C}function y(){for(var n,e,t=!1,r="",a=!1;null!=(n=i());)if(t)"u"!=n&&h("SyntaxError: Expecting UnicodeEscapeSequence -- uXXXX"),n=m(),S(n)||h("SyntaxError: Unicode char: "+n.charCodeAt(0)+" is not valid in identifier"),r+=n,t=!1;else if("\\"==n)a=t=!0,o();else{if(!S(n))break;r+=o()}return ke(r)&&a&&(e=r.charCodeAt(0).toString(16).toUpperCase(),r="\\u"+"0000".substr(e.length)+e+r.slice(1)),r}function A(n){function e(n){if(!i())return n;var t=n+i();return Oe(t)?(o(),e(t)):n}return l("operator",e(n||o()))}function w(){switch(o(),i()){case"/":return o(),b("comment1");case"*":return o(),z()}return T.regex_allowed?H(""):A("/")}function x(){return o(),E(i().charCodeAt(0))?v("."):l("punc",".")}function k(){var n=y();return O?l("name",n):Fe(n)?l("atom",n):ke(n)?Oe(n)?l("operator",n):l("keyword",n):l("name",n)}function F(n,e){return function(t){try{return e(t)}catch(e){if(e!==je)throw e;h(n)}}}function C(n){if(null!=n)return H(n);for(;;){if(p(),f(),t){if(u("<!--")){a(4),b("comment3");continue}if(u("-->")&&T.newline_before){a(3),b("comment4");continue}}var e=i();if(!e)return l("eof");var s=e.charCodeAt(0);switch(s){case 34:case 39:return M(e);case 46:return x();case 47:var c=w();if(c===C)continue;return c}if(E(s))return v();if(He(e))return l("punc",o());if(Se(e))return A();if(92==s||B(s))return k();if(!r||0!=T.pos||!u("#!"))break;a(2),b("comment5")}h("SyntaxError: Unexpected character '"+e+"'")}var T={text:n,filename:e,pos:0,tokpos:0,line:1,tokline:0,col:0,tokcol:0,newline_before:!1,regex_allowed:!1,comments_before:[],directives:{},directive_stack:[]},O=!1,M=F("SyntaxError: Unterminated string constant",function(n){for(var e=o(),t="";;){var r=o(!0,!0);if("\\"==r)r=m(!0);else if(Me(r))h("SyntaxError: Unterminated string constant");else if(r==e)break;t+=r}var i=l("string",t);return i.quote=n,i}),z=F("SyntaxError: Unterminated multiline comment",function(){var n=T.regex_allowed,e=c("*/",!0),t=T.text.substring(T.pos,e).replace(/\r\n|\r|\u2028|\u2029/g,"\n");return a(t.length+2),T.comments_before.push(l("comment2",t,!0)),T.regex_allowed=n,C}),H=F("SyntaxError: Unterminated regular expression",function(n){for(var e,t=!1,r=!1;e=o(!0);)if(Me(e))h("SyntaxError: Unexpected line terminator");else if(t)n+="\\"+e,t=!1;else if("["==e)r=!0,n+=e;else if("]"==e&&r)r=!1,n+=e;else{if("/"==e&&!r)break;"\\"==e?t=!0:n+=e}var i=y();try{return l("regexp",new RegExp(n,i))}catch(n){h("SyntaxError: "+n.message)}});return C.context=function(n){return n&&(T=n),T},C.add_directive=function(n){T.directive_stack[T.directive_stack.length-1].push(n),void 0===T.directives[n]?T.directives[n]=1:T.directives[n]++},C.push_directives_stack=function(){T.directive_stack.push([])},C.pop_directives_stack=function(){for(var n=T.directive_stack[T.directive_stack.length-1],e=0;e<n.length;e++)T.directives[n[e]]--;T.directive_stack.pop()},C.has_directive=function(n){return void 0!==T.directives[n]&&T.directives[n]>0},C}function H(n,e){function t(n,e){return M(U.token,n,e)}function r(){return U.peeked||(U.peeked=U.input())}function i(){return U.prev=U.token,U.peeked?(U.token=U.peeked,U.peeked=null):U.token=U.input(),U.in_directives=U.in_directives&&("string"==U.token.type||t("punc",";")),U.token}function a(){return U.prev}function u(n,e,t,r){var i=U.input.context();q(n,i.filename,null!=e?e:i.tokline,null!=t?t:i.tokcol,null!=r?r:i.tokpos)}function c(n,e){u(e,n.line,n.col)}function f(n){null==n&&(n=U.token),c(n,"SyntaxError: Unexpected token: "+n.type+" ("+n.value+")")}function l(n,e){return t(n,e)?i():void c(U.token,"SyntaxError: Unexpected token "+U.token.type+" «"+U.token.value+"», expected "+n+" «"+e+"»")}function p(n){return l("punc",n)}function d(){return!e.strict&&(U.token.nlb||t("eof")||t("punc","}"))}function h(n){t("punc",";")?i():n||d()||f()}function v(){p("(");var n=kn(!0);return p(")"),n}function m(n){return function(){var e=U.token,t=n(),r=a();return t.start=e,t.end=r,t}}function _(){(t("operator","/")||t("operator","/="))&&(U.peeked=null,U.token=U.input(U.token.value.substr(1)))}function g(){var n=N(ce);o(function(e){return e.name==n.name},U.labels)&&u("SyntaxError: Label "+n.name+" defined twice"),p(":"),U.labels.push(n);var e=L();return U.labels.pop(),e instanceof rn||n.references.forEach(function(e){e instanceof En&&(e=e.label.start,u("SyntaxError: Continue label `"+n.name+"` refers to non-IterationStatement.",e.line,e.col,e.pos))}),new tn({body:e,label:n})}function b(n){return new Z({body:(n=kn(!0),h(),n)})}function y(n){var e,t=null;d()||(t=N(le,!0)),null!=t?(e=o(function(n){return n.name==t.name},U.labels),e||u("SyntaxError: Undefined label "+t.name),t.thedef=e):0==U.in_loop&&u("SyntaxError: "+n.TYPE+" not inside a loop or switch"),h();var r=new n({label:t});return e&&e.references.push(r),r}function A(){p("(");var n=null;return!t("punc",";")&&(n=t("keyword","var")?(i(),Y(!0)):kn(!0,!0),t("operator","in"))?(n instanceof On&&n.definitions.length>1&&u("SyntaxError: Only one variable declaration allowed in for..in loop"),i(),E(n)):w(n)}function w(n){p(";");var e=t("punc",";")?null:kn(!0);p(";");var r=t("punc",")")?null:kn(!0);return p(")"),new sn({init:n,condition:e,step:r,body:P(L)})}function E(n){var e=n instanceof On?n.definitions[0].name:null,t=kn(!0);return p(")"),new cn({init:n,name:e,object:t,body:P(L)})}function D(){var n=v(),e=L(),r=null;return t("keyword","else")&&(i(),r=L()),new Dn({condition:n,body:e,alternative:r})}function x(){p("{");for(var n=[];!t("punc","}");)t("eof")&&f(),n.push(L());return i(),n}function k(){p("{");for(var n,e=[],r=null,o=null;!t("punc","}");)t("eof")&&f(),t("keyword","case")?(o&&(o.end=a()),r=[],o=new Cn({start:(n=U.token,i(),n),expression:kn(!0),body:r}),e.push(o),p(":")):t("keyword","default")?(o&&(o.end=a()),r=[],o=new Fn({start:(n=U.token,i(),p(":"),n),body:r}),e.push(o)):(r||f(),r.push(L()));return o&&(o.end=a()),i(),e}function F(){var n=x(),e=null,r=null;if(t("keyword","catch")){var o=U.token;i(),p("(");var s=N(se);p(")"),e=new Sn({start:o,argname:s,body:x(),end:a()})}if(t("keyword","finally")){var o=U.token;i(),r=new Tn({start:o,body:x(),end:a()})}return e||r||u("SyntaxError: Missing catch/finally blocks"),new Bn({body:n,bcatch:e,bfinally:r})}function C(n,e){for(var r=[];r.push(new Mn({start:U.token,name:N(e?ie:re),value:t("operator","=")?(i(),kn(!1,n)):null,end:a()})),t("punc",",");)i();return r}function B(){var n,e=U.token;switch(e.type){case"name":case"keyword":n=H(fe);break;case"num":n=new ve({start:e,end:e,value:e.value});break;case"string":n=new he({start:e,end:e,value:e.value,quote:e.quote});break;case"regexp":n=new me({start:e,end:e,value:e.value});break;case"atom":switch(e.value){case"false":n=new De({start:e,end:e});break;case"true":n=new xe({start:e,end:e});break;case"null":n=new ge({start:e,end:e})}break;case"operator":T(e.value)||u("SyntaxError: Invalid getter/setter name: "+e.value,e.line,e.col,e.pos),n=H(fe)}return i(),n}function S(n,e,r){for(var o=!0,a=[];!t("punc",n)&&(o?o=!1:p(","),!e||!t("punc",n));)t("punc",",")&&r?a.push(new Ae({start:U.token,end:U.token})):a.push(kn(!1));return i(),a}function $(){var n=U.token;switch(i(),n.type){case"num":case"string":case"name":case"operator":case"keyword":case"atom":return n.value;default:f()}}function O(){var n=U.token;switch(i(),n.type){case"name":case"operator":case"keyword":case"atom":return n.value;default:f()}}function H(n){var e=U.token.value;return new("this"==e?pe:n)({name:String(e),start:U.token,end:U.token})}function N(n,e){if(!t("name"))return e||u("SyntaxError: Name expected"),null;var r=H(n);return i(),r}function j(n,e,t){return"++"!=e&&"--"!=e||I(t)||u("SyntaxError: Invalid use of "+e+" operator"),new n({operator:e,expression:t})}function R(n){return _n(dn(!0),0,n)}function I(n){return!e.strict||!(n instanceof pe)&&(n instanceof jn||n instanceof ne)}function P(n){++U.in_loop;var e=n();return--U.in_loop,e}e=s(e,{strict:!1,filename:null,toplevel:null,expression:!1,html5_comments:!0,bare_returns:!1,shebang:!0});var U={input:"string"==typeof n?z(n,e.filename,e.html5_comments,e.shebang):n,token:null,prev:null,peeked:null,in_function:0,in_directives:!0,in_loop:0,labels:[]};U.token=i();var L=m(function(){var n;switch(_(),U.token.type){case"string":var o=!1;U.in_directives===!0&&((M(r(),"punc",";")||r().nlb)&&U.token.raw.indexOf("\\")===-1?U.input.add_directive(U.token.value):U.in_directives=!1);var o=U.in_directives,s=b();return o?new X({start:s.body.start,end:s.body.end,quote:s.body.quote,value:s.body.value}):s;case"num":case"regexp":case"operator":case"atom":return b();case"name":return M(r(),"punc",":")?g():b();case"punc":switch(U.token.value){case"{":return new Q({start:U.token,body:x(),end:a()});case"[":case"(":return b();case";":return U.in_directives=!1,i(),new nn;default:f()}case"keyword":switch(n=U.token.value,i(),n){case"break":return y(wn);case"continue":return y(En);case"debugger":return h(),new J;case"do":return new an({body:P(L),condition:(l("keyword","while"),n=v(),h(!0),n)});case"while":return new un({condition:v(),body:P(L)});case"for":return A();case"function":return V(mn);case"if":return D();case"return":return 0!=U.in_function||e.bare_returns||u("SyntaxError: 'return' outside of function"),new bn({value:t("punc",";")?(i(),null):d()?null:(n=kn(!0),h(),n)});case"switch":return new xn({expression:v(),body:P(k)});case"throw":return U.token.nlb&&u("SyntaxError: Illegal newline after 'throw'"),new yn({value:(n=kn(!0),h(),n)});case"try":return F();case"var":return n=Y(),h(),n;case"const":return n=W(),h(),n;case"with":return U.input.has_directive("use strict")&&u("SyntaxError: Strict mode may not include a with statement"),new fn({expression:v(),body:L()});default:f()}}}),V=function(n){var e=n===mn,r=t("name")?N(e?ae:ue):null;return e&&!r&&f(),p("("),new n({name:r,argnames:function(n,e){for(;!t("punc",")");)n?n=!1:p(","),e.push(N(oe));return i(),e}(!0,[]),body:function(n,e){++U.in_function,U.in_directives=!0,U.input.push_directives_stack(),U.in_loop=0,U.labels=[];var t=x();return U.input.pop_directives_stack(),--U.in_function,U.in_loop=n,U.labels=e,t}(U.in_loop,U.labels)})},Y=function(n){return new On({start:a(),definitions:C(n,!1),end:a()})},W=function(){return new qn({start:a(),definitions:C(!1,!0),end:a()})},G=function(n){var e=U.token;l("operator","new");var r,o=K(!1);return t("punc","(")?(i(),r=S(")")):r=[],ln(new Hn({start:e,expression:o,args:r,end:a()}),n)},K=function(n){if(t("operator","new"))return G(n);var e=U.token;if(t("punc")){switch(e.value){case"(":i();var r=kn(!0);return r.start=e,r.end=U.token,p(")"),ln(r,n);case"[":return ln(en(),n);case"{":return ln(on(),n)}f()}if(t("keyword","function")){i();var o=V(vn);return o.start=e,o.end=a(),ln(o,n)}return Le[U.token.type]?ln(B(),n):void f()},en=m(function(){return p("["),new Gn({elements:S("]",!e.strict,!0)})}),on=m(function(){p("{");for(var n=!0,r=[];!t("punc","}")&&(n?n=!1:p(","),e.strict||!t("punc","}"));){var o=U.token,u=o.type,s=$();if("name"==u&&!t("punc",":")){if("get"==s){r.push(new Qn({start:o,key:B(),value:V(hn),end:a()}));continue}if("set"==s){r.push(new Kn({start:o,key:B(),value:V(hn),end:a()}));continue}}p(":"),r.push(new Zn({start:o,quote:o.quote,key:s,value:kn(!1),end:a()}))}return i(),new Jn({properties:r})}),ln=function(n,e){var r=n.start;if(t("punc","."))return i(),ln(new Rn({start:r,expression:n,property:O(),end:a()}),e);if(t("punc","[")){i();var o=kn(!0);return p("]"),ln(new In({start:r,expression:n,property:o,end:a()}),e)}return e&&t("punc","(")?(i(),ln(new zn({start:r,expression:n,args:S(")"),end:a()}),!0)):n},dn=function(n){var e=U.token;if(t("operator")&&Re(e.value)){i(),_();var r=j(Un,e.value,dn(n));return r.start=e,r.end=a(),r}for(var o=K(n);t("operator")&&Ie(U.token.value)&&!U.token.nlb;)o=j(Ln,U.token.value,o),o.start=e,o.end=U.token,i();return o},_n=function(n,e,r){var o=t("operator")?U.token.value:null;"in"==o&&r&&(o=null);var a=null!=o?Ue[o]:null;if(null!=a&&a>e){i();var u=_n(dn(!0),a,r);return _n(new Vn({start:n.start,left:n,operator:o,right:u,end:u.end}),e,r)}return n},gn=function(n){var e=U.token,r=R(n);if(t("operator","?")){i();var o=kn(!1);return p(":"),new Yn({start:e,condition:r,consequent:o,alternative:kn(!1,n),end:a()})}return r},An=function(n){var e=U.token,r=gn(n),o=U.token.value;if(t("operator")&&Pe(o)){if(I(r))return i(),new Wn({start:e,left:r,operator:o,right:An(n),end:a()});u("SyntaxError: Invalid assignment")}return r},kn=function(n,e){var o=U.token,a=An(e);return n&&t("punc",",")?(i(),new Nn({start:o,car:a,cdr:kn(!0,e),end:r()})):a};return e.expression?kn(!0):function(){var n=U.token,r=[];for(U.input.push_directives_stack();!t("eof");)r.push(L());U.input.pop_directives_stack();var i=a(),o=e.toplevel;return o?(o.body=o.body.concat(r),o.end=i):o=new pn({start:n,body:r,end:i}),o}()}function N(n,e){A.call(this),this.before=n,this.after=e}function j(n,e,t){this.name=t.name,this.orig=[t],this.scope=n,this.references=[],this.global=!1,this.mangled_name=null,this.undeclared=!1,this.constant=!1,this.index=e,this.id=j.next_id++}function R(n){function e(n,e){return n.replace(/[\u0000-\u001f\u007f-\uffff]/g,function(n){var t=n.charCodeAt(0).toString(16);if(t.length<=2&&!e){for(;t.length<2;)t="0"+t;return"\\x"+t}for(;t.length<4;)t="0"+t;return"\\u"+t})}function t(t,r){function i(){return"'"+t.replace(/\x27/g,"\\'")+"'"}function o(){return'"'+t.replace(/\x22/g,'\\"')+'"'}var a=0,u=0;switch(t=t.replace(/[\\\b\f\n\r\v\t\x22\x27\u2028\u2029\0\ufeff]/g,function(e,r){switch(e){case'"':return++a,'"';case"'":return++u,"'";case"\\":return"\\\\";case"\n":return"\\n";case"\r":return"\\r";case"\t":return"\\t";case"\b":return"\\b";case"\f":return"\\f";case"\v":return n.screw_ie8?"\\v":"\\x0B";case"\u2028":return"\\u2028";case"\u2029":return"\\u2029";case"\ufeff":return"\\ufeff";case"\0":return/[0-7]/.test(t.charAt(r+1))?"\\x00":"\\0"}return e}),n.ascii_only&&(t=e(t)),n.quote_style){case 1:return i();case 2:return o();case 3:return"'"==r?i():o();default:return a>u?i():o()}}function r(e,r){var i=t(e,r);return n.inline_script&&(i=i.replace(/<\x2fscript([>\/\t\n\f\r ])/gi,"<\\/script$1"),i=i.replace(/\x3c!--/g,"\\x3c!--"),i=i.replace(/--\x3e/g,"--\\x3e")),i}function i(t){return t=t.toString(),n.ascii_only&&(t=e(t,!0)),t}function o(e){return a(" ",n.indent_start+w-e*n.indent_level)}function u(){return B.charAt(B.length-1)}function c(){n.max_line_len&&E>n.max_line_len&&l("\n")}function l(e){e=String(e);var t=e.charAt(0);if(C&&(C=!1,t&&!(";}".indexOf(t)<0)||/[;]$/.test(B)||(n.semicolons||T(t)?(k+=";",E++,x++):(k+="\n",x++,D++,E=0,/^\s+$/.test(e)&&(C=!0)),n.beautify||(F=!1))),!n.beautify&&n.preserve_line&&N[N.length-1])for(var r=N[N.length-1].start.line;D<r;)k+="\n",x++,D++,E=0,F=!1;if(F){var i=u();(S(i)&&(S(t)||"\\"==t)||/^[\+\-\/]$/.test(t)&&t==i)&&(k+=" ",E++,x++),F=!1}var o=e.split(/\r?\n/),a=o.length-1;D+=a,0==a?E+=o[a].length:E=o[a].length,x+=e.length,B=e,k+=e}function p(){C=!1,l(";")}function d(){return w+n.indent_level}function h(n){var e;return l("{"),M(),q(d(),function(){e=n()}),O(),l("}"),e}function m(n){l("(");var e=n();return l(")"),e}function _(n){l("[");var e=n();return l("]"),e}function g(){l(","),$()}function b(){l(":"),n.space_colon&&$()}function y(){return k}if(n=s(n,{indent_start:0,indent_level:4,quote_keys:!1,space_colon:!0,ascii_only:!1,unescape_regexps:!1,inline_script:!1,width:80,max_line_len:32e3,beautify:!1,source_map:null,bracketize:!1,semicolons:!0,comments:!1,shebang:!0,preserve_line:!1,screw_ie8:!0,preamble:null,quote_style:0,keep_quoted_props:!1,wrap_iife:!1},!0),"string"==typeof n.comments&&/^\/.*\/[a-zA-Z]*$/.test(n.comments)){var A=n.comments.lastIndexOf("/");n.comments=new RegExp(n.comments.substr(1,A-1),n.comments.substr(A+1))}n.comments instanceof RegExp?n.comments=function(n){return function(e){return"comment5"==e.type||n.test(e.value)}}(n.comments):"function"==typeof n.comments?n.comments=function(n){return function(e){return"comment5"==e.type||n(this,e)}}(n.comments):"some"===n.comments?n.comments=function(n){var e=n.value,t=n.type;return"comment2"==t?/@preserve|@license|@cc_on/i.test(e):"comment5"==t}:n.comments?n.comments=function(){return!0}:n.comments=function(n){return"comment5"==n.type};var w=0,E=0,D=1,x=0,k="",F=!1,C=!1,B=null,T=v("( [ + * / - , ."),$=n.beautify?function(){l(" ")}:function(){F=!0},O=n.beautify?function(e){n.beautify&&l(o(e?.5:0))}:f,q=n.beautify?function(n,e){n===!0&&(n=d());var t=w;w=n;var r=e();return w=t,r}:function(n,e){return e()},M=n.beautify?function(){l("\n")}:c,z=n.beautify?function(){l(";")}:function(){C=!0},H=n.source_map?function(e,t){try{e&&n.source_map.add(e.file||"?",D,E,e.line,e.col,t||"name"!=e.type?t:e.value)}catch(n){W.warn("Couldn't figure out mapping for {file}:{line},{col} → {cline},{ccol} [{name}]",{file:e.file,line:e.line,col:e.col,cline:D,ccol:E,name:t||""})}}:f;n.preamble&&l(n.preamble.replace(/\r\n?|[\n\u2028\u2029]|\s*$/g,"\n"));var N=[];return{get:y,toString:y,indent:O,indentation:function(){return w},current_width:function(){return E-w},should_break:function(){return n.width&&this.current_width()>=n.width},newline:M,print:l,space:$,comma:g,colon:b,last:function(){return B},semicolon:z,force_semicolon:p,to_ascii:e,print_name:function(n){l(i(n))},print_string:function(n,e,t){var i=r(n,e);t===!0&&i.indexOf("\\")===-1&&(Ye.test(k)||p(),p()),l(i)},encode_string:r,next_indent:d,with_indent:q,with_block:h,with_parens:m,with_square:_,add_mapping:H,option:function(e){return n[e]},line:function(){return D},col:function(){return E},pos:function(){return x},push_node:function(n){N.push(n)},pop_node:function(){return N.pop()},stack:function(){return N},parent:function(n){return N[N.length-2-(n||0)]}}}function I(n,e){if(!(this instanceof I))return new I(n,e);N.call(this,this.before,this.after),this.options=s(n,{sequences:!e,properties:!e,dead_code:!e,drop_debugger:!e,unsafe:!1,unsafe_comps:!1,conditionals:!e,comparisons:!e,evaluate:!e,booleans:!e,loops:!e,unused:!e,hoist_funs:!e,keep_fargs:!0,keep_fnames:!1,hoist_vars:!1,if_return:!e,join_vars:!e,collapse_vars:!1,reduce_vars:!1,cascade:!e,side_effects:!e,pure_getters:!1,pure_funcs:null,negate_iife:!e,screw_ie8:!0,drop_console:!1,angular:!1,warnings:!0,global_defs:{},passes:1},!0);var t=this.options.sequences;this.sequences_limit=1==t?200:0|t,this.warnings_produced={}}function P(n){function e(e,i,o,a,u,s){if(r){var c=r.originalPositionFor({line:a,column:u});if(null===c.source)return;e=c.source,a=c.line,u=c.column,s=c.name||s}t.addMapping({generated:{line:i+n.dest_line_diff,column:o},original:{line:a+n.orig_line_diff,column:u},source:e,name:s})}n=s(n,{file:null,root:null,orig:null,orig_line_diff:0,dest_line_diff:0});var t=new MOZ_SourceMap.SourceMapGenerator({file:n.file,sourceRoot:n.root}),r=n.orig&&new MOZ_SourceMap.SourceMapConsumer(n.orig);return r&&Array.isArray(n.orig.sources)&&n.orig.sources.forEach(function(n){var e=r.sourceContentFor(n,!0);e&&t.setSourceContent(n,e)}),{add:e,get:function(){return t},toString:function(){return JSON.stringify(t.toJSON())}}}function U(){function n(n){l(e,n)}var e=[];return[Object,Array,Function,Number,String,Boolean,Error,Math,Date,RegExp].forEach(function(e){Object.getOwnPropertyNames(e).map(n),e.prototype&&Object.getOwnPropertyNames(e.prototype).map(n)}),e}function L(n,e){function t(n){return!(v.indexOf(n)>=0)&&(!(c.indexOf(n)>=0)&&(e.only_cache?f.props.has(n):!/^[0-9.]+$/.test(n)))}function r(n){return!(d&&n in m)&&(!(p&&!p.test(n))&&(!(c.indexOf(n)>=0)&&(f.props.has(n)||h.indexOf(n)>=0)))}function i(n,e){return e?void(m[n]=!0):(t(n)&&l(h,n),void(r(n)||l(v,n)))}function o(n){if(!r(n))return n;var e=f.props.get(n);if(!e){do e=Ve(++f.cname);while(!t(e));f.props.set(n,e)}return e}function a(n,e){var t={};try{!function n(r){r.walk(new A(function(r){if(r instanceof Nn)return n(r.cdr),!0;if(r instanceof he)return i(r.value,e),!0;if(r instanceof Yn)return n(r.consequent),n(r.alternative),!0;throw t}))}(n)}catch(n){if(n!==t)throw n}}function u(n){return n.transform(new N(function(n){return n instanceof Nn?n.cdr=u(n.cdr):n instanceof he?n.value=o(n.value):n instanceof Yn&&(n.consequent=u(n.consequent),n.alternative=u(n.alternative)),n}))}e=s(e,{reserved:null,cache:null,only_cache:!1,regex:null,ignore_quoted:!1});var c=e.reserved;null==c&&(c=U());var f=e.cache;null==f&&(f={cname:-1,props:new _});var p=e.regex,d=e.ignore_quoted,h=[],v=[],m={};return n.walk(new A(function(n){n instanceof Zn?i(n.key,d&&n.quote):n instanceof Xn?i(n.key.name):n instanceof Rn?i(n.property):n instanceof In&&a(n.property,d)})),n.transform(new N(function(n){n instanceof Zn?d&&n.quote||(n.key=o(n.key)):n instanceof Xn?n.key.name=o(n.key.name):n instanceof Rn?n.property=o(n.property):n instanceof In&&(d||(n.property=u(n.property)))}))}u.prototype=Object.create(Error.prototype),u.prototype.constructor=u,u.croak=function(n,e){throw new u(n,e)};var V=function(){function n(n,o,a){function u(){var u=o(n[s],s),l=u instanceof r;return l&&(u=u.v),u instanceof e?(u=u.v,u instanceof t?f.push.apply(f,a?u.v.slice().reverse():u.v):f.push(u)):u!==i&&(u instanceof t?c.push.apply(c,a?u.v.slice().reverse():u.v):c.push(u)),l}var s,c=[],f=[];if(n instanceof Array)if(a){for(s=n.length;--s>=0&&!u(););c.reverse(),f.reverse()}else for(s=0;s<n.length&&!u();++s);else for(s in n)if(g(n,s)&&u())break;return f.concat(c)}function e(n){this.v=n}function t(n){this.v=n}function r(n){this.v=n}n.at_top=function(n){return new e(n)},n.splice=function(n){return new t(n)},n.last=function(n){return new r(n)};var i=n.skip={};return n}();_.prototype={set:function(n,e){return this.has(n)||++this._size,this._values["$"+n]=e,this},add:function(n,e){return this.has(n)?this.get(n).push(e):this.set(n,[e]),this},get:function(n){return this._values["$"+n]},del:function(n){return this.has(n)&&(--this._size,delete this._values["$"+n]),this},has:function(n){return"$"+n in this._values},each:function(n){for(var e in this._values)n(this._values[e],e.substr(1))},size:function(){return this._size},map:function(n){var e=[];for(var t in this._values)e.push(n(this._values[t],t.substr(1)));return e},toObject:function(){return this._values}},_.fromObject=function(n){var e=new _;return e._size=c(e._values,n),e};var Y=b("Token","type value line col pos endline endcol endpos nlb comments_before file raw",{},null),W=b("Node","start end",{clone:function(){return new this.CTOR(this)},$documentation:"Base class of all AST nodes",$propdoc:{start:"[AST_Token] The first token of this node",end:"[AST_Token] The last token of this node"},_walk:function(n){return n._visit(this)},walk:function(n){return this._walk(n)}},null);W.warn_function=null,W.warn=function(n,e){W.warn_function&&W.warn_function(p(n,e))};var G=b("Statement",null,{$documentation:"Base class of all statements"}),J=b("Debugger",null,{$documentation:"Represents a debugger statement"},G),X=b("Directive","value scope quote",{$documentation:'Represents a directive, like "use strict";',$propdoc:{value:"[string] The value of this directive as a plain string (it's not an AST_String!)",scope:"[AST_Scope/S] The scope that this directive affects",quote:"[string] the original quote character"}},G),Z=b("SimpleStatement","body",{$documentation:"A statement consisting of an expression, i.e. a = 1 + 2",$propdoc:{body:"[AST_Node] an expression node (should not be instanceof AST_Statement)"},_walk:function(n){return n._visit(this,function(){this.body._walk(n)})}},G),K=b("Block","body",{$documentation:"A body of statements (usually bracketed)",$propdoc:{body:"[AST_Statement*] an array of statements"},_walk:function(n){return n._visit(this,function(){y(this,n)})}},G),Q=b("BlockStatement",null,{$documentation:"A block statement"},K),nn=b("EmptyStatement",null,{$documentation:"The empty statement (empty block or simply a semicolon)",_walk:function(n){return n._visit(this)}},G),en=b("StatementWithBody","body",{$documentation:"Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`",$propdoc:{body:"[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement"},_walk:function(n){return n._visit(this,function(){this.body._walk(n)})}},G),tn=b("LabeledStatement","label",{$documentation:"Statement with a label",$propdoc:{label:"[AST_Label] a label definition"},_walk:function(n){return n._visit(this,function(){this.label._walk(n),this.body._walk(n)})}},en),rn=b("IterationStatement",null,{$documentation:"Internal class.  All loops inherit from it."},en),on=b("DWLoop","condition",{$documentation:"Base class for do/while statements",$propdoc:{condition:"[AST_Node] the loop condition.  Should not be instanceof AST_Statement"}},rn),an=b("Do",null,{$documentation:"A `do` statement",_walk:function(n){return n._visit(this,function(){this.body._walk(n),this.condition._walk(n)})}},on),un=b("While",null,{$documentation:"A `while` statement",_walk:function(n){return n._visit(this,function(){this.condition._walk(n),this.body._walk(n)})}},on),sn=b("For","init condition step",{$documentation:"A `for` statement",$propdoc:{init:"[AST_Node?] the `for` initialization code, or null if empty",condition:"[AST_Node?] the `for` termination clause, or null if empty",step:"[AST_Node?] the `for` update clause, or null if empty"},_walk:function(n){return n._visit(this,function(){this.init&&this.init._walk(n),this.condition&&this.condition._walk(n),this.step&&this.step._walk(n),this.body._walk(n)})}},rn),cn=b("ForIn","init name object",{$documentation:"A `for ... in` statement",$propdoc:{init:"[AST_Node] the `for/in` initialization code",
name:"[AST_SymbolRef?] the loop variable, only if `init` is AST_Var",object:"[AST_Node] the object that we're looping through"},_walk:function(n){return n._visit(this,function(){this.init._walk(n),this.object._walk(n),this.body._walk(n)})}},rn),fn=b("With","expression",{$documentation:"A `with` statement",$propdoc:{expression:"[AST_Node] the `with` expression"},_walk:function(n){return n._visit(this,function(){this.expression._walk(n),this.body._walk(n)})}},en),ln=b("Scope","directives variables functions uses_with uses_eval parent_scope enclosed cname",{$documentation:"Base class for all statements introducing a lexical scope",$propdoc:{directives:"[string*/S] an array of directives declared in this scope",variables:"[Object/S] a map of name -> SymbolDef for all variables/functions defined in this scope",functions:"[Object/S] like `variables`, but only lists function declarations",uses_with:"[boolean/S] tells whether this scope uses the `with` statement",uses_eval:"[boolean/S] tells whether this scope contains a direct call to the global `eval`",parent_scope:"[AST_Scope?/S] link to the parent scope",enclosed:"[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any subscopes",cname:"[integer/S] current index for mangling variables (used internally by the mangler)"}},K),pn=b("Toplevel","globals",{$documentation:"The toplevel scope",$propdoc:{globals:"[Object/S] a map of name -> SymbolDef for all undeclared names"},wrap_enclose:function(n){var e=this,t=[],r=[];n.forEach(function(n){var e=n.lastIndexOf(":");t.push(n.substr(0,e)),r.push(n.substr(e+1))});var i="(function("+r.join(",")+"){ '$ORIG'; })("+t.join(",")+")";return i=H(i),i=i.transform(new N(function(n){if(n instanceof X&&"$ORIG"==n.value)return V.splice(e.body)}))},wrap_commonjs:function(n,e){var t=this,r=[];e&&(t.figure_out_scope(),t.walk(new A(function(n){n instanceof te&&n.definition().global&&(o(function(e){return e.name==n.name},r)||r.push(n))})));var i="(function(exports, global){ '$ORIG'; '$EXPORTS'; global['"+n+"'] = exports; }({}, (function(){return this}())))";return i=H(i),i=i.transform(new N(function(n){if(n instanceof X)switch(n.value){case"$ORIG":return V.splice(t.body);case"$EXPORTS":var e=[];return r.forEach(function(n){e.push(new Z({body:new Wn({left:new In({expression:new fe({name:"exports"}),property:new he({value:n.name})}),operator:"=",right:new fe(n)})}))}),V.splice(e)}}))}},ln),dn=b("Lambda","name argnames uses_arguments",{$documentation:"Base class for functions",$propdoc:{name:"[AST_SymbolDeclaration?] the name of this function",argnames:"[AST_SymbolFunarg*] array of function arguments",uses_arguments:"[boolean/S] tells whether this function accesses the arguments array"},_walk:function(n){return n._visit(this,function(){this.name&&this.name._walk(n),this.argnames.forEach(function(e){e._walk(n)}),y(this,n)})}},ln),hn=b("Accessor",null,{$documentation:"A setter/getter function.  The `name` property is always null."},dn),vn=b("Function",null,{$documentation:"A function expression"},dn),mn=b("Defun",null,{$documentation:"A function definition"},dn),_n=b("Jump",null,{$documentation:"Base class for “jumps” (for now that's `return`, `throw`, `break` and `continue`)"},G),gn=b("Exit","value",{$documentation:"Base class for “exits” (`return` and `throw`)",$propdoc:{value:"[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return"},_walk:function(n){return n._visit(this,this.value&&function(){this.value._walk(n)})}},_n),bn=b("Return",null,{$documentation:"A `return` statement"},gn),yn=b("Throw",null,{$documentation:"A `throw` statement"},gn),An=b("LoopControl","label",{$documentation:"Base class for loop control statements (`break` and `continue`)",$propdoc:{label:"[AST_LabelRef?] the label, or null if none"},_walk:function(n){return n._visit(this,this.label&&function(){this.label._walk(n)})}},_n),wn=b("Break",null,{$documentation:"A `break` statement"},An),En=b("Continue",null,{$documentation:"A `continue` statement"},An),Dn=b("If","condition alternative",{$documentation:"A `if` statement",$propdoc:{condition:"[AST_Node] the `if` condition",alternative:"[AST_Statement?] the `else` part, or null if not present"},_walk:function(n){return n._visit(this,function(){this.condition._walk(n),this.body._walk(n),this.alternative&&this.alternative._walk(n)})}},en),xn=b("Switch","expression",{$documentation:"A `switch` statement",$propdoc:{expression:"[AST_Node] the `switch` “discriminant”"},_walk:function(n){return n._visit(this,function(){this.expression._walk(n),y(this,n)})}},K),kn=b("SwitchBranch",null,{$documentation:"Base class for `switch` branches"},K),Fn=b("Default",null,{$documentation:"A `default` switch branch"},kn),Cn=b("Case","expression",{$documentation:"A `case` switch branch",$propdoc:{expression:"[AST_Node] the `case` expression"},_walk:function(n){return n._visit(this,function(){this.expression._walk(n),y(this,n)})}},kn),Bn=b("Try","bcatch bfinally",{$documentation:"A `try` statement",$propdoc:{bcatch:"[AST_Catch?] the catch block, or null if not present",bfinally:"[AST_Finally?] the finally block, or null if not present"},_walk:function(n){return n._visit(this,function(){y(this,n),this.bcatch&&this.bcatch._walk(n),this.bfinally&&this.bfinally._walk(n)})}},K),Sn=b("Catch","argname",{$documentation:"A `catch` node; only makes sense as part of a `try` statement",$propdoc:{argname:"[AST_SymbolCatch] symbol for the exception"},_walk:function(n){return n._visit(this,function(){this.argname._walk(n),y(this,n)})}},K),Tn=b("Finally",null,{$documentation:"A `finally` node; only makes sense as part of a `try` statement"},K),$n=b("Definitions","definitions",{$documentation:"Base class for `var` or `const` nodes (variable declarations/initializations)",$propdoc:{definitions:"[AST_VarDef*] array of variable definitions"},_walk:function(n){return n._visit(this,function(){this.definitions.forEach(function(e){e._walk(n)})})}},G),On=b("Var",null,{$documentation:"A `var` statement"},$n),qn=b("Const",null,{$documentation:"A `const` statement"},$n),Mn=b("VarDef","name value",{$documentation:"A variable declaration; only appears in a AST_Definitions node",$propdoc:{name:"[AST_SymbolVar|AST_SymbolConst] name of the variable",value:"[AST_Node?] initializer, or null of there's no initializer"},_walk:function(n){return n._visit(this,function(){this.name._walk(n),this.value&&this.value._walk(n)})}}),zn=b("Call","expression args",{$documentation:"A function call expression",$propdoc:{expression:"[AST_Node] expression to invoke as function",args:"[AST_Node*] array of arguments"},_walk:function(n){return n._visit(this,function(){this.expression._walk(n),this.args.forEach(function(e){e._walk(n)})})}}),Hn=b("New",null,{$documentation:"An object instantiation.  Derives from a function call since it has exactly the same properties"},zn),Nn=b("Seq","car cdr",{$documentation:"A sequence expression (two comma-separated expressions)",$propdoc:{car:"[AST_Node] first element in sequence",cdr:"[AST_Node] second element in sequence"},$cons:function(n,e){var t=new Nn(n);return t.car=n,t.cdr=e,t},$from_array:function(n){if(0==n.length)return null;if(1==n.length)return n[0].clone();for(var e=null,t=n.length;--t>=0;)e=Nn.cons(n[t],e);for(var r=e;r;){if(r.cdr&&!r.cdr.cdr){r.cdr=r.cdr.car;break}r=r.cdr}return e},to_array:function(){for(var n=this,e=[];n;){if(e.push(n.car),n.cdr&&!(n.cdr instanceof Nn)){e.push(n.cdr);break}n=n.cdr}return e},add:function(n){for(var e=this;e;){if(!(e.cdr instanceof Nn)){var t=Nn.cons(e.cdr,n);return e.cdr=t}e=e.cdr}},len:function(){return this.cdr instanceof Nn?this.cdr.len()+1:2},_walk:function(n){return n._visit(this,function(){this.car._walk(n),this.cdr&&this.cdr._walk(n)})}}),jn=b("PropAccess","expression property",{$documentation:'Base class for property access expressions, i.e. `a.foo` or `a["foo"]`',$propdoc:{expression:"[AST_Node] the “container” expression",property:"[AST_Node|string] the property to access.  For AST_Dot this is always a plain string, while for AST_Sub it's an arbitrary AST_Node"}}),Rn=b("Dot",null,{$documentation:"A dotted property access expression",_walk:function(n){return n._visit(this,function(){this.expression._walk(n)})}},jn),In=b("Sub",null,{$documentation:'Index-style property access, i.e. `a["foo"]`',_walk:function(n){return n._visit(this,function(){this.expression._walk(n),this.property._walk(n)})}},jn),Pn=b("Unary","operator expression",{$documentation:"Base class for unary expressions",$propdoc:{operator:"[string] the operator",expression:"[AST_Node] expression that this unary operator applies to"},_walk:function(n){return n._visit(this,function(){this.expression._walk(n)})}}),Un=b("UnaryPrefix",null,{$documentation:"Unary prefix expression, i.e. `typeof i` or `++i`"},Pn),Ln=b("UnaryPostfix",null,{$documentation:"Unary postfix expression, i.e. `i++`"},Pn),Vn=b("Binary","left operator right",{$documentation:"Binary expression, i.e. `a + b`",$propdoc:{left:"[AST_Node] left-hand side expression",operator:"[string] the operator",right:"[AST_Node] right-hand side expression"},_walk:function(n){return n._visit(this,function(){this.left._walk(n),this.right._walk(n)})}}),Yn=b("Conditional","condition consequent alternative",{$documentation:"Conditional expression using the ternary operator, i.e. `a ? b : c`",$propdoc:{condition:"[AST_Node]",consequent:"[AST_Node]",alternative:"[AST_Node]"},_walk:function(n){return n._visit(this,function(){this.condition._walk(n),this.consequent._walk(n),this.alternative._walk(n)})}}),Wn=b("Assign",null,{$documentation:"An assignment expression — `a = b + 5`"},Vn),Gn=b("Array","elements",{$documentation:"An array literal",$propdoc:{elements:"[AST_Node*] array of elements"},_walk:function(n){return n._visit(this,function(){this.elements.forEach(function(e){e._walk(n)})})}}),Jn=b("Object","properties",{$documentation:"An object literal",$propdoc:{properties:"[AST_ObjectProperty*] array of properties"},_walk:function(n){return n._visit(this,function(){this.properties.forEach(function(e){e._walk(n)})})}}),Xn=b("ObjectProperty","key value",{$documentation:"Base class for literal object properties",$propdoc:{key:"[string] the property name converted to a string for ObjectKeyVal.  For setters and getters this is an arbitrary AST_Node.",value:"[AST_Node] property value.  For setters and getters this is an AST_Function."},_walk:function(n){return n._visit(this,function(){this.value._walk(n)})}}),Zn=b("ObjectKeyVal","quote",{$documentation:"A key: value object property",$propdoc:{quote:"[string] the original quote character"}},Xn),Kn=b("ObjectSetter",null,{$documentation:"An object setter property"},Xn),Qn=b("ObjectGetter",null,{$documentation:"An object getter property"},Xn),ne=b("Symbol","scope name thedef",{$propdoc:{name:"[string] name of this symbol",scope:"[AST_Scope/S] the current scope (not necessarily the definition scope)",thedef:"[SymbolDef/S] the definition of this symbol"},$documentation:"Base class for all symbols"}),ee=b("SymbolAccessor",null,{$documentation:"The name of a property accessor (setter/getter function)"},ne),te=b("SymbolDeclaration","init",{$documentation:"A declaration symbol (symbol in var/const, function name or argument, symbol in catch)",$propdoc:{init:"[AST_Node*/S] array of initializers for this declaration."}},ne),re=b("SymbolVar",null,{$documentation:"Symbol defining a variable"},te),ie=b("SymbolConst",null,{$documentation:"A constant declaration"},te),oe=b("SymbolFunarg",null,{$documentation:"Symbol naming a function argument"},re),ae=b("SymbolDefun",null,{$documentation:"Symbol defining a function"},te),ue=b("SymbolLambda",null,{$documentation:"Symbol naming a function expression"},te),se=b("SymbolCatch",null,{$documentation:"Symbol naming the exception in catch"},te),ce=b("Label","references",{$documentation:"Symbol naming a label (declaration)",$propdoc:{references:"[AST_LoopControl*] a list of nodes referring to this label"},initialize:function(){this.references=[],this.thedef=this}},ne),fe=b("SymbolRef",null,{$documentation:"Reference to some symbol (not definition/declaration)"},ne),le=b("LabelRef",null,{$documentation:"Reference to a label symbol"},ne),pe=b("This",null,{$documentation:"The `this` symbol"},ne),de=b("Constant",null,{$documentation:"Base class for all constants",getValue:function(){return this.value}}),he=b("String","value quote",{$documentation:"A string literal",$propdoc:{value:"[string] the contents of this string",quote:"[string] the original quote character"}},de),ve=b("Number","value literal",{$documentation:"A number literal",$propdoc:{value:"[number] the numeric value",literal:"[string] numeric value as string (optional)"}},de),me=b("RegExp","value",{$documentation:"A regexp literal",$propdoc:{value:"[RegExp] the actual regexp"}},de),_e=b("Atom",null,{$documentation:"Base class for atoms"},de),ge=b("Null",null,{$documentation:"The `null` atom",value:null},_e),be=b("NaN",null,{$documentation:"The impossible value",value:NaN},_e),ye=b("Undefined",null,{$documentation:"The `undefined` value",value:void 0},_e),Ae=b("Hole",null,{$documentation:"A hole in an array",value:void 0},_e),we=b("Infinity",null,{$documentation:"The `Infinity` value",value:1/0},_e),Ee=b("Boolean",null,{$documentation:"Base class for booleans"},_e),De=b("False",null,{$documentation:"The `false` atom",value:!1},Ee),xe=b("True",null,{$documentation:"The `true` atom",value:!0},Ee);A.prototype={_visit:function(n,e){this.push(n);var t=this.visit(n,e?function(){e.call(n)}:f);return!t&&e&&e.call(n),this.pop(n),t},parent:function(n){return this.stack[this.stack.length-2-(n||0)]},push:function(n){n instanceof dn?this.directives=Object.create(this.directives):n instanceof X&&(this.directives[n.value]=!this.directives[n.value]||"up"),this.stack.push(n)},pop:function(n){this.stack.pop(),n instanceof dn&&(this.directives=Object.getPrototypeOf(this.directives))},self:function(){return this.stack[this.stack.length-1]},find_parent:function(n){for(var e=this.stack,t=e.length;--t>=0;){var r=e[t];if(r instanceof n)return r}},has_directive:function(n){var e=this.directives[n];if(e)return e;var t=this.stack[this.stack.length-1];if(t instanceof ln)for(var r=0;r<t.body.length;++r){var i=t.body[r];if(!(i instanceof X))break;if(i.value==n)return!0}},in_boolean_context:function(){for(var n=this.stack,e=n.length,t=n[--e];e>0;){var r=n[--e];if(r instanceof Dn&&r.condition===t||r instanceof Yn&&r.condition===t||r instanceof on&&r.condition===t||r instanceof sn&&r.condition===t||r instanceof Un&&"!"==r.operator&&r.expression===t)return!0;if(!(r instanceof Vn)||"&&"!=r.operator&&"||"!=r.operator)return!1;t=r}},loopcontrol_target:function(n){var e=this.stack;if(n)for(var t=e.length;--t>=0;){var r=e[t];if(r instanceof tn&&r.label.name==n.name)return r.body}else for(var t=e.length;--t>=0;){var r=e[t];if(r instanceof xn||r instanceof rn)return r}}};var ke="break case catch const continue debugger default delete do else finally for function if in instanceof new return switch throw try typeof var void while with",Fe="false null true",Ce="abstract boolean byte char class double enum export extends final float goto implements import int interface let long native package private protected public short static super synchronized this throws transient volatile yield "+Fe+" "+ke,Be="return new delete throw else case";ke=v(ke),Ce=v(Ce),Be=v(Be),Fe=v(Fe);var Se=v(r("+-*&%=<>!?|~^")),Te=/^0x[0-9a-f]+$/i,$e=/^0[0-7]+$/,Oe=v(["in","instanceof","typeof","new","void","delete","++","--","+","-","!","~","&","|","^","*","/","%",">>","<<",">>>","<",">","<=",">=","==","===","!=","!==","?","=","+=","-=","/=","*=","%=",">>=","<<=",">>>=","|=","^=","&=","&&","||"]),qe=v(r("  \n\r\t\f\v​           \u2028\u2029  　\ufeff")),Me=v(r("\n\r\u2028\u2029")),ze=v(r("[{(,.;:")),He=v(r("[]{}(),;:")),Ne=(v(r("gmsiy")),{letter:new RegExp("[\\u0041-\\u005A\\u0061-\\u007A\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]"),digit:new RegExp("[\\u0030-\\u0039\\u0660-\\u0669\\u06F0-\\u06F9\\u07C0-\\u07C9\\u0966-\\u096F\\u09E6-\\u09EF\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0BE6-\\u0BEF\\u0C66-\\u0C6F\\u0CE6-\\u0CEF\\u0D66-\\u0D6F\\u0DE6-\\u0DEF\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u0F20-\\u0F29\\u1040-\\u1049\\u1090-\\u1099\\u17E0-\\u17E9\\u1810-\\u1819\\u1946-\\u194F\\u19D0-\\u19D9\\u1A80-\\u1A89\\u1A90-\\u1A99\\u1B50-\\u1B59\\u1BB0-\\u1BB9\\u1C40-\\u1C49\\u1C50-\\u1C59\\uA620-\\uA629\\uA8D0-\\uA8D9\\uA900-\\uA909\\uA9D0-\\uA9D9\\uA9F0-\\uA9F9\\uAA50-\\uAA59\\uABF0-\\uABF9\\uFF10-\\uFF19]"),non_spacing_mark:new RegExp("[\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065E\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0900-\\u0902\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09BC\\u09C1-\\u09C4\\u09CD\\u09E2\\u09E3\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0B01\\u0B3C\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B56\\u0B62\\u0B63\\u0B82\\u0BC0\\u0BCD\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0CBC\\u0CBF\\u0CC6\\u0CCC\\u0CCD\\u0CE2\\u0CE3\\u0D41-\\u0D44\\u0D4D\\u0D62\\u0D63\\u0DCA\\u0DD2-\\u0DD4\\u0DD6\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F90-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1B00-\\u1B03\\u1B34\\u1B36-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1DC0-\\u1DE6\\u1DFD-\\u1DFF\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F\\uA67C\\uA67D\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE26]"),space_combining_mark:new RegExp("[\\u0903\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u0982\\u0983\\u09BE-\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u09D7\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B3E\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0B57\\u0BBE\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0BD7\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0-\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0CD5\\u0CD6\\u0D02\\u0D03\\u0D3E-\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D57\\u0D82\\u0D83\\u0DCF-\\u0DD1\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0F3E\\u0F3F\\u0F7F\\u102B\\u102C\\u1031\\u1038\\u103B\\u103C\\u1056\\u1057\\u1062-\\u1064\\u1067-\\u106D\\u1083\\u1084\\u1087-\\u108C\\u108F\\u109A-\\u109C\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u19B0-\\u19C0\\u19C8\\u19C9\\u1A19-\\u1A1B\\u1A55\\u1A57\\u1A61\\u1A63\\u1A64\\u1A6D-\\u1A72\\u1B04\\u1B35\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF2\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BD-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAA7B\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]"),connector_punctuation:new RegExp("[\\u005F\\u203F\\u2040\\u2054\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF3F]")});O.prototype.toString=function(){return this.message+" (line: "+this.line+", col: "+this.col+", pos: "+this.pos+")\n\n"+this.stack};var je={},Re=v(["typeof","void","delete","--","++","!","~","-","+"]),Ie=v(["--","++"]),Pe=v(["=","+=","-=","/=","*=","%=",">>=","<<=",">>>=","|=","^=","&="]),Ue=function(n,e){for(var t=0;t<n.length;++t)for(var r=n[t],i=0;i<r.length;++i)e[r[i]]=t+1;return e}([["||"],["&&"],["|"],["^"],["&"],["==","===","!=","!=="],["<",">","<=",">=","in","instanceof"],[">>","<<",">>>"],["+","-"],["*","/","%"]],{}),Le=(t(["for","do","while","switch"]),t(["atom","num","string","regexp","name"]));N.prototype=new A,function(n){function e(e,t){e.DEFMETHOD("transform",function(e,r){var i,o;return e.push(this),e.before&&(i=e.before(this,t,r)),i===n&&(e.after?(e.stack[e.stack.length-1]=i=this,t(i,e),o=e.after(i,r),o!==n&&(i=o)):(i=this,t(i,e))),e.pop(this),i})}function t(n,e){return V(n,function(n){return n.transform(e,!0)})}e(W,f),e(tn,function(n,e){n.label=n.label.transform(e),n.body=n.body.transform(e)}),e(Z,function(n,e){n.body=n.body.transform(e)}),e(K,function(n,e){n.body=t(n.body,e)}),e(on,function(n,e){n.condition=n.condition.transform(e),n.body=n.body.transform(e)}),e(sn,function(n,e){n.init&&(n.init=n.init.transform(e)),n.condition&&(n.condition=n.condition.transform(e)),n.step&&(n.step=n.step.transform(e)),n.body=n.body.transform(e)}),e(cn,function(n,e){n.init=n.init.transform(e),n.object=n.object.transform(e),n.body=n.body.transform(e)}),e(fn,function(n,e){n.expression=n.expression.transform(e),n.body=n.body.transform(e)}),e(gn,function(n,e){n.value&&(n.value=n.value.transform(e))}),e(An,function(n,e){n.label&&(n.label=n.label.transform(e))}),e(Dn,function(n,e){n.condition=n.condition.transform(e),n.body=n.body.transform(e),n.alternative&&(n.alternative=n.alternative.transform(e))}),e(xn,function(n,e){n.expression=n.expression.transform(e),n.body=t(n.body,e)}),e(Cn,function(n,e){n.expression=n.expression.transform(e),n.body=t(n.body,e)}),e(Bn,function(n,e){n.body=t(n.body,e),n.bcatch&&(n.bcatch=n.bcatch.transform(e)),n.bfinally&&(n.bfinally=n.bfinally.transform(e))}),e(Sn,function(n,e){n.argname=n.argname.transform(e),n.body=t(n.body,e)}),e($n,function(n,e){n.definitions=t(n.definitions,e)}),e(Mn,function(n,e){n.name=n.name.transform(e),n.value&&(n.value=n.value.transform(e))}),e(dn,function(n,e){n.name&&(n.name=n.name.transform(e)),n.argnames=t(n.argnames,e),n.body=t(n.body,e)}),e(zn,function(n,e){n.expression=n.expression.transform(e),n.args=t(n.args,e)}),e(Nn,function(n,e){n.car=n.car.transform(e),n.cdr=n.cdr.transform(e)}),e(Rn,function(n,e){n.expression=n.expression.transform(e)}),e(In,function(n,e){n.expression=n.expression.transform(e),n.property=n.property.transform(e)}),e(Pn,function(n,e){n.expression=n.expression.transform(e)}),e(Vn,function(n,e){n.left=n.left.transform(e),n.right=n.right.transform(e)}),e(Yn,function(n,e){n.condition=n.condition.transform(e),n.consequent=n.consequent.transform(e),n.alternative=n.alternative.transform(e)}),e(Gn,function(n,e){n.elements=t(n.elements,e)}),e(Jn,function(n,e){n.properties=t(n.properties,e)}),e(Xn,function(n,e){n.value=n.value.transform(e)})}(),j.next_id=1,j.prototype={unmangleable:function(n){return n||(n={}),this.global&&!n.toplevel||this.undeclared||!n.eval&&(this.scope.uses_eval||this.scope.uses_with)||n.keep_fnames&&(this.orig[0]instanceof ue||this.orig[0]instanceof ae)},mangle:function(n){var e=n.cache&&n.cache.props;if(this.global&&e&&e.has(this.name))this.mangled_name=e.get(this.name);else if(!this.mangled_name&&!this.unmangleable(n)){var t=this.scope;!n.screw_ie8&&this.orig[0]instanceof ue&&(t=t.parent_scope),this.mangled_name=t.next_mangled(n,this),this.global&&e&&e.set(this.name,this.mangled_name)}}},pn.DEFMETHOD("figure_out_scope",function(n){n=s(n,{screw_ie8:!0,cache:null});var e=this,t=e.parent_scope=null,r=new _,i=null,o=!1,a=0,u=new A(function(e,s){if(n.screw_ie8&&e instanceof Sn){var c=t;return t=new ln(e),t.init_scope_vars(a),t.parent_scope=c,s(),t=c,!0}if(e instanceof ln){e.init_scope_vars(a);var c=e.parent_scope=t,f=i,l=r;return i=t=e,r=new _,++a,s(),--a,t=c,i=f,r=l,!0}if(e instanceof tn){var d=e.label;if(r.has(d.name))throw new Error(p("Label {name} defined twice",d));return r.set(d.name,d),s(),r.del(d.name),!0}if(e instanceof fn)for(var h=t;h;h=h.parent_scope)h.uses_with=!0;else if(e instanceof ne&&(e.scope=t),e instanceof ce&&(e.thedef=e,e.references=[]),e instanceof ue)i.def_function(e);else if(e instanceof ae)(e.scope=i.parent_scope).def_function(e);else if(e instanceof On)o=e.has_const_pragma();else if(e instanceof re||e instanceof ie){var v=i.def_variable(e);v.constant=e instanceof ie||o,v.init=u.parent().value}else if(e instanceof se)(n.screw_ie8?t:i).def_variable(e);else if(e instanceof le){var m=r.get(e.name);if(!m)throw new Error(p("Undefined label {name} [{line},{col}]",{name:e.name,line:e.start.line,col:e.start.col}));e.thedef=m}});e.walk(u);var c=null,f=e.globals=new _,u=new A(function(n,t){if(n instanceof dn){var r=c;return c=n,t(),c=r,!0}if(n instanceof An&&n.label)return n.label.thedef.references.push(n),!0;if(n instanceof fe){var i=n.name,o=u.parent();if("eval"==i&&o instanceof zn)for(var a=n.scope;a&&!a.uses_eval;a=a.parent_scope)a.uses_eval=!0;var s=n.scope.find_variable(i);if(n.scope instanceof dn&&"arguments"==i&&(n.scope.uses_arguments=!0),!s){var l;f.has(i)?l=f.get(i):(l=new j(e,f.size(),n),l.undeclared=!0,l.global=!0,f.set(i,l)),s=l}return n.thedef=s,(o instanceof Pn&&("++"===o.operator||"--"===o.operator)||o instanceof Wn&&o.left===n)&&(s.modified=!0),n.reference(),!0}});e.walk(u),n.cache&&(this.cname=n.cache.cname)}),ln.DEFMETHOD("init_scope_vars",function(n){this.variables=new _,this.functions=new _,this.uses_with=!1,this.uses_eval=!1,this.parent_scope=null,this.enclosed=[],this.cname=-1,this.nesting=n}),dn.DEFMETHOD("init_scope_vars",function(){ln.prototype.init_scope_vars.apply(this,arguments),this.uses_arguments=!1;var n=new Mn({name:"arguments",start:this.start,end:this.end}),e=new j(this,this.variables.size(),n);this.variables.set(n.name,e)}),fe.DEFMETHOD("reference",function(){var n=this.definition();n.references.push(this);for(var e=this.scope;e&&(l(e.enclosed,n),e!==n.scope);)e=e.parent_scope;this.frame=this.scope.nesting-n.scope.nesting}),ln.DEFMETHOD("find_variable",function(n){return n instanceof ne&&(n=n.name),this.variables.get(n)||this.parent_scope&&this.parent_scope.find_variable(n)}),ln.DEFMETHOD("def_function",function(n){this.functions.set(n.name,this.def_variable(n))}),ln.DEFMETHOD("def_variable",function(n){var e;return this.variables.has(n.name)?(e=this.variables.get(n.name),e.orig.push(n)):(e=new j(this,this.variables.size(),n),this.variables.set(n.name,e),e.global=!this.parent_scope),n.thedef=e}),ln.DEFMETHOD("next_mangled",function(n){var e=this.enclosed;n:for(;;){var t=Ve(++this.cname);if(C(t)&&!(n.except.indexOf(t)>=0)){for(var r=e.length;--r>=0;){var i=e[r],o=i.mangled_name||i.unmangleable(n)&&i.name;if(t==o)continue n}return t}}}),vn.DEFMETHOD("next_mangled",function(n,e){for(var t=e.orig[0]instanceof oe&&this.name&&this.name.definition(),r=t?t.mangled_name||t.name:null;;){
var i=dn.prototype.next_mangled.call(this,n,e);if(!r||r!=i)return i}}),ln.DEFMETHOD("references",function(n){return n instanceof ne&&(n=n.definition()),this.enclosed.indexOf(n)<0?null:n}),ne.DEFMETHOD("unmangleable",function(n){return this.definition().unmangleable(n)}),ee.DEFMETHOD("unmangleable",function(){return!0}),ce.DEFMETHOD("unmangleable",function(){return!1}),ne.DEFMETHOD("unreferenced",function(){return 0==this.definition().references.length&&!(this.scope.uses_eval||this.scope.uses_with)}),ne.DEFMETHOD("undeclared",function(){return this.definition().undeclared}),le.DEFMETHOD("undeclared",function(){return!1}),ce.DEFMETHOD("undeclared",function(){return!1}),ne.DEFMETHOD("definition",function(){return this.thedef}),ne.DEFMETHOD("global",function(){return this.definition().global}),On.DEFMETHOD("has_const_pragma",function(){var n=this.start&&this.start.comments_before,e=n&&n[n.length-1];return e&&/@const\b/.test(e.value)}),pn.DEFMETHOD("_default_mangler_options",function(n){return s(n,{except:[],eval:!1,sort:!1,toplevel:!1,screw_ie8:!0,keep_fnames:!1})}),pn.DEFMETHOD("mangle_names",function(n){n=this._default_mangler_options(n),n.except.push("arguments");var e=-1,t=[];n.cache&&this.globals.each(function(e){n.except.indexOf(e.name)<0&&t.push(e)});var r=new A(function(i,o){if(i instanceof tn){var a=e;return o(),e=a,!0}if(i instanceof ln){var u=(r.parent(),[]);return i.variables.each(function(e){n.except.indexOf(e.name)<0&&u.push(e)}),void t.push.apply(t,u)}if(i instanceof ce){var s;do s=Ve(++e);while(!C(s));return i.mangled_name=s,!0}if(n.screw_ie8&&i instanceof se)return void t.push(i.definition())});this.walk(r),t.forEach(function(e){e.mangle(n)}),n.cache&&(n.cache.cname=this.cname)}),pn.DEFMETHOD("compute_char_frequency",function(n){n=this._default_mangler_options(n);var e=new A(function(e){e instanceof de?Ve.consider(e.print_to_string()):e instanceof bn?Ve.consider("return"):e instanceof yn?Ve.consider("throw"):e instanceof En?Ve.consider("continue"):e instanceof wn?Ve.consider("break"):e instanceof J?Ve.consider("debugger"):e instanceof X?Ve.consider(e.value):e instanceof un?Ve.consider("while"):e instanceof an?Ve.consider("do while"):e instanceof Dn?(Ve.consider("if"),e.alternative&&Ve.consider("else")):e instanceof On?Ve.consider("var"):e instanceof qn?Ve.consider("const"):e instanceof dn?Ve.consider("function"):e instanceof sn?Ve.consider("for"):e instanceof cn?Ve.consider("for in"):e instanceof xn?Ve.consider("switch"):e instanceof Cn?Ve.consider("case"):e instanceof Fn?Ve.consider("default"):e instanceof fn?Ve.consider("with"):e instanceof Kn?Ve.consider("set"+e.key):e instanceof Qn?Ve.consider("get"+e.key):e instanceof Zn?Ve.consider(e.key):e instanceof Hn?Ve.consider("new"):e instanceof pe?Ve.consider("this"):e instanceof Bn?Ve.consider("try"):e instanceof Sn?Ve.consider("catch"):e instanceof Tn?Ve.consider("finally"):e instanceof ne&&e.unmangleable(n)?Ve.consider(e.name):e instanceof Pn||e instanceof Vn?Ve.consider(e.operator):e instanceof Rn&&Ve.consider(e.property)});this.walk(e),Ve.sort()});var Ve=function(){function n(){r=Object.create(null),t=i.split("").map(function(n){return n.charCodeAt(0)}),t.forEach(function(n){r[n]=0})}function e(n){var e="",r=54;n++;do n--,e+=String.fromCharCode(t[n%r]),n=Math.floor(n/r),r=64;while(n>0);return e}var t,r,i="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_0123456789";return e.consider=function(n){for(var e=n.length;--e>=0;){var t=n.charCodeAt(e);t in r&&++r[t]}},e.sort=function(){t=h(t,function(n,e){return E(n)&&!E(e)?1:E(e)&&!E(n)?-1:r[e]-r[n]})},e.reset=n,n(),e.get=function(){return t},e.freq=function(){return r},e}();pn.DEFMETHOD("scope_warnings",function(n){n=s(n,{undeclared:!1,unreferenced:!0,assign_to_global:!0,func_arguments:!0,nested_defuns:!0,eval:!0});var e=new A(function(t){if(n.undeclared&&t instanceof fe&&t.undeclared()&&W.warn("Undeclared symbol: {name} [{file}:{line},{col}]",{name:t.name,file:t.start.file,line:t.start.line,col:t.start.col}),n.assign_to_global){var r=null;t instanceof Wn&&t.left instanceof fe?r=t.left:t instanceof cn&&t.init instanceof fe&&(r=t.init),r&&(r.undeclared()||r.global()&&r.scope!==r.definition().scope)&&W.warn("{msg}: {name} [{file}:{line},{col}]",{msg:r.undeclared()?"Accidental global?":"Assignment to global",name:r.name,file:r.start.file,line:r.start.line,col:r.start.col})}n.eval&&t instanceof fe&&t.undeclared()&&"eval"==t.name&&W.warn("Eval is used [{file}:{line},{col}]",t.start),n.unreferenced&&(t instanceof te||t instanceof ce)&&!(t instanceof se)&&t.unreferenced()&&W.warn("{type} {name} is declared but not referenced [{file}:{line},{col}]",{type:t instanceof ce?"Label":"Symbol",name:t.name,file:t.start.file,line:t.start.line,col:t.start.col}),n.func_arguments&&t instanceof dn&&t.uses_arguments&&W.warn("arguments used in function {name} [{file}:{line},{col}]",{name:t.name?t.name.name:"anonymous",file:t.start.file,line:t.start.line,col:t.start.col}),n.nested_defuns&&t instanceof mn&&!(e.parent()instanceof ln)&&W.warn('Function {name} declared in nested statement "{type}" [{file}:{line},{col}]',{name:t.name.name,type:e.parent().TYPE,file:t.start.file,line:t.start.line,col:t.start.col})});this.walk(e)});var Ye=/^$|[;{][\s\n]*$/;!function(){function n(n,e){n.DEFMETHOD("_codegen",e)}function e(n,t){Array.isArray(n)?n.forEach(function(n){e(n,t)}):n.DEFMETHOD("needs_parens",t)}function t(n,e,t,r){var i=n.length-1;_=r,n.forEach(function(n,r){_!==!0||n instanceof X||n instanceof nn||n instanceof Z&&n.body instanceof he||(_=!1),n instanceof nn||(t.indent(),n.print(t),r==i&&e||(t.newline(),e&&t.newline())),_===!0&&n instanceof Z&&n.body instanceof he&&(_=!1)}),_=!1}function r(n,e,r){n.length>0?e.with_block(function(){t(n,!1,e,r)}):e.print("{}")}function i(n,e){if(e.option("bracketize"))return void d(n.body,e);if(!n.body)return e.force_semicolon();if(n.body instanceof an)return void d(n.body,e);for(var t=n.body;;)if(t instanceof Dn){if(!t.alternative)return void d(n.body,e);t=t.alternative}else{if(!(t instanceof en))break;t=t.body}u(n.body,e)}function o(n,e,t){if(t)try{n.walk(new A(function(n){if(n instanceof Vn&&"in"==n.operator)throw e})),n.print(e)}catch(t){if(t!==e)throw t;n.print(e,!0)}else n.print(e)}function a(n){return[92,47,46,43,42,63,40,41,91,93,123,125,36,94,58,124,33,10,13,0,65279,8232,8233].indexOf(n)<0}function u(n,e){e.option("bracketize")?!n||n instanceof nn?e.print("{}"):n instanceof Q?n.print(e):e.with_block(function(){e.indent(),n.print(e),e.newline()}):!n||n instanceof nn?e.force_semicolon():n.print(e)}function s(n){for(var e=n.stack(),t=e.length,r=e[--t],i=e[--t];t>0;){if(i instanceof G&&i.body===r)return!0;if(!(i instanceof Nn&&i.car===r||i instanceof zn&&i.expression===r&&!(i instanceof Hn)||i instanceof Rn&&i.expression===r||i instanceof In&&i.expression===r||i instanceof Yn&&i.condition===r||i instanceof Vn&&i.left===r||i instanceof Ln&&i.expression===r))return!1;r=i,i=e[--t]}}function c(n,e){return n.args.length>0||e.option("beautify")}function l(n){for(var e=n[0],t=e.length,r=1;r<n.length;++r)n[r].length<t&&(e=n[r],t=e.length);return e}function p(n){var e,t=n.toString(10),r=[t.replace(/^0\./,".").replace("e+","e")];return Math.floor(n)===n?(n>=0?r.push("0x"+n.toString(16).toLowerCase(),"0"+n.toString(8)):r.push("-0x"+(-n).toString(16).toLowerCase(),"-0"+(-n).toString(8)),(e=/^(.*?)(0+)$/.exec(n))&&r.push(e[1]+"e"+e[2].length)):(e=/^0?\.(0+)(.*)$/.exec(n))&&r.push(e[2]+"e-"+(e[1].length+e[2].length),t.substr(t.indexOf("."))),l(r)}function d(n,e){return n instanceof Q?void n.print(e):void e.with_block(function(){e.indent(),n.print(e),e.newline()})}function h(n,e){n.DEFMETHOD("add_source_map",function(n){e(this,n)})}function v(n,e){e.add_mapping(n.start)}var m=!1,_=!1;W.DEFMETHOD("print",function(n,e){function t(){r.add_comments(n),r.add_source_map(n),i(r,n)}var r=this,i=r._codegen,o=m;r instanceof X&&"use asm"==r.value&&n.parent()instanceof ln&&(m=!0),n.push_node(r),e||r.needs_parens(n)?n.with_parens(t):t(),n.pop_node(),r instanceof ln&&(m=o)}),W.DEFMETHOD("print_to_string",function(n){var e=R(n);return n||(e._readonly=!0),this.print(e),e.get()}),W.DEFMETHOD("add_comments",function(n){if(!n._readonly){var e=this,t=e.start;if(t&&!t._comments_dumped){t._comments_dumped=!0;var r=t.comments_before||[];e instanceof gn&&e.value&&e.value.walk(new A(function(n){if(n.start&&n.start.comments_before&&(r=r.concat(n.start.comments_before),n.start.comments_before=[]),n instanceof vn||n instanceof Gn||n instanceof Jn)return!0})),r=r.filter(n.option("comments"),e),!n.option("beautify")&&r.length>0&&/comment[134]/.test(r[0].type)&&0!==n.col()&&r[0].nlb&&n.print("\n"),r.forEach(function(e){/comment[134]/.test(e.type)?(n.print("//"+e.value+"\n"),n.indent()):"comment2"==e.type?(n.print("/*"+e.value+"*/"),t.nlb?(n.print("\n"),n.indent()):n.space()):0===n.pos()&&"comment5"==e.type&&n.option("shebang")&&(n.print("#!"+e.value+"\n"),n.indent())})}}}),e(W,function(){return!1}),e(vn,function(n){if(s(n))return!0;if(n.option("wrap_iife")){var e=n.parent();return e instanceof zn&&e.expression===this}return!1}),e(Jn,function(n){return s(n)}),e([Pn,ye],function(n){var e=n.parent();return e instanceof jn&&e.expression===this||e instanceof zn&&e.expression===this}),e(Nn,function(n){var e=n.parent();return e instanceof zn||e instanceof Pn||e instanceof Vn||e instanceof Mn||e instanceof jn||e instanceof Gn||e instanceof Xn||e instanceof Yn}),e(Vn,function(n){var e=n.parent();if(e instanceof zn&&e.expression===this)return!0;if(e instanceof Pn)return!0;if(e instanceof jn&&e.expression===this)return!0;if(e instanceof Vn){var t=e.operator,r=Ue[t],i=this.operator,o=Ue[i];if(r>o||r==o&&this===e.right)return!0}}),e(jn,function(n){var e=n.parent();if(e instanceof Hn&&e.expression===this)try{this.walk(new A(function(n){if(n instanceof zn)throw e}))}catch(n){if(n!==e)throw n;return!0}}),e(zn,function(n){var e,t=n.parent();return t instanceof Hn&&t.expression===this||this.expression instanceof vn&&t instanceof jn&&t.expression===this&&(e=n.parent(1))instanceof Wn&&e.left===t}),e(Hn,function(n){var e=n.parent();if(!c(this,n)&&(e instanceof jn||e instanceof zn&&e.expression===this))return!0}),e(ve,function(n){var e=n.parent();if(e instanceof jn&&e.expression===this){var t=this.getValue();if(t<0||/^0/.test(p(t)))return!0}}),e([Wn,Yn],function(n){var e=n.parent();return e instanceof Pn||(e instanceof Vn&&!(e instanceof Wn)||(e instanceof zn&&e.expression===this||(e instanceof Yn&&e.condition===this||(e instanceof jn&&e.expression===this||void 0))))}),n(X,function(n,e){e.print_string(n.value,n.quote),e.semicolon()}),n(J,function(n,e){e.print("debugger"),e.semicolon()}),en.DEFMETHOD("_do_print_body",function(n){u(this.body,n)}),n(G,function(n,e){n.body.print(e),e.semicolon()}),n(pn,function(n,e){t(n.body,!0,e,!0),e.print("")}),n(tn,function(n,e){n.label.print(e),e.colon(),n.body.print(e)}),n(Z,function(n,e){n.body.print(e),e.semicolon()}),n(Q,function(n,e){r(n.body,e)}),n(nn,function(n,e){e.semicolon()}),n(an,function(n,e){e.print("do"),e.space(),n._do_print_body(e),e.space(),e.print("while"),e.space(),e.with_parens(function(){n.condition.print(e)}),e.semicolon()}),n(un,function(n,e){e.print("while"),e.space(),e.with_parens(function(){n.condition.print(e)}),e.space(),n._do_print_body(e)}),n(sn,function(n,e){e.print("for"),e.space(),e.with_parens(function(){!n.init||n.init instanceof nn?e.print(";"):(n.init instanceof $n?n.init.print(e):o(n.init,e,!0),e.print(";"),e.space()),n.condition?(n.condition.print(e),e.print(";"),e.space()):e.print(";"),n.step&&n.step.print(e)}),e.space(),n._do_print_body(e)}),n(cn,function(n,e){e.print("for"),e.space(),e.with_parens(function(){n.init.print(e),e.space(),e.print("in"),e.space(),n.object.print(e)}),e.space(),n._do_print_body(e)}),n(fn,function(n,e){e.print("with"),e.space(),e.with_parens(function(){n.expression.print(e)}),e.space(),n._do_print_body(e)}),dn.DEFMETHOD("_do_print",function(n,e){var t=this;e||n.print("function"),t.name&&(n.space(),t.name.print(n)),n.with_parens(function(){t.argnames.forEach(function(e,t){t&&n.comma(),e.print(n)})}),n.space(),r(t.body,n,!0)}),n(dn,function(n,e){n._do_print(e)}),gn.DEFMETHOD("_do_print",function(n,e){n.print(e),this.value&&(n.space(),this.value.print(n)),n.semicolon()}),n(bn,function(n,e){n._do_print(e,"return")}),n(yn,function(n,e){n._do_print(e,"throw")}),An.DEFMETHOD("_do_print",function(n,e){n.print(e),this.label&&(n.space(),this.label.print(n)),n.semicolon()}),n(wn,function(n,e){n._do_print(e,"break")}),n(En,function(n,e){n._do_print(e,"continue")}),n(Dn,function(n,e){e.print("if"),e.space(),e.with_parens(function(){n.condition.print(e)}),e.space(),n.alternative?(i(n,e),e.space(),e.print("else"),e.space(),u(n.alternative,e)):n._do_print_body(e)}),n(xn,function(n,e){e.print("switch"),e.space(),e.with_parens(function(){n.expression.print(e)}),e.space(),n.body.length>0?e.with_block(function(){n.body.forEach(function(n,t){t&&e.newline(),e.indent(!0),n.print(e)})}):e.print("{}")}),kn.DEFMETHOD("_do_print_body",function(n){this.body.length>0&&(n.newline(),this.body.forEach(function(e){n.indent(),e.print(n),n.newline()}))}),n(Fn,function(n,e){e.print("default:"),n._do_print_body(e)}),n(Cn,function(n,e){e.print("case"),e.space(),n.expression.print(e),e.print(":"),n._do_print_body(e)}),n(Bn,function(n,e){e.print("try"),e.space(),r(n.body,e),n.bcatch&&(e.space(),n.bcatch.print(e)),n.bfinally&&(e.space(),n.bfinally.print(e))}),n(Sn,function(n,e){e.print("catch"),e.space(),e.with_parens(function(){n.argname.print(e)}),e.space(),r(n.body,e)}),n(Tn,function(n,e){e.print("finally"),e.space(),r(n.body,e)}),$n.DEFMETHOD("_do_print",function(n,e){n.print(e),n.space(),this.definitions.forEach(function(e,t){t&&n.comma(),e.print(n)});var t=n.parent(),r=t instanceof sn||t instanceof cn,i=r&&t.init===this;i||n.semicolon()}),n(On,function(n,e){n._do_print(e,"var")}),n(qn,function(n,e){n._do_print(e,"const")}),n(Mn,function(n,e){if(n.name.print(e),n.value){e.space(),e.print("="),e.space();var t=e.parent(1),r=t instanceof sn||t instanceof cn;o(n.value,e,r)}}),n(zn,function(n,e){n.expression.print(e),n instanceof Hn&&!c(n,e)||e.with_parens(function(){n.args.forEach(function(n,t){t&&e.comma(),n.print(e)})})}),n(Hn,function(n,e){e.print("new"),e.space(),zn.prototype._codegen(n,e)}),Nn.DEFMETHOD("_do_print",function(n){this.car.print(n),this.cdr&&(n.comma(),n.should_break()&&(n.newline(),n.indent()),this.cdr.print(n))}),n(Nn,function(n,e){n._do_print(e)}),n(Rn,function(n,e){var t=n.expression;t.print(e),t instanceof ve&&t.getValue()>=0&&(/[xa-f.)]/i.test(e.last())||e.print(".")),e.print("."),e.add_mapping(n.end),e.print_name(n.property)}),n(In,function(n,e){n.expression.print(e),e.print("["),n.property.print(e),e.print("]")}),n(Un,function(n,e){var t=n.operator;e.print(t),(/^[a-z]/i.test(t)||/[+-]$/.test(t)&&n.expression instanceof Un&&/^[+-]/.test(n.expression.operator))&&e.space(),n.expression.print(e)}),n(Ln,function(n,e){n.expression.print(e),e.print(n.operator)}),n(Vn,function(n,e){var t=n.operator;n.left.print(e),">"==t[0]&&n.left instanceof Ln&&"--"==n.left.operator?e.print(" "):e.space(),e.print(t),("<"==t||"<<"==t)&&n.right instanceof Un&&"!"==n.right.operator&&n.right.expression instanceof Un&&"--"==n.right.expression.operator?e.print(" "):e.space(),n.right.print(e)}),n(Yn,function(n,e){n.condition.print(e),e.space(),e.print("?"),e.space(),n.consequent.print(e),e.space(),e.colon(),n.alternative.print(e)}),n(Gn,function(n,e){e.with_square(function(){var t=n.elements,r=t.length;r>0&&e.space(),t.forEach(function(n,t){t&&e.comma(),n.print(e),t===r-1&&n instanceof Ae&&e.comma()}),r>0&&e.space()})}),n(Jn,function(n,e){n.properties.length>0?e.with_block(function(){n.properties.forEach(function(n,t){t&&(e.print(","),e.newline()),e.indent(),n.print(e)}),e.newline()}):e.print("{}")}),n(Zn,function(n,e){var t=n.key,r=n.quote;e.option("quote_keys")?e.print_string(t+""):("number"==typeof t||!e.option("beautify")&&+t+""==t)&&parseFloat(t)>=0?e.print(p(t)):(Ce(t)?e.option("screw_ie8"):T(t))?r&&e.option("keep_quoted_props")?e.print_string(t,r):e.print_name(t):e.print_string(t,r),e.colon(),n.value.print(e)}),n(Kn,function(n,e){e.print("set"),e.space(),n.key.print(e),n.value._do_print(e,!0)}),n(Qn,function(n,e){e.print("get"),e.space(),n.key.print(e),n.value._do_print(e,!0)}),n(ne,function(n,e){var t=n.definition();e.print_name(t?t.mangled_name||t.name:n.name)}),n(ye,function(n,e){e.print("void 0")}),n(Ae,f),n(we,function(n,e){e.print("Infinity")}),n(be,function(n,e){e.print("NaN")}),n(pe,function(n,e){e.print("this")}),n(de,function(n,e){e.print(n.getValue())}),n(he,function(n,e){e.print_string(n.getValue(),n.quote,_)}),n(ve,function(n,e){m&&n.start&&null!=n.start.raw?e.print(n.start.raw):e.print(p(n.getValue()))}),n(me,function(n,e){var t=n.getValue().toString();e.option("ascii_only")?t=e.to_ascii(t):e.option("unescape_regexps")&&(t=t.split("\\\\").map(function(n){return n.replace(/\\u[0-9a-fA-F]{4}|\\x[0-9a-fA-F]{2}/g,function(n){var e=parseInt(n.substr(2),16);return a(e)?String.fromCharCode(e):n})}).join("\\\\")),e.print(t);var r=e.parent();r instanceof Vn&&/^in/.test(r.operator)&&r.left===n&&e.print(" ")}),h(W,f),h(X,v),h(J,v),h(ne,v),h(_n,v),h(en,v),h(tn,f),h(dn,v),h(xn,v),h(kn,v),h(Q,v),h(pn,f),h(Hn,v),h(Bn,v),h(Sn,v),h(Tn,v),h($n,v),h(de,v),h(Kn,function(n,e){e.add_mapping(n.start,n.key.name)}),h(Qn,function(n,e){e.add_mapping(n.start,n.key.name)}),h(Xn,function(n,e){e.add_mapping(n.start,n.key)})}(),I.prototype=new N,c(I.prototype,{option:function(n){return this.options[n]},compress:function(n){for(var e=+this.options.passes||1,t=0;t<e&&t<3;++t)t>0&&n.clear_opt_flags(),n=n.transform(this);return n},warn:function(n,e){if(this.options.warnings){var t=p(n,e);t in this.warnings_produced||(this.warnings_produced[t]=!0,W.warn.apply(W,arguments))}},clear_warnings:function(){this.warnings_produced={}},before:function(n,e,t){if(n._squeezed)return n;var r=!1;return n instanceof ln&&(n=n.hoist_declarations(this),r=!0),e(n,this),n=n.optimize(this),r&&n instanceof ln&&(n.drop_unused(this),e(n,this)),n._squeezed=!0,n}}),function(){function n(n,e){n.DEFMETHOD("optimize",function(n){var t=this;if(t._optimized)return t;if(n.has_directive("use asm"))return t;var r=e(t,n);return r._optimized=!0,r===t?r:r.transform(n)})}function e(n,e,t){return t||(t={}),e&&(t.start||(t.start=e.start),t.end||(t.end=e.end)),new n(t)}function t(n,t,r){if(t instanceof W)return t.transform(n);switch(typeof t){case"string":return e(he,r,{value:t}).optimize(n);case"number":return isNaN(t)?e(be,r):1/t<0?e(Un,r,{operator:"-",expression:e(ve,r,{value:-t})}):e(ve,r,{value:t}).optimize(n);case"boolean":return e(t?xe:De,r).optimize(n);case"undefined":return e(ye,r).optimize(n);default:if(null===t)return e(ge,r,{value:null}).optimize(n);if(t instanceof RegExp)return e(me,r,{value:t}).optimize(n);throw new Error(p("Can't handle constant of type: {type}",{type:typeof t}))}}function r(n,t,r){return n instanceof zn&&n.expression===t&&(r instanceof jn||r instanceof fe&&"eval"===r.name)?e(Nn,t,{car:e(ve,t,{value:0}),cdr:r}):r}function a(n){if(null===n)return[];if(n instanceof Q)return n.body;if(n instanceof nn)return[];if(n instanceof G)return[n];throw new Error("Can't convert thing to statement array")}function u(n){return null===n||(n instanceof nn||n instanceof Q&&0==n.body.length)}function s(n){return n instanceof xn?n:(n instanceof sn||n instanceof cn||n instanceof on)&&n.body instanceof Q?n.body:n}function c(n,t){function i(n,t){function o(n,e){return n instanceof fe&&(e instanceof Wn&&n===e.left||e instanceof Pn&&e.expression===n&&("++"==e.operator||"--"==e.operator))}function a(i,a,c){if(o(i,a))return i;var p=r(a,i,y.value);return y.value=null,d.splice(g,1),0===d.length&&(n[l]=e(nn,u),s=!0),f.clear_opt_flags(),t.warn("Replacing "+(c?"constant":"variable")+" "+w+" [{file}:{line},{col}]",i.start),b=!0,p}for(var u=t.self(),s=!1,c=n.length;--c>=0;){var f=n[c];if(!(f instanceof $n)){if([f,f.body,f.alternative,f.bcatch,f.bfinally].forEach(function(n){n&&n.body&&i(n.body,t)}),c<=0)break;var l=c-1,p=n[l];if(p instanceof $n){var d=p.definitions;if(null!=d)for(var h={},v=!1,m=!1,_={},g=d.length;--g>=0;){var y=d[g];if(null==y.value)break;var w=y.name.name;if(!w||!w.length)break;if(w in h)break;h[w]=!0;var E=u.find_variable&&u.find_variable(w);if(E&&E.references&&1===E.references.length&&"arguments"!=w){var D=E.references[0];if(D.scope.uses_eval||D.scope.uses_with)break;if(y.value instanceof me||!y.value.is_constant(t)){if(!(v|=m))if(D.scope===u){var x=new A(function(n){n instanceof fe&&o(n,x.parent())&&(_[n.name]=m=!0)});y.value.walk(x);var k=!1,F=new N(function(n){if(k)return n;var e=F.parent();return n instanceof dn||n instanceof Bn||n instanceof fn||n instanceof Cn||n instanceof rn||e instanceof Dn&&n!==e.condition||e instanceof Yn&&n!==e.condition||e instanceof Vn&&("&&"==e.operator||"||"==e.operator)&&n===e.right||e instanceof xn&&n!==e.expression?(v=k=!0,n):void 0},function(n){return k?n:n===D?(k=!0,a(n,F.parent(),!1)):(v|=n.has_side_effects(t))?(k=!0,n):m&&n instanceof fe&&n.name in _?(v=!0,k=!0,n):void 0});f.transform(F)}else v|=y.value.has_side_effects(t)}else{var C=new N(function(n){if(n===D)return a(n,C.parent(),!0)});f.transform(C)}}else v=!0}}}}if(s)for(var B=n.length;--B>=0;)n.length>1&&n[B]instanceof nn&&n.splice(B,1);return n}function o(n){function r(n){return/@ngInject/.test(n.value)}function i(n){return n.argnames.map(function(n){return e(he,n,{value:n.name})})}function o(n,t){return e(Gn,n,{elements:t})}function a(n,t){return e(Z,n,{body:e(Wn,n,{operator:"=",left:e(Rn,t,{expression:e(fe,t,t),property:"$inject"}),right:o(n,i(n))})})}function u(n){n&&n.args&&(n.args.forEach(function(n,e,t){var a=n.start.comments_before;n instanceof dn&&a.length&&r(a[0])&&(t[e]=o(n,i(n).concat(n)))}),n.expression&&n.expression.expression&&u(n.expression.expression))}return n.reduce(function(n,e){if(n.push(e),e.body&&e.body.args)u(e.body);else{var i=e.start,o=i.comments_before;if(o&&o.length>0){var s=o.pop();r(s)&&(e instanceof mn?n.push(a(e,e.name)):e instanceof $n?e.definitions.forEach(function(e){e.value&&e.value instanceof dn&&n.push(a(e.value,e.name))}):t.warn("Unknown statement marked with @ngInject [{file}:{line},{col}]",i))}}return n},[])}function u(n){var e=[];return n.reduce(function(n,t){return t instanceof Q?(b=!0,n.push.apply(n,u(t.body))):t instanceof nn?b=!0:t instanceof X?e.indexOf(t.value)<0?(n.push(t),e.push(t.value)):b=!0:n.push(t),n},[])}function c(n,t){function r(n){for(var e=0,t=n.length;--t>=0;){var r=n[t];if(r instanceof Dn&&r.body instanceof bn&&++e>1)return!0}return!1}var i=t.self(),o=r(n),u=i instanceof dn,c=[];n:for(var l=n.length;--l>=0;){var p=n[l];switch(!0){case u&&p instanceof bn&&!p.value&&0==c.length:b=!0;continue n;case p instanceof Dn:if(p.body instanceof bn){if((u&&0==c.length||c[0]instanceof bn&&!c[0].value)&&!p.body.value&&!p.alternative){b=!0;var h=e(Z,p.condition,{body:p.condition});c.unshift(h);continue n}if(c[0]instanceof bn&&p.body.value&&c[0].value&&!p.alternative){b=!0,p=p.clone(),p.alternative=c[0],c[0]=p.transform(t);continue n}if(o&&(0==c.length||c[0]instanceof bn)&&p.body.value&&!p.alternative&&u){b=!0,p=p.clone(),p.alternative=c[0]||e(bn,p,{value:e(ye,p)}),c[0]=p.transform(t);continue n}if(!p.body.value&&u){b=!0,p=p.clone(),p.condition=p.condition.negate(t);var v=a(p.alternative).concat(c),m=f(v);p.body=e(Q,p,{body:v}),p.alternative=null,c=m.concat([p.transform(t)]);continue n}if(t.option("sequences")&&1==c.length&&u&&c[0]instanceof Z&&(!p.alternative||p.alternative instanceof Z)){b=!0,c.push(e(bn,c[0],{value:e(ye,c[0])}).transform(t)),c=a(p.alternative).concat(c),c.unshift(p);continue n}}var _=y(p.body),g=_ instanceof An?t.loopcontrol_target(_.label):null;if(_&&(_ instanceof bn&&!_.value&&u||_ instanceof En&&i===s(g)||_ instanceof wn&&g instanceof Q&&i===g)){_.label&&d(_.label.thedef.references,_),b=!0;var v=a(p.body).slice(0,-1);p=p.clone(),p.condition=p.condition.negate(t),p.body=e(Q,p,{body:a(p.alternative).concat(c)}),p.alternative=e(Q,p,{body:v}),c=[p.transform(t)];continue n}var _=y(p.alternative),g=_ instanceof An?t.loopcontrol_target(_.label):null;if(_&&(_ instanceof bn&&!_.value&&u||_ instanceof En&&i===s(g)||_ instanceof wn&&g instanceof Q&&i===g)){_.label&&d(_.label.thedef.references,_),b=!0,p=p.clone(),p.body=e(Q,p.body,{body:a(p.body).concat(c)}),p.alternative=e(Q,p.alternative,{body:a(p.alternative).slice(0,-1)}),c=[p.transform(t)];continue n}c.unshift(p);break;default:c.unshift(p)}}return c}function p(n,e){var t=!1,r=n.length,i=e.self();return n=n.reduce(function(n,r){if(t)l(e,r,n);else{if(r instanceof An){var o=e.loopcontrol_target(r.label);r instanceof wn&&o instanceof Q&&s(o)===i||r instanceof En&&s(o)===i?r.label&&d(r.label.thedef.references,r):n.push(r)}else n.push(r);y(r)&&(t=!0)}return n},[]),b=n.length!=r,n}function h(n,t){function r(){i=Nn.from_array(i),i&&o.push(e(Z,i,{body:i})),i=[]}if(n.length<2)return n;var i=[],o=[];return n.forEach(function(n){n instanceof Z&&v(i)<t.sequences_limit?i.push(n.body):(r(),o.push(n))}),r(),o=m(o,t),b=o.length!=n.length,o}function v(n){for(var e=0,t=0;t<n.length;++t){var r=n[t];r instanceof Nn?e+=r.len():e++}return e}function m(n,t){function r(n){i.pop();var e=o.body;return e instanceof Nn?e.add(n):e=Nn.cons(e,n),e.transform(t)}var i=[],o=null;return n.forEach(function(n){if(o)if(n instanceof sn){var t={};try{o.body.walk(new A(function(n){if(n instanceof Vn&&"in"==n.operator)throw t})),!n.init||n.init instanceof $n?n.init||(n.init=o.body,i.pop()):n.init=r(n.init)}catch(n){if(n!==t)throw n}}else n instanceof Dn?n.condition=r(n.condition):n instanceof fn?n.expression=r(n.expression):n instanceof gn&&n.value?n.value=r(n.value):n instanceof gn?n.value=r(e(ye,n)):n instanceof xn&&(n.expression=r(n.expression));i.push(n),o=n instanceof Z?n:null}),i}function _(n,e){var t=null;return n.reduce(function(n,e){return e instanceof $n&&t&&t.TYPE==e.TYPE?(t.definitions=t.definitions.concat(e.definitions),b=!0):e instanceof sn&&t instanceof On&&(!e.init||e.init.TYPE==t.TYPE)?(b=!0,n.pop(),e.init?e.init.definitions=t.definitions.concat(e.init.definitions):e.init=t,n.push(e),t=e):(t=e,n.push(e)),n},[])}function g(n,t){function r(n){return n instanceof zn&&(n.expression instanceof vn||r(n.expression))}n.forEach(function(n){n instanceof Z&&(n.body=function n(t){return t.transform(new N(function(t){if(t instanceof Hn)return t;if(r(t))return e(Un,t,{operator:"!",expression:t});if(t instanceof zn)t.expression=n(t.expression);else if(t instanceof Nn)t.car=n(t.car);else if(t instanceof Yn){var i=n(t.condition);if(i!==t.condition){t.condition=i;var o=t.consequent;t.consequent=t.alternative,t.alternative=o}}return t}))}(n.body))})}var b,w=10;do b=!1,t.option("angular")&&(n=o(n)),n=u(n),t.option("dead_code")&&(n=p(n,t)),t.option("if_return")&&(n=c(n,t)),t.sequences_limit>0&&(n=h(n,t)),t.option("join_vars")&&(n=_(n,t)),t.option("collapse_vars")&&(n=i(n,t));while(b&&w-- >0);return t.option("negate_iife")&&g(n,t),n}function f(n){for(var e=[],t=n.length-1;t>=0;--t){var r=n[t];r instanceof mn&&(n.splice(t,1),e.unshift(r))}return e}function l(n,e,t){e instanceof mn||n.warn("Dropping unreachable code [{file}:{line},{col}]",e.start),e.walk(new A(function(e){return e instanceof $n?(n.warn("Declarations in unreachable code! [{file}:{line},{col}]",e.start),e.remove_initializers(),t.push(e),!0):e instanceof mn?(t.push(e),!0):e instanceof ln||void 0}))}function b(n,e){return n.print_to_string().length>e.print_to_string().length?e:n}function y(n){return n&&n.aborts()}function w(n,t){function r(r){r=a(r),n.body instanceof Q?(n.body=n.body.clone(),n.body.body=r.concat(n.body.body.slice(1)),n.body=n.body.transform(t)):n.body=e(Q,n.body,{body:r}).transform(t),w(n,t)}var i=n.body instanceof Q?n.body.body[0]:n.body;i instanceof Dn&&(i.body instanceof wn&&t.loopcontrol_target(i.body.label)===n?(n.condition?n.condition=e(Vn,n.condition,{left:n.condition,operator:"&&",right:i.condition.negate(t)}):n.condition=i.condition.negate(t),r(i.alternative)):i.alternative instanceof wn&&t.loopcontrol_target(i.alternative.label)===n&&(n.condition?n.condition=e(Vn,n.condition,{left:n.condition,operator:"&&",right:i.condition}):n.condition=i.condition,r(i.body)))}function E(n,e){var t=e.option("pure_getters");e.options.pure_getters=!1;var r=n.has_side_effects(e);return e.options.pure_getters=t,r}function D(n,t){return t.option("booleans")&&t.in_boolean_context()&&!n.has_side_effects(t)?e(xe,n):n}n(W,function(n,e){return n}),W.DEFMETHOD("equivalent_to",function(n){return this.print_to_string()==n.print_to_string()}),W.DEFMETHOD("clear_opt_flags",function(){this.walk(new A(function(n){n instanceof X||n instanceof de||(n._squeezed=!1,n._optimized=!1)}))}),function(n){var e=["!","delete"],t=["in","instanceof","==","!=","===","!==","<","<=",">=",">"];n(W,function(){return!1}),n(Un,function(){return i(this.operator,e)}),n(Vn,function(){return i(this.operator,t)||("&&"==this.operator||"||"==this.operator)&&this.left.is_boolean()&&this.right.is_boolean()}),n(Yn,function(){return this.consequent.is_boolean()&&this.alternative.is_boolean()}),n(Wn,function(){return"="==this.operator&&this.right.is_boolean()}),n(Nn,function(){return this.cdr.is_boolean()}),n(xe,function(){return!0}),n(De,function(){return!0})}(function(n,e){n.DEFMETHOD("is_boolean",e)}),function(n){n(W,function(){return!1}),n(he,function(){return!0}),n(Un,function(){return"typeof"==this.operator}),n(Vn,function(n){return"+"==this.operator&&(this.left.is_string(n)||this.right.is_string(n))}),n(Wn,function(n){return("="==this.operator||"+="==this.operator)&&this.right.is_string(n)}),n(Nn,function(n){return this.cdr.is_string(n)}),n(Yn,function(n){return this.consequent.is_string(n)&&this.alternative.is_string(n)}),n(zn,function(n){return n.option("unsafe")&&this.expression instanceof fe&&"String"==this.expression.name&&this.expression.undeclared()})}(function(n,e){n.DEFMETHOD("is_string",e)}),function(n){function e(n,e){if(!e)throw new Error("Compressor must be passed");return n._eval(e)}W.DEFMETHOD("evaluate",function(e){if(!e.option("evaluate"))return[this];try{var r=this._eval(e);return[b(t(e,r,this),this),r]}catch(e){if(e!==n)throw e;return[this]}}),W.DEFMETHOD("is_constant",function(n){return this instanceof de||this instanceof Un&&"!"==this.operator&&this.expression instanceof de||this.evaluate(n).length>1}),W.DEFMETHOD("constant_value",function(n){if(this instanceof de)return this.value;if(this instanceof Un&&"!"==this.operator&&this.expression instanceof de)return!this.expression.value;var e=this.evaluate(n);return e.length>1?e[1]:void 0}),n(G,function(){throw new Error(p("Cannot evaluate a statement [{file}:{line},{col}]",this.start))}),n(vn,function(){throw n}),n(W,function(){throw n}),n(de,function(){return this.getValue()}),n(Un,function(t){var r=this.expression;switch(this.operator){case"!":return!e(r,t);case"typeof":if(r instanceof vn)return"function";if(r=e(r,t),r instanceof RegExp)throw n;return typeof r;case"void":return void e(r,t);case"~":return~e(r,t);case"-":return-e(r,t);case"+":return+e(r,t)}throw n}),n(Vn,function(t){var r,i=this.left,o=this.right;switch(this.operator){case"&&":r=e(i,t)&&e(o,t);break;case"||":r=e(i,t)||e(o,t);break;case"|":r=e(i,t)|e(o,t);break;case"&":r=e(i,t)&e(o,t);break;case"^":r=e(i,t)^e(o,t);break;case"+":r=e(i,t)+e(o,t);break;case"*":r=e(i,t)*e(o,t);break;case"/":r=e(i,t)/e(o,t);break;case"%":r=e(i,t)%e(o,t);break;case"-":r=e(i,t)-e(o,t);break;case"<<":r=e(i,t)<<e(o,t);break;case">>":r=e(i,t)>>e(o,t);break;case">>>":r=e(i,t)>>>e(o,t);break;case"==":r=e(i,t)==e(o,t);break;case"===":r=e(i,t)===e(o,t);break;case"!=":r=e(i,t)!=e(o,t);break;case"!==":r=e(i,t)!==e(o,t);break;case"<":r=e(i,t)<e(o,t);break;case"<=":r=e(i,t)<=e(o,t);break;case">":r=e(i,t)>e(o,t);break;case">=":r=e(i,t)>=e(o,t);break;default:throw n}if(isNaN(r)&&t.find_parent(fn))throw n;return r}),n(Yn,function(n){return e(this.condition,n)?e(this.consequent,n):e(this.alternative,n)}),n(fe,function(t){
if(this._evaluating)throw n;this._evaluating=!0;try{var r=this.definition();if(r&&(r.constant||t.option("reduce_vars")&&!r.modified)&&r.init)return e(r.init,t)}finally{this._evaluating=!1}throw n}),n(Rn,function(t){if(t.option("unsafe")&&"length"==this.property){var r=e(this.expression,t);if("string"==typeof r)return r.length}throw n})}(function(n,e){n.DEFMETHOD("_eval",e)}),function(n){function t(n){return e(Un,n,{operator:"!",expression:n})}n(W,function(){return t(this)}),n(G,function(){throw new Error("Cannot negate a statement")}),n(vn,function(){return t(this)}),n(Un,function(){return"!"==this.operator?this.expression:t(this)}),n(Nn,function(n){var e=this.clone();return e.cdr=e.cdr.negate(n),e}),n(Yn,function(n){var e=this.clone();return e.consequent=e.consequent.negate(n),e.alternative=e.alternative.negate(n),b(t(this),e)}),n(Vn,function(n){var e=this.clone(),r=this.operator;if(n.option("unsafe_comps"))switch(r){case"<=":return e.operator=">",e;case"<":return e.operator=">=",e;case">=":return e.operator="<",e;case">":return e.operator="<=",e}switch(r){case"==":return e.operator="!=",e;case"!=":return e.operator="==",e;case"===":return e.operator="!==",e;case"!==":return e.operator="===",e;case"&&":return e.operator="||",e.left=e.left.negate(n),e.right=e.right.negate(n),b(t(this),e);case"||":return e.operator="&&",e.left=e.left.negate(n),e.right=e.right.negate(n),b(t(this),e)}return t(this)})}(function(n,e){n.DEFMETHOD("negate",function(n){return e.call(this,n)})}),function(n){n(W,function(n){return!0}),n(nn,function(n){return!1}),n(de,function(n){return!1}),n(pe,function(n){return!1}),n(zn,function(n){var e=n.option("pure_funcs");return!e||("function"==typeof e?e(this):e.indexOf(this.expression.print_to_string())<0)}),n(K,function(n){for(var e=this.body.length;--e>=0;)if(this.body[e].has_side_effects(n))return!0;return!1}),n(Z,function(n){return this.body.has_side_effects(n)}),n(mn,function(n){return!0}),n(vn,function(n){return!1}),n(Vn,function(n){return this.left.has_side_effects(n)||this.right.has_side_effects(n)}),n(Wn,function(n){return!0}),n(Yn,function(n){return this.condition.has_side_effects(n)||this.consequent.has_side_effects(n)||this.alternative.has_side_effects(n)}),n(Pn,function(n){return"delete"==this.operator||"++"==this.operator||"--"==this.operator||this.expression.has_side_effects(n)}),n(fe,function(n){return this.global()&&this.undeclared()}),n(Jn,function(n){for(var e=this.properties.length;--e>=0;)if(this.properties[e].has_side_effects(n))return!0;return!1}),n(Xn,function(n){return this.value.has_side_effects(n)}),n(Gn,function(n){for(var e=this.elements.length;--e>=0;)if(this.elements[e].has_side_effects(n))return!0;return!1}),n(Rn,function(n){return!n.option("pure_getters")||this.expression.has_side_effects(n)}),n(In,function(n){return!n.option("pure_getters")||(this.expression.has_side_effects(n)||this.property.has_side_effects(n))}),n(jn,function(n){return!n.option("pure_getters")}),n(Nn,function(n){return this.car.has_side_effects(n)||this.cdr.has_side_effects(n)})}(function(n,e){n.DEFMETHOD("has_side_effects",e)}),function(n){function e(){var n=this.body.length;return n>0&&y(this.body[n-1])}n(G,function(){return null}),n(_n,function(){return this}),n(Q,e),n(kn,e),n(Dn,function(){return this.alternative&&y(this.body)&&y(this.alternative)&&this})}(function(n,e){n.DEFMETHOD("aborts",e)}),n(X,function(n,t){return"up"===t.has_directive(n.value)?e(nn,n):n}),n(J,function(n,t){return t.option("drop_debugger")?e(nn,n):n}),n(tn,function(n,t){return n.body instanceof wn&&t.loopcontrol_target(n.body.label)===n.body?e(nn,n):0==n.label.references.length?n.body:n}),n(K,function(n,e){return n.body=c(n.body,e),n}),n(Q,function(n,t){switch(n.body=c(n.body,t),n.body.length){case 1:return n.body[0];case 0:return e(nn,n)}return n}),ln.DEFMETHOD("drop_unused",function(n){var t=this;if(n.has_directive("use asm"))return t;if(n.option("unused")&&!(t instanceof pn)&&!t.uses_eval&&!t.uses_with){var r=[],i={},o=new _,a=this,u=new A(function(e,s){if(e!==t){if(e instanceof mn)return o.add(e.name.name,e),!0;if(e instanceof $n&&a===t)return e.definitions.forEach(function(e){e.value&&(o.add(e.name.name,e.value),e.value.has_side_effects(n)&&e.value.walk(u))}),!0;if(e instanceof fe){var c=e.definition();return c.id in i||(i[c.id]=!0,r.push(c)),!0}if(e instanceof ln){var f=a;return a=e,s(),a=f,!0}}});t.walk(u);for(var s=0;s<r.length;++s)r[s].orig.forEach(function(n){var e=o.get(n.name);e&&e.forEach(function(n){var e=new A(function(n){if(n instanceof fe){var e=n.definition();e.id in i||(i[e.id]=!0,r.push(e))}});n.walk(e)})});var c=new N(function(r,o,a){if(r instanceof dn&&!(r instanceof hn)&&!n.option("keep_fargs"))for(var u=r.argnames,s=u.length;--s>=0;){var f=u[s];if(!f.unreferenced())break;u.pop(),n.warn("Dropping unused function argument {name} [{file}:{line},{col}]",{name:f.name,file:f.start.file,line:f.start.line,col:f.start.col})}if(r instanceof mn&&r!==t)return r.name.definition().id in i?r:(n.warn("Dropping unused function {name} [{file}:{line},{col}]",{name:r.name.name,file:r.name.start.file,line:r.name.start.line,col:r.name.start.col}),e(nn,r));if(r instanceof $n&&!(c.parent()instanceof cn)){var l=r.definitions.filter(function(e){if(e.name.definition().id in i)return!0;var t={name:e.name.name,file:e.name.start.file,line:e.name.start.line,col:e.name.start.col};return e.value&&e.value.has_side_effects(n)?(e._unused_side_effects=!0,n.warn("Side effects in initialization of unused variable {name} [{file}:{line},{col}]",t),!0):(n.warn("Dropping unused variable {name} [{file}:{line},{col}]",t),!1)});l=h(l,function(n,e){return!n.value&&e.value?-1:!e.value&&n.value?1:0});for(var p=[],s=0;s<l.length;){var d=l[s];d._unused_side_effects?(p.push(d.value),l.splice(s,1)):(p.length>0&&(p.push(d.value),d.value=Nn.from_array(p),p=[]),++s)}return p=p.length>0?e(Q,r,{body:[e(Z,r,{body:Nn.from_array(p)})]}):null,0!=l.length||p?0==l.length?a?V.splice(p.body):p:(r.definitions=l,p?(p.body.unshift(r),a?V.splice(p.body):p):r):e(nn,r)}if(r instanceof sn&&(o(r,this),r.init instanceof Q)){var v=r.init.body.slice(0,-1);return r.init=r.init.body.slice(-1)[0].body,v.push(r),a?V.splice(v):e(Q,r,{body:v})}return r instanceof ln&&r!==t?r:void 0});t.transform(c)}}),ln.DEFMETHOD("hoist_declarations",function(n){var t=this;if(n.has_directive("use asm"))return t;var r=n.option("hoist_funs"),i=n.option("hoist_vars");if(r||i){var a=[],u=[],s=new _,c=0,f=0;t.walk(new A(function(n){return n instanceof ln&&n!==t||(n instanceof On?(++f,!0):void 0)})),i=i&&f>1;var l=new N(function(n){if(n!==t){if(n instanceof X)return a.push(n),e(nn,n);if(n instanceof mn&&r)return u.push(n),e(nn,n);if(n instanceof On&&i){n.definitions.forEach(function(n){s.set(n.name.name,n),++c});var o=n.to_assignments(),f=l.parent();if(f instanceof cn&&f.init===n){if(null==o){var p=n.definitions[0].name;return e(fe,p,p)}return o}return f instanceof sn&&f.init===n?o:o?e(Z,n,{body:o}):e(nn,n)}if(n instanceof ln)return n}});if(t=t.transform(l),c>0){var p=[];if(s.each(function(n,e){t instanceof dn&&o(function(e){return e.name==n.name.name},t.argnames)?s.del(e):(n=n.clone(),n.value=null,p.push(n),s.set(e,n))}),p.length>0){for(var h=0;h<t.body.length;){if(t.body[h]instanceof Z){var v,m,g=t.body[h].body;if(g instanceof Wn&&"="==g.operator&&(v=g.left)instanceof ne&&s.has(v.name)){var b=s.get(v.name);if(b.value)break;b.value=g.right,d(p,b),p.push(b),t.body.splice(h,1);continue}if(g instanceof Nn&&(m=g.car)instanceof Wn&&"="==m.operator&&(v=m.left)instanceof ne&&s.has(v.name)){var b=s.get(v.name);if(b.value)break;b.value=m.right,d(p,b),p.push(b),t.body[h].body=g.cdr;continue}}if(t.body[h]instanceof nn)t.body.splice(h,1);else{if(!(t.body[h]instanceof Q))break;var y=[h,1].concat(t.body[h].body);t.body.splice.apply(t.body,y)}}p=e(On,t,{definitions:p}),u.push(p)}}t.body=a.concat(u,t.body)}return t}),n(Z,function(n,t){return t.option("side_effects")&&!n.body.has_side_effects(t)?(t.warn("Dropping side-effect-free statement [{file}:{line},{col}]",n.start),e(nn,n)):n}),n(on,function(n,t){var r=n.condition.evaluate(t);if(n.condition=r[0],!t.option("loops"))return n;if(r.length>1){if(r[1])return e(sn,n,{body:n.body});if(n instanceof un&&t.option("dead_code")){var i=[];return l(t,n.body,i),e(Q,n,{body:i})}}return n}),n(un,function(n,t){return t.option("loops")?(n=on.prototype.optimize.call(n,t),n instanceof un&&(w(n,t),n=e(sn,n,n).transform(t)),n):n}),n(sn,function(n,t){var r=n.condition;if(r&&(r=r.evaluate(t),n.condition=r[0]),!t.option("loops"))return n;if(r&&r.length>1&&!r[1]&&t.option("dead_code")){var i=[];return n.init instanceof G?i.push(n.init):n.init&&i.push(e(Z,n.init,{body:n.init})),l(t,n.body,i),e(Q,n,{body:i})}return w(n,t),n}),n(Dn,function(n,t){if(!t.option("conditionals"))return n;var r=n.condition.evaluate(t);if(n.condition=r[0],r.length>1)if(r[1]){if(t.warn("Condition always true [{file}:{line},{col}]",n.condition.start),t.option("dead_code")){var i=[];return n.alternative&&l(t,n.alternative,i),i.push(n.body),e(Q,n,{body:i}).transform(t)}}else if(t.warn("Condition always false [{file}:{line},{col}]",n.condition.start),t.option("dead_code")){var i=[];return l(t,n.body,i),n.alternative&&i.push(n.alternative),e(Q,n,{body:i}).transform(t)}u(n.alternative)&&(n.alternative=null);var o=n.condition.negate(t),a=n.condition.print_to_string().length,s=o.print_to_string().length,c=s<a;if(n.alternative&&c){c=!1,n.condition=o;var f=n.body;n.body=n.alternative||e(nn),n.alternative=f}if(u(n.body)&&u(n.alternative))return e(Z,n.condition,{body:n.condition}).transform(t);if(n.body instanceof Z&&n.alternative instanceof Z)return e(Z,n,{body:e(Yn,n,{condition:n.condition,consequent:n.body.body,alternative:n.alternative.body})}).transform(t);if(u(n.alternative)&&n.body instanceof Z)return a===s&&!c&&n.condition instanceof Vn&&"||"==n.condition.operator&&(c=!0),c?e(Z,n,{body:e(Vn,n,{operator:"||",left:o,right:n.body.body})}).transform(t):e(Z,n,{body:e(Vn,n,{operator:"&&",left:n.condition,right:n.body.body})}).transform(t);if(n.body instanceof nn&&n.alternative&&n.alternative instanceof Z)return e(Z,n,{body:e(Vn,n,{operator:"||",left:n.condition,right:n.alternative.body})}).transform(t);if(n.body instanceof gn&&n.alternative instanceof gn&&n.body.TYPE==n.alternative.TYPE)return e(n.body.CTOR,n,{value:e(Yn,n,{condition:n.condition,consequent:n.body.value||e(ye,n.body).optimize(t),alternative:n.alternative.value||e(ye,n.alternative).optimize(t)})}).transform(t);if(n.body instanceof Dn&&!n.body.alternative&&!n.alternative&&(n.condition=e(Vn,n.condition,{operator:"&&",left:n.condition,right:n.body.condition}).transform(t),n.body=n.body.body),y(n.body)&&n.alternative){var p=n.alternative;return n.alternative=null,e(Q,n,{body:[n,p]}).transform(t)}if(y(n.alternative)){var d=n.body;return n.body=n.alternative,n.condition=c?o:n.condition.negate(t),n.alternative=null,e(Q,n,{body:[n,d]}).transform(t)}return n}),n(xn,function(n,t){if(0==n.body.length&&t.option("conditionals"))return e(Z,n,{body:n.expression}).transform(t);for(;;){var r=n.body[n.body.length-1];if(r){var i=r.body[r.body.length-1];if(i instanceof wn&&s(t.loopcontrol_target(i.label))===n&&r.body.pop(),r instanceof Fn&&0==r.body.length){n.body.pop();continue}}break}var o=n.expression.evaluate(t);n:if(2==o.length)try{if(n.expression=o[0],!t.option("dead_code"))break n;var a=o[1],u=!1,c=!1,f=!1,l=!1,p=!1,d=new N(function(r,i,o){if(r instanceof dn||r instanceof Z)return r;if(r instanceof xn&&r===n)return r=r.clone(),i(r,this),p?r:e(Q,r,{body:r.body.reduce(function(n,e){return n.concat(e.body)},[])}).transform(t);if(r instanceof Dn||r instanceof Bn){var s=u;return u=!c,i(r,this),u=s,r}if(r instanceof en||r instanceof xn){var s=c;return c=!0,i(r,this),c=s,r}if(r instanceof wn&&this.loopcontrol_target(r.label)===n)return u?(p=!0,r):c?r:(l=!0,o?V.skip:e(nn,r));if(r instanceof kn&&this.parent()===n){if(l)return V.skip;if(r instanceof Cn){var d=r.expression.evaluate(t);if(d.length<2)throw n;return d[1]===a||f?(f=!0,y(r)&&(l=!0),i(r,this),r):V.skip}return i(r,this),r}});d.stack=t.stack.slice(),n=n.transform(d)}catch(e){if(e!==n)throw e}return n}),n(Cn,function(n,e){return n.body=c(n.body,e),n}),n(Bn,function(n,e){return n.body=c(n.body,e),n}),$n.DEFMETHOD("remove_initializers",function(){this.definitions.forEach(function(n){n.value=null})}),$n.DEFMETHOD("to_assignments",function(){var n=this.definitions.reduce(function(n,t){if(t.value){var r=e(fe,t.name,t.name);n.push(e(Wn,t,{operator:"=",left:r,right:t.value}))}return n},[]);return 0==n.length?null:Nn.from_array(n)}),n($n,function(n,t){return 0==n.definitions.length?e(nn,n):n}),n(vn,function(n,e){return n=dn.prototype.optimize.call(n,e),e.option("unused")&&!e.option("keep_fnames")&&n.name&&n.name.unreferenced()&&(n.name=null),n}),n(zn,function(n,r){if(r.option("unsafe")){var i=n.expression;if(i instanceof fe&&i.undeclared())switch(i.name){case"Array":if(1!=n.args.length)return e(Gn,n,{elements:n.args}).transform(r);break;case"Object":if(0==n.args.length)return e(Jn,n,{properties:[]});break;case"String":if(0==n.args.length)return e(he,n,{value:""});if(n.args.length<=1)return e(Vn,n,{left:n.args[0],operator:"+",right:e(he,n,{value:""})}).transform(r);break;case"Number":if(0==n.args.length)return e(ve,n,{value:0});if(1==n.args.length)return e(Un,n,{expression:n.args[0],operator:"+"}).transform(r);case"Boolean":if(0==n.args.length)return e(De,n);if(1==n.args.length)return e(Un,n,{expression:e(Un,null,{expression:n.args[0],operator:"!"}),operator:"!"}).transform(r);break;case"Function":if(0==n.args.length)return e(vn,n,{argnames:[],body:[]});if(m(n.args,function(n){return n instanceof he}))try{var o="(function("+n.args.slice(0,-1).map(function(n){return n.value}).join(",")+"){"+n.args[n.args.length-1].value+"})()",a=H(o);a.figure_out_scope({screw_ie8:r.option("screw_ie8")});var u=new I(r.options);a=a.transform(u),a.figure_out_scope({screw_ie8:r.option("screw_ie8")}),a.mangle_names();var s;try{a.walk(new A(function(n){if(n instanceof dn)throw s=n,a}))}catch(n){if(n!==a)throw n}if(!s)return n;var c=s.argnames.map(function(t,r){return e(he,n.args[r],{value:t.print_to_string()})}),o=R();return Q.prototype._codegen.call(s,s,o),o=o.toString().replace(/^\{|\}$/g,""),c.push(e(he,n.args[n.args.length-1],{value:o})),n.args=c,n}catch(e){if(!(e instanceof O))throw console.log(e),e;r.warn("Error parsing code passed to new Function [{file}:{line},{col}]",n.args[n.args.length-1].start),r.warn(e.toString())}}else{if(i instanceof Rn&&"toString"==i.property&&0==n.args.length)return e(Vn,n,{left:e(he,n,{value:""}),operator:"+",right:i.expression}).transform(r);if(i instanceof Rn&&i.expression instanceof Gn&&"join"==i.property){var f=0==n.args.length?",":n.args[0].evaluate(r)[1];if(null!=f){var l=i.expression.elements.reduce(function(n,e){if(e=e.evaluate(r),0==n.length||1==e.length)n.push(e);else{var i=n[n.length-1];if(2==i.length){var o=""+i[1]+f+e[1];n[n.length-1]=[t(r,o,i[0]),o]}else n.push(e)}return n},[]);if(0==l.length)return e(he,n,{value:""});if(1==l.length)return l[0][0];if(""==f){var p;return p=l[0][0]instanceof he||l[1][0]instanceof he?l.shift()[0]:e(he,n,{value:""}),l.reduce(function(n,t){return e(Vn,t[0],{operator:"+",left:n,right:t[0]})},p).transform(r)}var d=n.clone();return d.expression=d.expression.clone(),d.expression.expression=d.expression.expression.clone(),d.expression.expression.elements=l.map(function(n){return n[0]}),b(n,d)}}}}if(r.option("side_effects")&&n.expression instanceof vn&&0==n.args.length&&!K.prototype.has_side_effects.call(n.expression,r))return e(ye,n).transform(r);if(r.option("drop_console")&&n.expression instanceof jn){for(var h=n.expression.expression;h.expression;)h=h.expression;if(h instanceof fe&&"console"==h.name&&h.undeclared())return e(ye,n).transform(r)}return n.evaluate(r)[0]}),n(Hn,function(n,t){if(t.option("unsafe")){var r=n.expression;if(r instanceof fe&&r.undeclared())switch(r.name){case"Object":case"RegExp":case"Function":case"Error":case"Array":return e(zn,n,n).transform(t)}}return n}),n(Nn,function(n,t){if(!t.option("side_effects"))return n;if(!n.car.has_side_effects(t))return r(t.parent(),n,n.cdr);if(t.option("cascade")){if(n.car instanceof Wn&&!n.car.left.has_side_effects(t)){if(n.car.left.equivalent_to(n.cdr))return n.car;if(n.cdr instanceof zn&&n.cdr.expression.equivalent_to(n.car.left))return n.cdr.expression=n.car,n.cdr}if(!n.car.has_side_effects(t)&&!n.cdr.has_side_effects(t)&&n.car.equivalent_to(n.cdr))return n.car}return n.cdr instanceof Un&&"void"==n.cdr.operator&&!n.cdr.expression.has_side_effects(t)?(n.cdr.expression=n.car,n.cdr):n.cdr instanceof ye?e(Un,n,{operator:"void",expression:n.car}):n}),Pn.DEFMETHOD("lift_sequences",function(n){if(n.option("sequences")&&this.expression instanceof Nn){var e=this.expression,t=e.to_array();return this.expression=t.pop(),t.push(this),e=Nn.from_array(t).transform(n)}return this}),n(Ln,function(n,e){return n.lift_sequences(e)}),n(Un,function(n,t){n=n.lift_sequences(t);var r=n.expression;if(t.option("booleans")&&t.in_boolean_context()){switch(n.operator){case"!":if(r instanceof Un&&"!"==r.operator)return r.expression;break;case"typeof":return t.warn("Boolean expression always true [{file}:{line},{col}]",n.start),n.expression.has_side_effects(t)?e(Nn,n,{car:n.expression,cdr:e(xe,n)}):e(xe,n)}r instanceof Vn&&"!"==n.operator&&(n=b(n,r.negate(t)))}return n.evaluate(t)[0]}),Vn.DEFMETHOD("lift_sequences",function(n){if(n.option("sequences")){if(this.left instanceof Nn){var e=this.left,t=e.to_array();return this.left=t.pop(),t.push(this),e=Nn.from_array(t).transform(n)}if(this.right instanceof Nn&&this instanceof Wn&&!E(this.left,n)){var e=this.right,t=e.to_array();return this.right=t.pop(),t.push(this),e=Nn.from_array(t).transform(n)}}return this});var x=v("== === != !== * & | ^");n(Vn,function(n,t){function i(e,r){if(r||!n.left.has_side_effects(t)&&!n.right.has_side_effects(t)){e&&(n.operator=e);var i=n.left;n.left=n.right,n.right=i}}if(x(n.operator)&&(n.right instanceof de&&!(n.left instanceof de)&&(n.left instanceof Vn&&Ue[n.left.operator]>=Ue[n.operator]||i(null,!0)),/^[!=]==?$/.test(n.operator))){if(n.left instanceof fe&&n.right instanceof Yn){if(n.right.consequent instanceof fe&&n.right.consequent.definition()===n.left.definition()){if(/^==/.test(n.operator))return n.right.condition;if(/^!=/.test(n.operator))return n.right.condition.negate(t)}if(n.right.alternative instanceof fe&&n.right.alternative.definition()===n.left.definition()){if(/^==/.test(n.operator))return n.right.condition.negate(t);if(/^!=/.test(n.operator))return n.right.condition}}if(n.right instanceof fe&&n.left instanceof Yn){if(n.left.consequent instanceof fe&&n.left.consequent.definition()===n.right.definition()){if(/^==/.test(n.operator))return n.left.condition;if(/^!=/.test(n.operator))return n.left.condition.negate(t)}if(n.left.alternative instanceof fe&&n.left.alternative.definition()===n.right.definition()){if(/^==/.test(n.operator))return n.left.condition.negate(t);if(/^!=/.test(n.operator))return n.left.condition}}}if(n=n.lift_sequences(t),t.option("comparisons"))switch(n.operator){case"===":case"!==":(n.left.is_string(t)&&n.right.is_string(t)||n.left.is_boolean()&&n.right.is_boolean())&&(n.operator=n.operator.substr(0,2));case"==":case"!=":n.left instanceof he&&"undefined"==n.left.value&&n.right instanceof Un&&"typeof"==n.right.operator&&t.option("unsafe")&&(n.right.expression instanceof fe&&n.right.expression.undeclared()||(n.right=n.right.expression,n.left=e(ye,n.left).optimize(t),2==n.operator.length&&(n.operator+="=")))}if(t.option("conditionals"))if("&&"==n.operator){var o=n.left.evaluate(t);if(o.length>1)return o[1]?(t.warn("Condition left of && always true [{file}:{line},{col}]",n.start),r(t.parent(),n,n.right.evaluate(t)[0])):(t.warn("Condition left of && always false [{file}:{line},{col}]",n.start),r(t.parent(),n,o[0]))}else if("||"==n.operator){var o=n.left.evaluate(t);if(o.length>1)return o[1]?(t.warn("Condition left of || always true [{file}:{line},{col}]",n.start),r(t.parent(),n,o[0])):(t.warn("Condition left of || always false [{file}:{line},{col}]",n.start),r(t.parent(),n,n.right.evaluate(t)[0]))}if(t.option("booleans")&&t.in_boolean_context())switch(n.operator){case"&&":var o=n.left.evaluate(t),a=n.right.evaluate(t);if(o.length>1&&!o[1]||a.length>1&&!a[1])return t.warn("Boolean && always false [{file}:{line},{col}]",n.start),n.left.has_side_effects(t)?e(Nn,n,{car:n.left,cdr:e(De)}).optimize(t):e(De,n);if(o.length>1&&o[1])return a[0];if(a.length>1&&a[1])return o[0];break;case"||":var o=n.left.evaluate(t),a=n.right.evaluate(t);if(o.length>1&&o[1]||a.length>1&&a[1])return t.warn("Boolean || always true [{file}:{line},{col}]",n.start),n.left.has_side_effects(t)?e(Nn,n,{car:n.left,cdr:e(xe)}).optimize(t):e(xe,n);if(o.length>1&&!o[1])return a[0];if(a.length>1&&!a[1])return o[0];break;case"+":var o=n.left.evaluate(t),a=n.right.evaluate(t);if(o.length>1&&o[0]instanceof he&&o[1]&&!n.right.has_side_effects(t)||a.length>1&&a[0]instanceof he&&a[1]&&!n.left.has_side_effects(t))return t.warn("+ in boolean context always true [{file}:{line},{col}]",n.start),e(xe,n)}if(t.option("comparisons")&&n.is_boolean()){if(!(t.parent()instanceof Vn)||t.parent()instanceof Wn){var u=e(Un,n,{operator:"!",expression:n.negate(t)});n=b(n,u)}if(t.option("unsafe_comps"))switch(n.operator){case"<":i(">");break;case"<=":i(">=")}}return"+"==n.operator&&n.right instanceof he&&""===n.right.getValue()&&n.left instanceof Vn&&"+"==n.left.operator&&n.left.is_string(t)?n.left:(t.option("evaluate")&&"+"==n.operator&&(n.left instanceof de&&n.right instanceof Vn&&"+"==n.right.operator&&n.right.left instanceof de&&n.right.is_string(t)&&(n=e(Vn,n,{operator:"+",left:e(he,null,{value:""+n.left.getValue()+n.right.left.getValue(),start:n.left.start,end:n.right.left.end}),right:n.right.right})),n.right instanceof de&&n.left instanceof Vn&&"+"==n.left.operator&&n.left.right instanceof de&&n.left.is_string(t)&&(n=e(Vn,n,{operator:"+",left:n.left.left,right:e(he,null,{value:""+n.left.right.getValue()+n.right.getValue(),start:n.left.right.start,end:n.right.end})})),n.left instanceof Vn&&"+"==n.left.operator&&n.left.is_string(t)&&n.left.right instanceof de&&n.right instanceof Vn&&"+"==n.right.operator&&n.right.left instanceof de&&n.right.is_string(t)&&(n=e(Vn,n,{operator:"+",left:e(Vn,n.left,{operator:"+",left:n.left.left,right:e(he,null,{value:""+n.left.right.getValue()+n.right.left.getValue(),start:n.left.right.start,end:n.right.left.end})}),right:n.right.right}))),n.right instanceof Vn&&n.right.operator==n.operator&&("&&"==n.operator||"||"==n.operator)?(n.left=e(Vn,n.left,{operator:n.operator,left:n.left,right:n.right.left}),n.right=n.right.right,n.transform(t)):n.evaluate(t)[0])}),n(fe,function(n,r){function i(n,e){return e instanceof Vn&&"="===e.operator&&e.left===n}if(n.undeclared()&&!i(n,r.parent())){var o=r.option("global_defs");if(o&&g(o,n.name))return t(r,o[n.name],n);if(!n.scope.uses_with||!r.find_parent(fn))switch(n.name){case"undefined":return e(ye,n);case"NaN":return e(be,n).transform(r);case"Infinity":return e(we,n).transform(r)}}return n}),n(we,function(n,t){return e(Vn,n,{operator:"/",left:e(ve,n,{value:1}),right:e(ve,n,{value:0})})}),n(ye,function(n,t){if(t.option("unsafe")){var r=t.find_parent(ln),i=r.find_variable("undefined");if(i){var o=e(fe,n,{name:"undefined",scope:r,thedef:i});return o.reference(),o}}return n});var k=["+","-","/","*","%",">>","<<",">>>","|","^","&"],F=["*","|","^","&"];n(Wn,function(n,e){return n=n.lift_sequences(e),"="==n.operator&&n.left instanceof fe&&n.right instanceof Vn&&(n.right.left instanceof fe&&n.right.left.name==n.left.name&&i(n.right.operator,k)?(n.operator=n.right.operator+"=",n.right=n.right.right):n.right.right instanceof fe&&n.right.right.name==n.left.name&&i(n.right.operator,F)&&!n.right.left.has_side_effects(e)&&(n.operator=n.right.operator+"=",n.right=n.right.left)),n}),n(Yn,function(n,i){function o(n){return n.is_boolean()?n:e(Un,n,{operator:"!",expression:n.negate(i)})}function a(n){return n instanceof xe||n instanceof Un&&"!"==n.operator&&n.expression instanceof de&&!n.expression.value}function u(n){return n instanceof De||n instanceof Un&&"!"==n.operator&&n.expression instanceof de&&!!n.expression.value}if(!i.option("conditionals"))return n;if(n.condition instanceof Nn){var s=n.condition.car;return n.condition=n.condition.cdr,Nn.cons(s,n)}var c=n.condition.evaluate(i);if(c.length>1)return c[1]?(i.warn("Condition always true [{file}:{line},{col}]",n.start),r(i.parent(),n,n.consequent)):(i.warn("Condition always false [{file}:{line},{col}]",n.start),r(i.parent(),n,n.alternative));var f=c[0].negate(i);b(c[0],f)===f&&(n=e(Yn,n,{condition:f,consequent:n.alternative,alternative:n.consequent}));var l=n.consequent,p=n.alternative;if(l instanceof Wn&&p instanceof Wn&&l.operator==p.operator&&l.left.equivalent_to(p.left)&&!l.left.has_side_effects(i))return e(Wn,n,{operator:l.operator,left:l.left,right:e(Yn,n,{condition:n.condition,consequent:l.right,alternative:p.right})});if(l instanceof zn&&p.TYPE===l.TYPE&&l.args.length==p.args.length&&!l.expression.has_side_effects(i)&&l.expression.equivalent_to(p.expression)){if(0==l.args.length)return e(Nn,n,{car:n.condition,cdr:l});if(1==l.args.length)return l.args[0]=e(Yn,n,{condition:n.condition,consequent:l.args[0],alternative:p.args[0]}),l}if(l instanceof Yn&&l.alternative.equivalent_to(p))return e(Yn,n,{condition:e(Vn,n,{left:n.condition,operator:"&&",right:l.condition}),consequent:l.consequent,alternative:p});if(l.is_constant(i)&&p.is_constant(i)&&l.equivalent_to(p)){var d=l.constant_value(i);return n.condition.has_side_effects(i)?Nn.from_array([n.condition,t(i,d,n)]):t(i,d,n)}return a(n.consequent)?u(n.alternative)?o(n.condition):e(Vn,n,{operator:"||",left:o(n.condition),right:n.alternative}):u(n.consequent)?a(n.alternative)?o(n.condition.negate(i)):e(Vn,n,{operator:"&&",left:o(n.condition.negate(i)),right:n.alternative}):a(n.alternative)?e(Vn,n,{operator:"||",left:o(n.condition.negate(i)),right:n.consequent}):u(n.alternative)?e(Vn,n,{operator:"&&",left:o(n.condition),right:n.consequent}):n}),n(Ee,function(n,t){if(t.option("booleans")){var r=t.parent();return r instanceof Vn&&("=="==r.operator||"!="==r.operator)?(t.warn("Non-strict equality against boolean: {operator} {value} [{file}:{line},{col}]",{operator:r.operator,value:n.value,file:r.start.file,line:r.start.line,col:r.start.col}),e(ve,n,{value:+n.value})):e(Un,n,{operator:"!",expression:e(ve,n,{value:1-n.value})})}return n}),n(In,function(n,t){var r=n.property;if(r instanceof he&&t.option("properties")){if(r=r.getValue(),Ce(r)?t.option("screw_ie8"):T(r))return e(Rn,n,{expression:n.expression,property:r}).optimize(t);var i=parseFloat(r);isNaN(i)||i.toString()!=r||(n.property=e(ve,n.property,{value:i}))}return n}),n(Rn,function(n,t){var r=n.property;return Ce(r)&&!t.option("screw_ie8")?e(In,n,{expression:n.expression,property:e(he,n,{value:r})}).optimize(t):n.evaluate(t)[0]}),n(Gn,D),n(Jn,D),n(me,D),n(bn,function(n,e){return n.value instanceof ye&&(n.value=null),n})}(),function(){function e(n){if("Literal"==n.type)return null!=n.raw?n.raw:n.value+""}function t(n){var t=n.loc,r=t&&t.start,i=n.range;return new Y({file:t&&t.source,line:r&&r.line,col:r&&r.column,pos:i?i[0]:n.start,endline:r&&r.line,endcol:r&&r.column,endpos:i?i[0]:n.start,raw:e(n)})}function r(n){var t=n.loc,r=t&&t.end,i=n.range;return new Y({file:t&&t.source,line:r&&r.line,col:r&&r.column,pos:i?i[1]:n.end,endline:r&&r.line,endcol:r&&r.column,endpos:i?i[1]:n.end,raw:e(n)})}function i(e,i,a){var f="function From_Moz_"+e+"(M){\n";f+="return new U2."+i.name+"({\nstart: my_start_token(M),\nend: my_end_token(M)";var p="function To_Moz_"+e+"(M){\n";p+="return {\ntype: "+JSON.stringify(e),a&&a.split(/\s*,\s*/).forEach(function(n){var e=/([a-z0-9$_]+)(=|@|>|%)([a-z0-9$_]+)/i.exec(n);if(!e)throw new Error("Can't understand property map: "+n);var t=e[1],r=e[2],i=e[3];switch(f+=",\n"+i+": ",p+=",\n"+t+": ",r){case"@":f+="M."+t+".map(from_moz)",p+="M."+i+".map(to_moz)";break;case">":f+="from_moz(M."+t+")",p+="to_moz(M."+i+")";break;case"=":f+="M."+t,p+="M."+i;break;case"%":f+="from_moz(M."+t+").body",p+="to_moz_block(M)";break;default:throw new Error("Can't understand operator in propmap: "+n)}}),f+="\n})\n}",p+="\n}\n}",f=new Function("U2","my_start_token","my_end_token","from_moz","return("+f+")")(n,t,r,o),p=new Function("to_moz","to_moz_block","return("+p+")")(s,c),l[e]=f,u(i,p)}function o(n){p.push(n);var e=null!=n?l[n.type](n):null;return p.pop(),e}function a(n,e,t){var r=n.start,i=n.end;return null!=r.pos&&null!=i.endpos&&(e.range=[r.pos,i.endpos]),r.line&&(e.loc={start:{line:r.line,column:r.col},end:i.endline?{line:i.endline,column:i.endcol}:null},r.file&&(e.loc.source=r.file)),e}function u(n,e){n.DEFMETHOD("to_mozilla_ast",function(){return a(this,e(this))})}function s(n){return null!=n?n.to_mozilla_ast():null}function c(n){return{type:"BlockStatement",body:n.body.map(s)}}var f=function(n){for(var e=!0,t=0;t<n.length;t++)e&&n[t]instanceof G&&n[t].body instanceof he?n[t]=new X({start:n[t].start,end:n[t].end,value:n[t].body.value}):!e||n[t]instanceof G&&n[t].body instanceof he||(e=!1);return n},l={Program:function(n){return new pn({start:t(n),end:r(n),body:f(n.body.map(o))})},FunctionDeclaration:function(n){return new mn({start:t(n),end:r(n),name:o(n.id),argnames:n.params.map(o),body:f(o(n.body).body)})},FunctionExpression:function(n){return new vn({start:t(n),end:r(n),name:o(n.id),argnames:n.params.map(o),body:f(o(n.body).body)})},ExpressionStatement:function(n){return new Z({start:t(n),end:r(n),body:o(n.expression)})},TryStatement:function(n){var e=n.handlers||[n.handler];if(e.length>1||n.guardedHandlers&&n.guardedHandlers.length)throw new Error("Multiple catch clauses are not supported.");return new Bn({start:t(n),end:r(n),body:o(n.block).body,bcatch:o(e[0]),bfinally:n.finalizer?new Tn(o(n.finalizer)):null})},Property:function(n){var e=n.key,i="Identifier"==e.type?e.name:e.value,a={start:t(e),end:r(n.value),key:i,value:o(n.value)};switch(n.kind){case"init":return new Zn(a);case"set":return a.value.name=o(e),new Kn(a);case"get":return a.value.name=o(e),new Qn(a)}},ArrayExpression:function(n){return new Gn({start:t(n),end:r(n),elements:n.elements.map(function(n){return null===n?new Ae:o(n)})})},ObjectExpression:function(n){return new Jn({start:t(n),end:r(n),properties:n.properties.map(function(n){return n.type="Property",o(n)})})},SequenceExpression:function(n){return Nn.from_array(n.expressions.map(o))},MemberExpression:function(n){return new(n.computed?In:Rn)({start:t(n),end:r(n),property:n.computed?o(n.property):n.property.name,expression:o(n.object)})},SwitchCase:function(n){return new(n.test?Cn:Fn)({start:t(n),end:r(n),expression:o(n.test),body:n.consequent.map(o)})},VariableDeclaration:function(n){return new("const"===n.kind?qn:On)({start:t(n),end:r(n),definitions:n.declarations.map(o)})},Literal:function(n){var e=n.value,i={start:t(n),end:r(n)};if(null===e)return new ge(i);switch(typeof e){case"string":return i.value=e,new he(i);case"number":return i.value=e,new ve(i);case"boolean":return new(e?xe:De)(i);default:var o=n.regex;return o&&o.pattern?i.value=new RegExp(o.pattern,o.flags).toString():i.value=n.regex&&n.raw?n.raw:e,new me(i)}},Identifier:function(n){var e=p[p.length-2];return new("LabeledStatement"==e.type?ce:"VariableDeclarator"==e.type&&e.id===n?"const"==e.kind?ie:re:"FunctionExpression"==e.type?e.id===n?ue:oe:"FunctionDeclaration"==e.type?e.id===n?ae:oe:"CatchClause"==e.type?se:"BreakStatement"==e.type||"ContinueStatement"==e.type?le:fe)({start:t(n),end:r(n),name:n.name})}};l.UpdateExpression=l.UnaryExpression=function(n){var e="prefix"in n?n.prefix:"UnaryExpression"==n.type;return new(e?Un:Ln)({start:t(n),end:r(n),operator:n.operator,expression:o(n.argument)})},i("EmptyStatement",nn),i("BlockStatement",Q,"body@body"),i("IfStatement",Dn,"test>condition, consequent>body, alternate>alternative"),i("LabeledStatement",tn,"label>label, body>body"),
i("BreakStatement",wn,"label>label"),i("ContinueStatement",En,"label>label"),i("WithStatement",fn,"object>expression, body>body"),i("SwitchStatement",xn,"discriminant>expression, cases@body"),i("ReturnStatement",bn,"argument>value"),i("ThrowStatement",yn,"argument>value"),i("WhileStatement",un,"test>condition, body>body"),i("DoWhileStatement",an,"test>condition, body>body"),i("ForStatement",sn,"init>init, test>condition, update>step, body>body"),i("ForInStatement",cn,"left>init, right>object, body>body"),i("DebuggerStatement",J),i("VariableDeclarator",Mn,"id>name, init>value"),i("CatchClause",Sn,"param>argname, body%body"),i("ThisExpression",pe),i("BinaryExpression",Vn,"operator=operator, left>left, right>right"),i("LogicalExpression",Vn,"operator=operator, left>left, right>right"),i("AssignmentExpression",Wn,"operator=operator, left>left, right>right"),i("ConditionalExpression",Yn,"test>condition, consequent>consequent, alternate>alternative"),i("NewExpression",Hn,"callee>expression, arguments@args"),i("CallExpression",zn,"callee>expression, arguments@args"),u(pn,function(n){return{type:"Program",body:n.body.map(s)}}),u(mn,function(n){return{type:"FunctionDeclaration",id:s(n.name),params:n.argnames.map(s),body:c(n)}}),u(vn,function(n){return{type:"FunctionExpression",id:s(n.name),params:n.argnames.map(s),body:c(n)}}),u(X,function(n){return{type:"ExpressionStatement",expression:{type:"Literal",value:n.value}}}),u(Z,function(n){return{type:"ExpressionStatement",expression:s(n.body)}}),u(kn,function(n){return{type:"SwitchCase",test:s(n.expression),consequent:n.body.map(s)}}),u(Bn,function(n){return{type:"TryStatement",block:c(n),handler:s(n.bcatch),guardedHandlers:[],finalizer:s(n.bfinally)}}),u(Sn,function(n){return{type:"CatchClause",param:s(n.argname),guard:null,body:c(n)}}),u($n,function(n){return{type:"VariableDeclaration",kind:n instanceof qn?"const":"var",declarations:n.definitions.map(s)}}),u(Nn,function(n){return{type:"SequenceExpression",expressions:n.to_array().map(s)}}),u(jn,function(n){var e=n instanceof In;return{type:"MemberExpression",object:s(n.expression),computed:e,property:e?s(n.property):{type:"Identifier",name:n.property}}}),u(Pn,function(n){return{type:"++"==n.operator||"--"==n.operator?"UpdateExpression":"UnaryExpression",operator:n.operator,prefix:n instanceof Un,argument:s(n.expression)}}),u(Vn,function(n){return{type:"&&"==n.operator||"||"==n.operator?"LogicalExpression":"BinaryExpression",left:s(n.left),operator:n.operator,right:s(n.right)}}),u(Gn,function(n){return{type:"ArrayExpression",elements:n.elements.map(s)}}),u(Jn,function(n){return{type:"ObjectExpression",properties:n.properties.map(s)}}),u(Xn,function(n){var e,t=C(n.key)?{type:"Identifier",name:n.key}:{type:"Literal",value:n.key};return n instanceof Zn?e="init":n instanceof Qn?e="get":n instanceof Kn&&(e="set"),{type:"Property",kind:e,key:t,value:s(n.value)}}),u(ne,function(n){var e=n.definition();return{type:"Identifier",name:e?e.mangled_name||e.name:n.name}}),u(me,function(n){var e=n.value;return{type:"Literal",value:e,raw:e.toString(),regex:{pattern:e.source,flags:e.toString().match(/[gimuy]*$/)[0]}}}),u(de,function(n){var e=n.value;return"number"==typeof e&&(e<0||0===e&&1/e<0)?{type:"UnaryExpression",operator:"-",prefix:!0,argument:{type:"Literal",value:-e,raw:n.start.raw}}:{type:"Literal",value:e,raw:n.start.raw}}),u(_e,function(n){return{type:"Identifier",name:String(n.value)}}),Ee.DEFMETHOD("to_mozilla_ast",de.prototype.to_mozilla_ast),ge.DEFMETHOD("to_mozilla_ast",de.prototype.to_mozilla_ast),Ae.DEFMETHOD("to_mozilla_ast",function(){return null}),K.DEFMETHOD("to_mozilla_ast",Q.prototype.to_mozilla_ast),dn.DEFMETHOD("to_mozilla_ast",vn.prototype.to_mozilla_ast);var p=null;W.from_mozilla_ast=function(n){var e=p;p=[];var t=o(n);return p=e,t}}(),n.Compressor=I,n.DefaultsError=u,n.Dictionary=_,n.JS_Parse_Error=O,n.MAP=V,n.OutputStream=R,n.SourceMap=P,n.TreeTransformer=N,n.TreeWalker=A,n.base54=Ve,n.defaults=s,n.mangle_properties=L,n.merge=c,n.parse=H,n.push_uniq=l,n.string_template=p,n.tokenizer=z,n.is_identifier=C,n.SymbolDef=j,"undefined"!=typeof DEBUG&&DEBUG&&(n.EXPECT_DIRECTIVE=Ye),module.exports=n}({},function(){return this}());

/***/ },
/* 7 */
/***/ function(module, exports) {

"use strict";
'use strict';

module.exports = {
    'default': '<!DOCTYPE html>'
  , 'xml': '<?xml version="1.0" encoding="utf-8" ?>'
  , 'transitional': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'
  , 'strict': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">'
  , 'frameset': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">'
  , '1.1': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">'
  , 'basic': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML Basic 1.1//EN" "http://www.w3.org/TR/xhtml-basic/xhtml-basic11.dtd">'
  , 'mobile': '<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.2//EN" "http://www.openmobilealliance.org/tech/DTD/xhtml-mobile12.dtd">'
};

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

var utils = __webpack_require__(1);
var characterParser = __webpack_require__(5);


/**
 * Initialize `Lexer` with the given `str`.
 *
 * @param {String} str
 * @param {String} filename
 * @api private
 */

var Lexer = module.exports = function Lexer(str, filename) {
  this.input = str.replace(/\r\n|\r/g, '\n');
  this.filename = filename;
  this.deferredTokens = [];
  this.lastIndents = 0;
  this.lineno = 1;
  this.stash = [];
  this.indentStack = [];
  this.indentRe = null;
  this.pipeless = false;
};


function assertExpression(exp) {
  //this verifies that a JavaScript expression is valid
  Function('', 'return (' + exp + ')');
}
function assertNestingCorrect(exp) {
  //this verifies that code is properly nested, but allows
  //invalid JavaScript such as the contents of `attributes`
  var res = characterParser(exp)
  if (res.isNesting()) {
    throw new Error('Nesting must match on expression `' + exp + '`')
  }
}

/**
 * Lexer prototype.
 */

Lexer.prototype = {

  /**
   * Construct a token with the given `type` and `val`.
   *
   * @param {String} type
   * @param {String} val
   * @return {Object}
   * @api private
   */

  tok: function(type, val){
    return {
        type: type
      , line: this.lineno
      , val: val
    }
  },

  /**
   * Consume the given `len` of input.
   *
   * @param {Number} len
   * @api private
   */

  consume: function(len){
    this.input = this.input.substr(len);
  },

  /**
   * Scan for `type` with the given `regexp`.
   *
   * @param {String} type
   * @param {RegExp} regexp
   * @return {Object}
   * @api private
   */

  scan: function(regexp, type){
    var captures;
    if (captures = regexp.exec(this.input)) {
      this.consume(captures[0].length);
      return this.tok(type, captures[1]);
    }
  },

  /**
   * Defer the given `tok`.
   *
   * @param {Object} tok
   * @api private
   */

  defer: function(tok){
    this.deferredTokens.push(tok);
  },

  /**
   * Lookahead `n` tokens.
   *
   * @param {Number} n
   * @return {Object}
   * @api private
   */

  lookahead: function(n){
    var fetch = n - this.stash.length;
    while (fetch-- > 0) this.stash.push(this.next());
    return this.stash[--n];
  },

  /**
   * Return the indexOf `(` or `{` or `[` / `)` or `}` or `]` delimiters.
   *
   * @return {Number}
   * @api private
   */

  bracketExpression: function(skip){
    skip = skip || 0;
    var start = this.input[skip];
    if (start != '(' && start != '{' && start != '[') throw new Error('unrecognized start character');
    var end = ({'(': ')', '{': '}', '[': ']'})[start];
    var range = characterParser.parseMax(this.input, {start: skip + 1});
    if (this.input[range.end] !== end) throw new Error('start character ' + start + ' does not match end character ' + this.input[range.end]);
    return range;
  },

  /**
   * Stashed token.
   */

  stashed: function() {
    return this.stash.length
      && this.stash.shift();
  },

  /**
   * Deferred token.
   */

  deferred: function() {
    return this.deferredTokens.length
      && this.deferredTokens.shift();
  },

  /**
   * end-of-source.
   */

  eos: function() {
    if (this.input.length) return;
    if (this.indentStack.length) {
      this.indentStack.shift();
      return this.tok('outdent');
    } else {
      return this.tok('eos');
    }
  },

  /**
   * Blank line.
   */

  blank: function() {
    var captures;
    if (captures = /^\n *\n/.exec(this.input)) {
      this.consume(captures[0].length - 1);
      ++this.lineno;
      if (this.pipeless) return this.tok('text', '');
      return this.next();
    }
  },

  /**
   * Comment.
   */

  comment: function() {
    var captures;
    if (captures = /^\/\/(-)?([^\n]*)/.exec(this.input)) {
      this.consume(captures[0].length);
      var tok = this.tok('comment', captures[2]);
      tok.buffer = '-' != captures[1];
      this.pipeless = true;
      return tok;
    }
  },

  /**
   * Interpolated tag.
   */

  interpolation: function() {
    if (/^#\{/.test(this.input)) {
      var match;
      try {
        match = this.bracketExpression(1);
      } catch (ex) {
        return;//not an interpolation expression, just an unmatched open interpolation
      }

      this.consume(match.end + 1);
      return this.tok('interpolation', match.src);
    }
  },

  /**
   * Tag.
   */

  tag: function() {
    var captures;
    if (captures = /^(\w[-:\w]*)(\/?)/.exec(this.input)) {
      this.consume(captures[0].length);
      var tok, name = captures[1];
      if (':' == name[name.length - 1]) {
        name = name.slice(0, -1);
        tok = this.tok('tag', name);
        this.defer(this.tok(':'));
        while (' ' == this.input[0]) this.input = this.input.substr(1);
      } else {
        tok = this.tok('tag', name);
      }
      tok.selfClosing = !!captures[2];
      return tok;
    }
  },

  /**
   * Filter.
   */

  filter: function() {
    var tok = this.scan(/^:([\w\-]+)/, 'filter');
    if (tok) {
      this.pipeless = true;
      return tok;
    }
  },

  /**
   * Doctype.
   */

  doctype: function() {
    if (this.scan(/^!!! *([^\n]+)?/, 'doctype')) {
      throw new Error('`!!!` is deprecated, you must now use `doctype`');
    }
    var node = this.scan(/^(?:doctype) *([^\n]+)?/, 'doctype');
    if (node && node.val && node.val.trim() === '5') {
      throw new Error('`doctype 5` is deprecated, you must now use `doctype html`');
    }
    return node;
  },

  /**
   * Id.
   */

  id: function() {
    return this.scan(/^#([\w-]+)/, 'id');
  },

  /**
   * Class.
   */

  className: function() {
    return this.scan(/^\.([\w-]+)/, 'class');
  },

  /**
   * Text.
   */

  text: function() {
    return this.scan(/^(?:\| ?| )([^\n]+)/, 'text') || this.scan(/^(<[^\n]*)/, 'text');
  },

  textFail: function () {
    var tok;
    if (tok = this.scan(/^([^\.\n][^\n]+)/, 'text')) {
      console.warn('Warning: missing space before text for line ' + this.lineno +
          ' of jade file "' + this.filename + '"');
      return tok;
    }
  },

  /**
   * Dot.
   */

  dot: function() {
    this.pipeless = true;
    return this.scan(/^\./, 'dot');
  },

  /**
   * Extends.
   */

  "extends": function() {
    return this.scan(/^extends? +([^\n]+)/, 'extends');
  },

  /**
   * Block prepend.
   */

  prepend: function() {
    var captures;
    if (captures = /^prepend +([^\n]+)/.exec(this.input)) {
      this.consume(captures[0].length);
      var mode = 'prepend'
        , name = captures[1]
        , tok = this.tok('block', name);
      tok.mode = mode;
      return tok;
    }
  },

  /**
   * Block append.
   */

  append: function() {
    var captures;
    if (captures = /^append +([^\n]+)/.exec(this.input)) {
      this.consume(captures[0].length);
      var mode = 'append'
        , name = captures[1]
        , tok = this.tok('block', name);
      tok.mode = mode;
      return tok;
    }
  },

  /**
   * Block.
   */

  block: function() {
    var captures;
    if (captures = /^block\b *(?:(prepend|append) +)?([^\n]+)/.exec(this.input)) {
      this.consume(captures[0].length);
      var mode = captures[1] || 'replace'
        , name = captures[2]
        , tok = this.tok('block', name);

      tok.mode = mode;
      return tok;
    }
  },

  /**
   * Mixin Block.
   */

  mixinBlock: function() {
    var captures;
    if (captures = /^block\s*(\n|$)/.exec(this.input)) {
      this.consume(captures[0].length - 1);
      return this.tok('mixin-block');
    }
  },

  /**
   * Yield.
   */

  yield: function() {
    return this.scan(/^yield */, 'yield');
  },

  /**
   * Include.
   */

  include: function() {
    return this.scan(/^include +([^\n]+)/, 'include');
  },

  /**
   * Include with filter
   */

  includeFiltered: function() {
    var captures;
    if (captures = /^include:([\w\-]+)([\( ])/.exec(this.input)) {
      this.consume(captures[0].length - 1);
      var filter = captures[1];
      var attrs = captures[2] === '(' ? this.attrs() : null;
      if (!(captures[2] === ' ' || this.input[0] === ' ')) {
        throw new Error('expected space after include:filter but got ' + JSON.stringify(this.input[0]));
      }
      captures = /^ *([^\n]+)/.exec(this.input);
      if (!captures) {
        throw new Error('missing path for include:filter');
      }
      this.consume(captures[0].length);
      var path = captures[1];
      var tok = this.tok('include', path);
      tok.filter = filter;
      tok.attrs = attrs;
      return tok;
    }
  },

  /**
   * Case.
   */

  "case": function() {
    return this.scan(/^case +([^\n]+)/, 'case');
  },

  /**
   * When.
   */

  when: function() {
    return this.scan(/^when +([^:\n]+)/, 'when');
  },

  /**
   * Default.
   */

  "default": function() {
    return this.scan(/^default */, 'default');
  },

  /**
   * Call mixin.
   */

  call: function(){

    var tok, captures;
    if (captures = /^\+(([-\w]+)|(#\{))/.exec(this.input)) {
      // try to consume simple or interpolated call
      if (captures[2]) {
        // simple call
        this.consume(captures[0].length);
        tok = this.tok('call', captures[2]);
      } else {
        // interpolated call
        var match;
        try {
          match = this.bracketExpression(2);
        } catch (ex) {
          return;//not an interpolation expression, just an unmatched open interpolation
        }
        this.consume(match.end + 1);
        assertExpression(match.src);
        tok = this.tok('call', '#{'+match.src+'}');
      }

      // Check for args (not attributes)
      if (captures = /^ *\(/.exec(this.input)) {
        try {
          var range = this.bracketExpression(captures[0].length - 1);
          if (!/^\s*[-\w]+ *=/.test(range.src)) { // not attributes
            this.consume(range.end + 1);
            tok.args = range.src;
          }
        } catch (ex) {
          //not a bracket expcetion, just unmatched open parens
        }
      }

      return tok;
    }
  },

  /**
   * Mixin.
   */

  mixin: function(){
    var captures;
    if (captures = /^mixin +([-\w]+)(?: *\((.*)\))? */.exec(this.input)) {
      this.consume(captures[0].length);
      var tok = this.tok('mixin', captures[1]);
      tok.args = captures[2];
      return tok;
    }
  },

  /**
   * Conditional.
   */

  conditional: function() {
    var captures;
    if (captures = /^(if|unless|else if|else)\b([^\n]*)/.exec(this.input)) {
      this.consume(captures[0].length);
      var type = captures[1]
      var js = captures[2];
      var isIf = false;
      var isElse = false;

      switch (type) {
        case 'if':
          assertExpression(js)
          js = 'if (' + js + ')';
          isIf = true;
          break;
        case 'unless':
          assertExpression(js)
          js = 'if (!(' + js + '))';
          isIf = true;
          break;
        case 'else if':
          assertExpression(js)
          js = 'else if (' + js + ')';
          isIf = true;
          isElse = true;
          break;
        case 'else':
          if (js && js.trim()) {
            throw new Error('`else` cannot have a condition, perhaps you meant `else if`');
          }
          js = 'else';
          isElse = true;
          break;
      }
      var tok = this.tok('code', js);
      tok.isElse = isElse;
      tok.isIf = isIf;
      tok.requiresBlock = true;
      return tok;
    }
  },

  /**
   * While.
   */

  "while": function() {
    var captures;
    if (captures = /^while +([^\n]+)/.exec(this.input)) {
      this.consume(captures[0].length);
      assertExpression(captures[1])
      var tok = this.tok('code', 'while (' + captures[1] + ')');
      tok.requiresBlock = true;
      return tok;
    }
  },

  /**
   * Each.
   */

  each: function() {
    var captures;
    if (captures = /^(?:- *)?(?:each|for) +([a-zA-Z_$][\w$]*)(?: *, *([a-zA-Z_$][\w$]*))? * in *([^\n]+)/.exec(this.input)) {
      this.consume(captures[0].length);
      var tok = this.tok('each', captures[1]);
      tok.key = captures[2] || '$index';
      assertExpression(captures[3])
      tok.code = captures[3];
      return tok;
    }
  },

  /**
   * Code.
   */

  code: function() {
    var captures;
    if (captures = /^(!?=|-)[ \t]*([^\n]+)/.exec(this.input)) {
      this.consume(captures[0].length);
      var flags = captures[1];
      captures[1] = captures[2];
      var tok = this.tok('code', captures[1]);
      tok.escape = flags.charAt(0) === '=';
      tok.buffer = flags.charAt(0) === '=' || flags.charAt(1) === '=';
      if (tok.buffer) assertExpression(captures[1])
      return tok;
    }
  },

  /**
   * Attributes.
   */

  attrs: function() {
    if ('(' == this.input.charAt(0)) {
      var index = this.bracketExpression().end
        , str = this.input.substr(1, index-1)
        , tok = this.tok('attrs');

      assertNestingCorrect(str);

      var quote = '';
      var interpolate = function (attr) {
        return attr.replace(/(\\)?#\{(.+)/g, function(_, escape, expr){
          if (escape) return _;
          try {
            var range = characterParser.parseMax(expr);
            if (expr[range.end] !== '}') return _.substr(0, 2) + interpolate(_.substr(2));
            assertExpression(range.src)
            return quote + " + (" + range.src + ") + " + quote + interpolate(expr.substr(range.end + 1));
          } catch (ex) {
            return _.substr(0, 2) + interpolate(_.substr(2));
          }
        });
      }

      this.consume(index + 1);
      tok.attrs = [];

      var escapedAttr = true
      var key = '';
      var val = '';
      var interpolatable = '';
      var state = characterParser.defaultState();
      var loc = 'key';
      var isEndOfAttribute = function (i) {
        if (key.trim() === '') return false;
        if (i === str.length) return true;
        if (loc === 'key') {
          if (str[i] === ' ' || str[i] === '\n') {
            for (var x = i; x < str.length; x++) {
              if (str[x] != ' ' && str[x] != '\n') {
                if (str[x] === '=' || str[x] === '!' || str[x] === ',') return false;
                else return true;
              }
            }
          }
          return str[i] === ','
        } else if (loc === 'value' && !state.isNesting()) {
          try {
            Function('', 'return (' + val + ');');
            if (str[i] === ' ' || str[i] === '\n') {
              for (var x = i; x < str.length; x++) {
                if (str[x] != ' ' && str[x] != '\n') {
                  if (characterParser.isPunctuator(str[x]) && str[x] != '"' && str[x] != "'") return false;
                  else return true;
                }
              }
            }
            return str[i] === ',';
          } catch (ex) {
            return false;
          }
        }
      }

      this.lineno += str.split("\n").length - 1;

      for (var i = 0; i <= str.length; i++) {
        if (isEndOfAttribute(i)) {
          val = val.trim();
          if (val) assertExpression(val)
          key = key.trim();
          key = key.replace(/^['"]|['"]$/g, '');
          tok.attrs.push({
            name: key,
            val: '' == val ? true : val,
            escaped: escapedAttr
          });
          key = val = '';
          loc = 'key';
          escapedAttr = false;
        } else {
          switch (loc) {
            case 'key-char':
              if (str[i] === quote) {
                loc = 'key';
                if (i + 1 < str.length && [' ', ',', '!', '=', '\n'].indexOf(str[i + 1]) === -1)
                  throw new Error('Unexpected character ' + str[i + 1] + ' expected ` `, `\\n`, `,`, `!` or `=`');
              } else {
                key += str[i];
              }
              break;
            case 'key':
              if (key === '' && (str[i] === '"' || str[i] === "'")) {
                loc = 'key-char';
                quote = str[i];
              } else if (str[i] === '!' || str[i] === '=') {
                escapedAttr = str[i] !== '!';
                if (str[i] === '!') i++;
                if (str[i] !== '=') throw new Error('Unexpected character ' + str[i] + ' expected `=`');
                loc = 'value';
                state = characterParser.defaultState();
              } else {
                key += str[i]
              }
              break;
            case 'value':
              state = characterParser.parseChar(str[i], state);
              if (state.isString()) {
                loc = 'string';
                quote = str[i];
                interpolatable = str[i];
              } else {
                val += str[i];
              }
              break;
            case 'string':
              state = characterParser.parseChar(str[i], state);
              interpolatable += str[i];
              if (!state.isString()) {
                loc = 'value';
                val += interpolate(interpolatable);
              }
              break;
          }
        }
      }

      if ('/' == this.input.charAt(0)) {
        this.consume(1);
        tok.selfClosing = true;
      }

      return tok;
    }
  },

  /**
   * &attributes block
   */
  attributesBlock: function () {
    var captures;
    if (/^&attributes\b/.test(this.input)) {
      this.consume(11);
      var args = this.bracketExpression();
      this.consume(args.end + 1);
      return this.tok('&attributes', args.src);
    }
  },

  /**
   * Indent | Outdent | Newline.
   */

  indent: function() {
    var captures, re;

    // established regexp
    if (this.indentRe) {
      captures = this.indentRe.exec(this.input);
    // determine regexp
    } else {
      // tabs
      re = /^\n(\t*) */;
      captures = re.exec(this.input);

      // spaces
      if (captures && !captures[1].length) {
        re = /^\n( *)/;
        captures = re.exec(this.input);
      }

      // established
      if (captures && captures[1].length) this.indentRe = re;
    }

    if (captures) {
      var tok
        , indents = captures[1].length;

      ++this.lineno;
      this.consume(indents + 1);

      if (' ' == this.input[0] || '\t' == this.input[0]) {
        throw new Error('Invalid indentation, you can use tabs or spaces but not both');
      }

      // blank line
      if ('\n' == this.input[0]) {
        this.pipeless = false;
        return this.tok('newline');
      }

      // outdent
      if (this.indentStack.length && indents < this.indentStack[0]) {
        while (this.indentStack.length && this.indentStack[0] > indents) {
          this.stash.push(this.tok('outdent'));
          this.indentStack.shift();
        }
        tok = this.stash.pop();
      // indent
      } else if (indents && indents != this.indentStack[0]) {
        this.indentStack.unshift(indents);
        tok = this.tok('indent', indents);
      // newline
      } else {
        tok = this.tok('newline');
      }

      this.pipeless = false;
      return tok;
    }
  },

  /**
   * Pipe-less text consumed only when
   * pipeless is true;
   */

  pipelessText: function() {
    if (!this.pipeless) return;
    var captures, re;

    // established regexp
    if (this.indentRe) {
      captures = this.indentRe.exec(this.input);
    // determine regexp
    } else {
      // tabs
      re = /^\n(\t*) */;
      captures = re.exec(this.input);

      // spaces
      if (captures && !captures[1].length) {
        re = /^\n( *)/;
        captures = re.exec(this.input);
      }

      // established
      if (captures && captures[1].length) this.indentRe = re;
    }

    var indents = captures && captures[1].length;
    if (indents && (this.indentStack.length === 0 || indents > this.indentStack[0])) {
      var indent = captures[1];
      var line;
      var tokens = [];
      var isMatch;
      do {
        // text has `\n` as a prefix
        var i = this.input.substr(1).indexOf('\n');
        if (-1 == i) i = this.input.length - 1;
        var str = this.input.substr(1, i);
        isMatch = str.substr(0, indent.length) === indent || !str.trim();
        if (isMatch) {
          // consume test along with `\n` prefix if match
          this.consume(str.length + 1);
          tokens.push(str.substr(indent.length));
        }
      } while(this.input.length && isMatch);
      while (this.input.length === 0 && tokens[tokens.length - 1] === '') tokens.pop();
      return this.tok('pipeless-text', tokens);
    }
  },

  /**
   * ':'
   */

  colon: function() {
    return this.scan(/^: */, ':');
  },

  fail: function () {
    if (/^ ($|\n)/.test(this.input)) {
      this.consume(1);
      return this.next();
    }
    throw new Error('unexpected text ' + this.input.substr(0, 5));
  },

  /**
   * Return the next token object, or those
   * previously stashed by lookahead.
   *
   * @return {Object}
   * @api private
   */

  advance: function(){
    return this.stashed()
      || this.next();
  },

  /**
   * Return the next token object.
   *
   * @return {Object}
   * @api private
   */

  next: function() {
    return this.deferred()
      || this.blank()
      || this.eos()
      || this.pipelessText()
      || this.yield()
      || this.doctype()
      || this.interpolation()
      || this["case"]()
      || this.when()
      || this["default"]()
      || this["extends"]()
      || this.append()
      || this.prepend()
      || this.block()
      || this.mixinBlock()
      || this.include()
      || this.includeFiltered()
      || this.mixin()
      || this.call()
      || this.conditional()
      || this.each()
      || this["while"]()
      || this.tag()
      || this.filter()
      || this.code()
      || this.id()
      || this.className()
      || this.attrs()
      || this.attributesBlock()
      || this.indent()
      || this.text()
      || this.comment()
      || this.colon()
      || this.dot()
      || this.textFail()
      || this.fail();
  }
};


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

var Node = __webpack_require__(0);

/**
 * Initialize a `Attrs` node.
 *
 * @api public
 */

var Attrs = module.exports = function Attrs() {
  this.attributeNames = [];
  this.attrs = [];
  this.attributeBlocks = [];
};

// Inherit from `Node`.
Attrs.prototype = Object.create(Node.prototype);
Attrs.prototype.constructor = Attrs;

Attrs.prototype.type = 'Attrs';

/**
 * Set attribute `name` to `val`, keep in mind these become
 * part of a raw js object literal, so to quote a value you must
 * '"quote me"', otherwise or example 'user.name' is literal JavaScript.
 *
 * @param {String} name
 * @param {String} val
 * @param {Boolean} escaped
 * @return {Tag} for chaining
 * @api public
 */

Attrs.prototype.setAttribute = function(name, val, escaped){
  if (name !== 'class' && this.attributeNames.indexOf(name) !== -1) {
    throw new Error('Duplicate attribute "' + name + '" is not allowed.');
  }
  this.attributeNames.push(name);
  this.attrs.push({ name: name, val: val, escaped: escaped });
  return this;
};

/**
 * Remove attribute `name` when present.
 *
 * @param {String} name
 * @api public
 */

Attrs.prototype.removeAttribute = function(name){
  var err = new Error('attrs.removeAttribute is deprecated and will be removed in v2.0.0');
  console.warn(err.stack);

  for (var i = 0, len = this.attrs.length; i < len; ++i) {
    if (this.attrs[i] && this.attrs[i].name == name) {
      delete this.attrs[i];
    }
  }
};

/**
 * Get attribute value by `name`.
 *
 * @param {String} name
 * @return {String}
 * @api public
 */

Attrs.prototype.getAttribute = function(name){
  var err = new Error('attrs.getAttribute is deprecated and will be removed in v2.0.0');
  console.warn(err.stack);

  for (var i = 0, len = this.attrs.length; i < len; ++i) {
    if (this.attrs[i] && this.attrs[i].name == name) {
      return this.attrs[i].val;
    }
  }
};

Attrs.prototype.addAttributes = function (src) {
  this.attributeBlocks.push(src);
};


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

var Node = __webpack_require__(0);

/**
 * Initialize a new `Block` with an optional `node`.
 *
 * @param {Node} node
 * @api public
 */

var Block = module.exports = function Block(node){
  this.nodes = [];
  if (node) this.push(node);
};

// Inherit from `Node`.
Block.prototype = Object.create(Node.prototype);
Block.prototype.constructor = Block;

Block.prototype.type = 'Block';

/**
 * Block flag.
 */

Block.prototype.isBlock = true;

/**
 * Replace the nodes in `other` with the nodes
 * in `this` block.
 *
 * @param {Block} other
 * @api private
 */

Block.prototype.replace = function(other){
  var err = new Error('block.replace is deprecated and will be removed in v2.0.0');
  console.warn(err.stack);

  other.nodes = this.nodes;
};

/**
 * Push the given `node`.
 *
 * @param {Node} node
 * @return {Number}
 * @api public
 */

Block.prototype.push = function(node){
  return this.nodes.push(node);
};

/**
 * Check if this block is empty.
 *
 * @return {Boolean}
 * @api public
 */

Block.prototype.isEmpty = function(){
  return 0 == this.nodes.length;
};

/**
 * Unshift the given `node`.
 *
 * @param {Node} node
 * @return {Number}
 * @api public
 */

Block.prototype.unshift = function(node){
  return this.nodes.unshift(node);
};

/**
 * Return the "last" block, or the first `yield` node.
 *
 * @return {Block}
 * @api private
 */

Block.prototype.includeBlock = function(){
  var ret = this
    , node;

  for (var i = 0, len = this.nodes.length; i < len; ++i) {
    node = this.nodes[i];
    if (node.yield) return node;
    else if (node.textOnly) continue;
    else if (node.includeBlock) ret = node.includeBlock();
    else if (node.block && !node.block.isEmpty()) ret = node.block.includeBlock();
    if (ret.yield) return ret;
  }

  return ret;
};

/**
 * Return a clone of this block.
 *
 * @return {Block}
 * @api private
 */

Block.prototype.clone = function(){
  var err = new Error('block.clone is deprecated and will be removed in v2.0.0');
  console.warn(err.stack);

  var clone = new Block;
  for (var i = 0, len = this.nodes.length; i < len; ++i) {
    clone.push(this.nodes[i].clone());
  }
  return clone;
};


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

/**
 * Merge two attribute objects giving precedence
 * to values in object `b`. Classes are special-cased
 * allowing for arrays and merging/joining appropriately
 * resulting in a string.
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 * @api private
 */

exports.merge = function merge(a, b) {
  if (arguments.length === 1) {
    var attrs = a[0];
    for (var i = 1; i < a.length; i++) {
      attrs = merge(attrs, a[i]);
    }
    return attrs;
  }
  var ac = a['class'];
  var bc = b['class'];

  if (ac || bc) {
    ac = ac || [];
    bc = bc || [];
    if (!Array.isArray(ac)) ac = [ac];
    if (!Array.isArray(bc)) bc = [bc];
    a['class'] = ac.concat(bc).filter(nulls);
  }

  for (var key in b) {
    if (key != 'class') {
      a[key] = b[key];
    }
  }

  return a;
};

/**
 * Filter null `val`s.
 *
 * @param {*} val
 * @return {Boolean}
 * @api private
 */

function nulls(val) {
  return val != null && val !== '';
}

/**
 * join array as classes.
 *
 * @param {*} val
 * @return {String}
 */
exports.joinClasses = joinClasses;
function joinClasses(val) {
  return Array.isArray(val) ? val.map(joinClasses).filter(nulls).join(' ') : val;
}

/**
 * Render the given classes.
 *
 * @param {Array} classes
 * @param {Array.<Boolean>} escaped
 * @return {String}
 */
exports.cls = function cls(classes, escaped) {
  var buf = [];
  for (var i = 0; i < classes.length; i++) {
    if (escaped && escaped[i]) {
      buf.push(exports.escape(joinClasses([classes[i]])));
    } else {
      buf.push(joinClasses(classes[i]));
    }
  }
  var text = joinClasses(buf);
  if (text.length) {
    return ' class="' + text + '"';
  } else {
    return '';
  }
};

/**
 * Render the given attribute.
 *
 * @param {String} key
 * @param {String} val
 * @param {Boolean} escaped
 * @param {Boolean} terse
 * @return {String}
 */
exports.attr = function attr(key, val, escaped, terse) {
  if ('boolean' == typeof val || null == val) {
    if (val) {
      return ' ' + (terse ? key : key + '="' + key + '"');
    } else {
      return '';
    }
  } else if (0 == key.indexOf('data') && 'string' != typeof val) {
    return ' ' + key + "='" + JSON.stringify(val).replace(/'/g, '&apos;') + "'";
  } else if (escaped) {
    return ' ' + key + '="' + exports.escape(val) + '"';
  } else {
    return ' ' + key + '="' + val + '"';
  }
};

/**
 * Render the given attributes object.
 *
 * @param {Object} obj
 * @param {Object} escaped
 * @return {String}
 */
exports.attrs = function attrs(obj, terse){
  var buf = [];

  var keys = Object.keys(obj);

  if (keys.length) {
    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i]
        , val = obj[key];

      if ('class' == key) {
        if (val = joinClasses(val)) {
          buf.push(' ' + key + '="' + val + '"');
        }
      } else {
        buf.push(exports.attr(key, val, false, terse));
      }
    }
  }

  return buf.join('');
};

/**
 * Escape the given string of `html`.
 *
 * @param {String} html
 * @return {String}
 * @api private
 */

exports.escape = function escape(html){
  var result = String(html)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
  if (result === '' + html) return html;
  else return result;
};

/**
 * Re-throw the given `err` in context to the
 * the jade in `filename` at the given `lineno`.
 *
 * @param {Error} err
 * @param {String} filename
 * @param {String} lineno
 * @api private
 */

exports.rethrow = function rethrow(err, filename, lineno, str){
  if (!(err instanceof Error)) throw err;
  if ((typeof window != 'undefined' || !filename) && !str) {
    err.message += ' on line ' + lineno;
    throw err;
  }
  try {
    str = str || __webpack_require__(2).readFileSync(filename, 'utf8')
  } catch (ex) {
    rethrow(err, null, lineno)
  }
  var context = 3
    , lines = str.split('\n')
    , start = Math.max(lineno - context, 0)
    , end = Math.min(lines.length, lineno + context);

  // Error context
  var context = lines.slice(start, end).map(function(line, i){
    var curr = i + start + 1;
    return (curr == lineno ? '  > ' : '    ')
      + curr
      + '| '
      + line;
  }).join('\n');

  // Alter exception message
  err.path = filename;
  err.message = (filename || 'Jade') + ':' + lineno
    + '\n' + context + '\n\n' + err.message;
  throw err;
};


/***/ },
/* 12 */
/***/ function(module, exports) {

"use strict";
'use strict';

// source: http://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements

module.exports = [
    'area'
  , 'base'
  , 'br'
  , 'col'
  , 'embed'
  , 'hr'
  , 'img'
  , 'input'
  , 'keygen'
  , 'link'
  , 'menuitem'
  , 'meta'
  , 'param'
  , 'source'
  , 'track'
  , 'wbr'
];


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict'

var uglify = __webpack_require__(6)

var lastSRC = '(null)'
var lastRes = true
var lastConstants = undefined;

module.exports = isConstant
function isConstant(src, constants) {
  src = '(' + src + ')'
  if (lastSRC === src && lastConstants === constants) return lastRes
  lastSRC = src
  try {
    return lastRes = (detect(src).filter(function (key) {
      return !constants || !(key in constants)
    }).length === 0)
  } catch (ex) {
    return lastRes = false
  }
}
isConstant.isConstant = isConstant

isConstant.toConstant = toConstant
function toConstant(src, constants) {
  if (!isConstant(src, constants)) throw new Error(JSON.stringify(src) + ' is not constant.')
  return Function(Object.keys(constants || {}).join(','), 'return (' + src + ')').apply(null, Object.keys(constants || {}).map(function (key) {
    return constants[key];
  }));
}

function detect(src) {
  var ast = uglify.parse(src.toString())
  ast.figure_out_scope()
  var globals = ast.globals
    .map(function (node, name) {
      return name
    })
  
  // Walk the AST tree in search for `this`
  // Add a fake "this" global when found
  var has_this = false;
  var walker = new uglify.TreeWalker(function(node) {
    if (node instanceof uglify.AST_This) {
      has_this = true;
    }
  });
  ast.walk(walker);
  if (has_this) {
    globals.push('this')
  }
  
  return globals
}


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(32)))

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

/*!
 * Jade
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Parser = __webpack_require__(30)
  , Lexer = __webpack_require__(8)
  , Compiler = __webpack_require__(16)
  , runtime = __webpack_require__(11)
  , addWith = __webpack_require__(31)
  , fs = __webpack_require__(2);

/**
 * Expose self closing tags.
 */

exports.selfClosing = __webpack_require__(12);

/**
 * Default supported doctypes.
 */

exports.doctypes = __webpack_require__(7);

/**
 * Text filters.
 */

exports.filters = __webpack_require__(3);

/**
 * Utilities.
 */

exports.utils = __webpack_require__(1);

/**
 * Expose `Compiler`.
 */

exports.Compiler = Compiler;

/**
 * Expose `Parser`.
 */

exports.Parser = Parser;

/**
 * Expose `Lexer`.
 */

exports.Lexer = Lexer;

/**
 * Nodes.
 */

exports.nodes = __webpack_require__(4);

/**
 * Jade runtime helpers.
 */

exports.runtime = runtime;

/**
 * Template function cache.
 */

exports.cache = {};

/**
 * Parse the given `str` of jade and return a function body.
 *
 * @param {String} str
 * @param {Object} options
 * @return {Object}
 * @api private
 */

function parse(str, options){
  // Parse
  var parser = new (options.parser || Parser)(str, options.filename, options);
  var tokens;
  try {
    // Parse
    tokens = parser.parse();
  } catch (err) {
    parser = parser.context();
    runtime.rethrow(err, parser.filename, parser.lexer.lineno, parser.input);
  }

  // Compile
  var compiler = new (options.compiler || Compiler)(tokens, options);
  var js;
  try {
    js = compiler.compile();
  } catch (err) {
    if (err.line && (err.filename || !options.filename)) {
      runtime.rethrow(err, err.filename, err.line, parser.input);
    }
  }

  // Debug compiler
  if (options.debug) {
    console.error('\nCompiled Function:\n\n\u001b[90m%s\u001b[0m', js.replace(/^/gm, '  '));
  }

  var globals = [];

  globals.push('jade');
  globals.push('jade_mixins');
  globals.push('jade_interp');
  globals.push('jade_debug');
  globals.push('buf');

  var body = ''
    + 'var buf = [];\n'
    + 'var jade_mixins = {};\n'
    + 'var jade_interp;\n'
    + (options.self
      ? 'var self = locals || {};\n' + js
      : addWith('locals || {}', '\n' + js, globals)) + ';'
    + 'return buf.join("");';
  return {body: body, dependencies: parser.dependencies};
}

/**
 * Compile a `Function` representation of the given jade `str`.
 *
 * Options:
 *
 *   - `compileDebug` when `false` debugging code is stripped from the compiled
       template, when it is explicitly `true`, the source code is included in
       the compiled template for better accuracy.
 *   - `filename` used to improve errors when `compileDebug` is not `false` and to resolve imports/extends
 *
 * @param {String} str
 * @param {Options} options
 * @return {Function}
 * @api public
 */

exports.compile = function(str, options){
  var options = options || {}
    , filename = options.filename
      ? JSON.stringify(options.filename)
      : 'undefined'
    , fn;

  str = String(str);

  var parsed = parse(str, options);
  if (options.compileDebug !== false) {
    fn = [
        'var jade_debug = [{ lineno: 1, filename: ' + filename + ' }];'
      , 'try {'
      , parsed.body
      , '} catch (err) {'
      , '  jade.rethrow(err, jade_debug[0].filename, jade_debug[0].lineno' + (options.compileDebug === true ? ',' + JSON.stringify(str) : '') + ');'
      , '}'
    ].join('\n');
  } else {
    fn = parsed.body;
  }
  fn = new Function('locals, jade', fn)
  var res = function(locals){ return fn(locals, Object.create(runtime)) };
  if (options.client) {
    res.toString = function () {
      var err = new Error('The `client` option is deprecated, use the `jade.compileClient` method instead');
      err.name = 'Warning';
      console.error(err.stack || err.message);
      return exports.compileClient(str, options);
    };
  }
  res.dependencies = parsed.dependencies;
  return res;
};

/**
 * Compile a JavaScript source representation of the given jade `str`.
 *
 * Options:
 *
 *   - `compileDebug` When it is `true`, the source code is included in
 *     the compiled template for better error messages.
 *   - `filename` used to improve errors when `compileDebug` is not `true` and to resolve imports/extends
 *   - `name` the name of the resulting function (defaults to "template")
 *
 * @param {String} str
 * @param {Options} options
 * @return {String}
 * @api public
 */

exports.compileClient = function(str, options){
  var options = options || {};
  var name = options.name || 'template';
  var filename = options.filename ? JSON.stringify(options.filename) : 'undefined';
  var fn;

  str = String(str);

  if (options.compileDebug) {
    options.compileDebug = true;
    fn = [
        'var jade_debug = [{ lineno: 1, filename: ' + filename + ' }];'
      , 'try {'
      , parse(str, options).body
      , '} catch (err) {'
      , '  jade.rethrow(err, jade_debug[0].filename, jade_debug[0].lineno, ' + JSON.stringify(str) + ');'
      , '}'
    ].join('\n');
  } else {
    options.compileDebug = false;
    fn = parse(str, options).body;
  }

  return 'function ' + name + '(locals) {\n' + fn + '\n}';
};



/**
 * Render the given `str` of jade.
 *
 * Options:
 *
 *   - `cache` enable template caching
 *   - `filename` filename required for `include` / `extends` and caching
 *
 * @param {String} str
 * @param {Object|Function} options or fn
 * @param {Function|undefined} fn
 * @returns {String}
 * @api public
 */

exports.render = function(str, options, fn){
  // support callback API
  if ('function' == typeof options) {
    fn = options, options = undefined;
  }
  if (typeof fn === 'function') {
    var res
    try {
      res = exports.render(str, options);
    } catch (ex) {
      return fn(ex);
    }
    return fn(null, res);
  }

  options = options || {};

  // cache requires .filename
  if (options.cache && !options.filename) {
    throw new Error('the "filename" option is required for caching');
  }

  var path = options.filename;
  var tmpl = options.cache
    ? exports.cache[path] || (exports.cache[path] = exports.compile(str, options))
    : exports.compile(str, options);
  return tmpl(options);
};

/**
 * Render a Jade file at the given `path`.
 *
 * @param {String} path
 * @param {Object|Function} options or callback
 * @param {Function|undefined} fn
 * @returns {String}
 * @api public
 */

exports.renderFile = function(path, options, fn){
  // support callback API
  if ('function' == typeof options) {
    fn = options, options = undefined;
  }
  if (typeof fn === 'function') {
    var res
    try {
      res = exports.renderFile(path, options);
    } catch (ex) {
      return fn(ex);
    }
    return fn(null, res);
  }

  options = options || {};

  var key = path + ':string';

  options.filename = path;
  var str = options.cache
    ? exports.cache[key] || (exports.cache[key] = fs.readFileSync(path, 'utf8'))
    : fs.readFileSync(path, 'utf8');
  return exports.render(str, options);
};


/**
 * Compile a Jade file at the given `path` for use on the client.
 *
 * @param {String} path
 * @param {Object} options
 * @returns {String}
 * @api public
 */

exports.compileFileClient = function(path, options){
  options = options || {};

  var key = path + ':string';

  options.filename = path;
  var str = options.cache
    ? exports.cache[key] || (exports.cache[key] = fs.readFileSync(path, 'utf8'))
    : fs.readFileSync(path, 'utf8');

  return exports.compileClient(str, options);
};

/**
 * Express support.
 */

exports.__express = exports.renderFile;


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

var nodes = __webpack_require__(4);
var filters = __webpack_require__(3);
var doctypes = __webpack_require__(7);
var runtime = __webpack_require__(11);
var utils = __webpack_require__(1);
var selfClosing = __webpack_require__(12);
var parseJSExpression = __webpack_require__(5).parseMax;
var constantinople = __webpack_require__(13);

function isConstant(src) {
  return constantinople(src, {jade: runtime, 'jade_interp': undefined});
}
function toConstant(src) {
  return constantinople.toConstant(src, {jade: runtime, 'jade_interp': undefined});
}
function errorAtNode(node, error) {
  error.line = node.line;
  error.filename = node.filename;
  return error;
}

/**
 * Initialize `Compiler` with the given `node`.
 *
 * @param {Node} node
 * @param {Object} options
 * @api public
 */

var Compiler = module.exports = function Compiler(node, options) {
  this.options = options = options || {};
  this.node = node;
  this.hasCompiledDoctype = false;
  this.hasCompiledTag = false;
  this.pp = options.pretty || false;
  this.debug = false !== options.compileDebug;
  this.indents = 0;
  this.parentIndents = 0;
  this.terse = false;
  this.mixins = {};
  this.dynamicMixins = false;
  if (options.doctype) this.setDoctype(options.doctype);
};

/**
 * Compiler prototype.
 */

Compiler.prototype = {

  /**
   * Compile parse tree to JavaScript.
   *
   * @api public
   */

  compile: function(){
    this.buf = [];
    if (this.pp) this.buf.push("var jade_indent = [];");
    this.lastBufferedIdx = -1;
    this.visit(this.node);
    if (!this.dynamicMixins) {
      // if there are no dynamic mixins we can remove any un-used mixins
      var mixinNames = Object.keys(this.mixins);
      for (var i = 0; i < mixinNames.length; i++) {
        var mixin = this.mixins[mixinNames[i]];
        if (!mixin.used) {
          for (var x = 0; x < mixin.instances.length; x++) {
            for (var y = mixin.instances[x].start; y < mixin.instances[x].end; y++) {
              this.buf[y] = '';
            }
          }
        }
      }
    }
    return this.buf.join('\n');
  },

  /**
   * Sets the default doctype `name`. Sets terse mode to `true` when
   * html 5 is used, causing self-closing tags to end with ">" vs "/>",
   * and boolean attributes are not mirrored.
   *
   * @param {string} name
   * @api public
   */

  setDoctype: function(name){
    this.doctype = doctypes[name.toLowerCase()] || '<!DOCTYPE ' + name + '>';
    this.terse = this.doctype.toLowerCase() == '<!doctype html>';
    this.xml = 0 == this.doctype.indexOf('<?xml');
  },

  /**
   * Buffer the given `str` exactly as is or with interpolation
   *
   * @param {String} str
   * @param {Boolean} interpolate
   * @api public
   */

  buffer: function (str, interpolate) {
    var self = this;
    if (interpolate) {
      var match = /(\\)?([#!]){((?:.|\n)*)$/.exec(str);
      if (match) {
        this.buffer(str.substr(0, match.index), false);
        if (match[1]) { // escape
          this.buffer(match[2] + '{', false);
          this.buffer(match[3], true);
          return;
        } else {
          var rest = match[3];
          var range = parseJSExpression(rest);
          var code = ('!' == match[2] ? '' : 'jade.escape') + "((jade_interp = " + range.src + ") == null ? '' : jade_interp)";
          this.bufferExpression(code);
          this.buffer(rest.substr(range.end + 1), true);
          return;
        }
      }
    }

    str = JSON.stringify(str);
    str = str.substr(1, str.length - 2);

    if (this.lastBufferedIdx == this.buf.length) {
      if (this.lastBufferedType === 'code') this.lastBuffered += ' + "';
      this.lastBufferedType = 'text';
      this.lastBuffered += str;
      this.buf[this.lastBufferedIdx - 1] = 'buf.push(' + this.bufferStartChar + this.lastBuffered + '");'
    } else {
      this.buf.push('buf.push("' + str + '");');
      this.lastBufferedType = 'text';
      this.bufferStartChar = '"';
      this.lastBuffered = str;
      this.lastBufferedIdx = this.buf.length;
    }
  },

  /**
   * Buffer the given `src` so it is evaluated at run time
   *
   * @param {String} src
   * @api public
   */

  bufferExpression: function (src) {
    if (isConstant(src)) {
      return this.buffer(toConstant(src) + '', false)
    }
    if (this.lastBufferedIdx == this.buf.length) {
      if (this.lastBufferedType === 'text') this.lastBuffered += '"';
      this.lastBufferedType = 'code';
      this.lastBuffered += ' + (' + src + ')';
      this.buf[this.lastBufferedIdx - 1] = 'buf.push(' + this.bufferStartChar + this.lastBuffered + ');'
    } else {
      this.buf.push('buf.push(' + src + ');');
      this.lastBufferedType = 'code';
      this.bufferStartChar = '';
      this.lastBuffered = '(' + src + ')';
      this.lastBufferedIdx = this.buf.length;
    }
  },

  /**
   * Buffer an indent based on the current `indent`
   * property and an additional `offset`.
   *
   * @param {Number} offset
   * @param {Boolean} newline
   * @api public
   */

  prettyIndent: function(offset, newline){
    offset = offset || 0;
    newline = newline ? '\n' : '';
    this.buffer(newline + Array(this.indents + offset).join('  '));
    if (this.parentIndents)
      this.buf.push("buf.push.apply(buf, jade_indent);");
  },

  /**
   * Visit `node`.
   *
   * @param {Node} node
   * @api public
   */

  visit: function(node){
    var debug = this.debug;

    if (debug) {
      this.buf.push('jade_debug.unshift({ lineno: ' + node.line
        + ', filename: ' + (node.filename
          ? JSON.stringify(node.filename)
          : 'jade_debug[0].filename')
        + ' });');
    }

    // Massive hack to fix our context
    // stack for - else[ if] etc
    if (false === node.debug && this.debug) {
      this.buf.pop();
      this.buf.pop();
    }

    this.visitNode(node);

    if (debug) this.buf.push('jade_debug.shift();');
  },

  /**
   * Visit `node`.
   *
   * @param {Node} node
   * @api public
   */

  visitNode: function(node){
    return this['visit' + node.type](node);
  },

  /**
   * Visit case `node`.
   *
   * @param {Literal} node
   * @api public
   */

  visitCase: function(node){
    var _ = this.withinCase;
    this.withinCase = true;
    this.buf.push('switch (' + node.expr + '){');
    this.visit(node.block);
    this.buf.push('}');
    this.withinCase = _;
  },

  /**
   * Visit when `node`.
   *
   * @param {Literal} node
   * @api public
   */

  visitWhen: function(node){
    if ('default' == node.expr) {
      this.buf.push('default:');
    } else {
      this.buf.push('case ' + node.expr + ':');
    }
    if (node.block) {
      this.visit(node.block);
      this.buf.push('  break;');
    }
  },

  /**
   * Visit literal `node`.
   *
   * @param {Literal} node
   * @api public
   */

  visitLiteral: function(node){
    this.buffer(node.str);
  },

  /**
   * Visit all nodes in `block`.
   *
   * @param {Block} block
   * @api public
   */

  visitBlock: function(block){
    var len = block.nodes.length
      , escape = this.escape
      , pp = this.pp

    // Pretty print multi-line text
    if (pp && len > 1 && !escape && block.nodes[0].isText && block.nodes[1].isText)
      this.prettyIndent(1, true);

    for (var i = 0; i < len; ++i) {
      // Pretty print text
      if (pp && i > 0 && !escape && block.nodes[i].isText && block.nodes[i-1].isText)
        this.prettyIndent(1, false);

      this.visit(block.nodes[i]);
      // Multiple text nodes are separated by newlines
      if (block.nodes[i+1] && block.nodes[i].isText && block.nodes[i+1].isText)
        this.buffer('\n');
    }
  },

  /**
   * Visit a mixin's `block` keyword.
   *
   * @param {MixinBlock} block
   * @api public
   */

  visitMixinBlock: function(block){
    if (this.pp) this.buf.push("jade_indent.push('" + Array(this.indents + 1).join('  ') + "');");
    this.buf.push('block && block();');
    if (this.pp) this.buf.push("jade_indent.pop();");
  },

  /**
   * Visit `doctype`. Sets terse mode to `true` when html 5
   * is used, causing self-closing tags to end with ">" vs "/>",
   * and boolean attributes are not mirrored.
   *
   * @param {Doctype} doctype
   * @api public
   */

  visitDoctype: function(doctype){
    if (doctype && (doctype.val || !this.doctype)) {
      this.setDoctype(doctype.val || 'default');
    }

    if (this.doctype) this.buffer(this.doctype);
    this.hasCompiledDoctype = true;
  },

  /**
   * Visit `mixin`, generating a function that
   * may be called within the template.
   *
   * @param {Mixin} mixin
   * @api public
   */

  visitMixin: function(mixin){
    var name = 'jade_mixins[';
    var args = mixin.args || '';
    var block = mixin.block;
    var attrs = mixin.attrs;
    var attrsBlocks = mixin.attributeBlocks;
    var pp = this.pp;
    var dynamic = mixin.name[0]==='#';
    var key = mixin.name;
    if (dynamic) this.dynamicMixins = true;
    name += (dynamic ? mixin.name.substr(2,mixin.name.length-3):'"'+mixin.name+'"')+']';

    this.mixins[key] = this.mixins[key] || {used: false, instances: []};
    if (mixin.call) {
      this.mixins[key].used = true;
      if (pp) this.buf.push("jade_indent.push('" + Array(this.indents + 1).join('  ') + "');")
      if (block || attrs.length || attrsBlocks.length) {

        this.buf.push(name + '.call({');

        if (block) {
          this.buf.push('block: function(){');

          // Render block with no indents, dynamically added when rendered
          this.parentIndents++;
          var _indents = this.indents;
          this.indents = 0;
          this.visit(mixin.block);
          this.indents = _indents;
          this.parentIndents--;

          if (attrs.length || attrsBlocks.length) {
            this.buf.push('},');
          } else {
            this.buf.push('}');
          }
        }

        if (attrsBlocks.length) {
          if (attrs.length) {
            var val = this.attrs(attrs);
            attrsBlocks.unshift(val);
          }
          this.buf.push('attributes: jade.merge([' + attrsBlocks.join(',') + '])');
        } else if (attrs.length) {
          var val = this.attrs(attrs);
          this.buf.push('attributes: ' + val);
        }

        if (args) {
          this.buf.push('}, ' + args + ');');
        } else {
          this.buf.push('});');
        }

      } else {
        this.buf.push(name + '(' + args + ');');
      }
      if (pp) this.buf.push("jade_indent.pop();")
    } else {
      var mixin_start = this.buf.length;
      this.buf.push(name + ' = function(' + args + '){');
      this.buf.push('var block = (this && this.block), attributes = (this && this.attributes) || {};');
      this.parentIndents++;
      this.visit(block);
      this.parentIndents--;
      this.buf.push('};');
      var mixin_end = this.buf.length;
      this.mixins[key].instances.push({start: mixin_start, end: mixin_end});
    }
  },

  /**
   * Visit `tag` buffering tag markup, generating
   * attributes, visiting the `tag`'s code and block.
   *
   * @param {Tag} tag
   * @api public
   */

  visitTag: function(tag){
    this.indents++;
    var name = tag.name
      , pp = this.pp
      , self = this;

    function bufferName() {
      if (tag.buffer) self.bufferExpression(name);
      else self.buffer(name);
    }

    if ('pre' == tag.name) this.escape = true;

    if (!this.hasCompiledTag) {
      if (!this.hasCompiledDoctype && 'html' == name) {
        this.visitDoctype();
      }
      this.hasCompiledTag = true;
    }

    // pretty print
    if (pp && !tag.isInline())
      this.prettyIndent(0, true);

    if (tag.selfClosing || (!this.xml && selfClosing.indexOf(tag.name) !== -1)) {
      this.buffer('<');
      bufferName();
      this.visitAttributes(tag.attrs, tag.attributeBlocks);
      this.terse
        ? this.buffer('>')
        : this.buffer('/>');
      // if it is non-empty throw an error
      if (tag.block &&
          !(tag.block.type === 'Block' && tag.block.nodes.length === 0) &&
          tag.block.nodes.some(function (tag) {
            return tag.type !== 'Text' || !/^\s*$/.test(tag.val)
          })) {
        throw errorAtNode(tag, new Error(name + ' is self closing and should not have content.'));
      }
    } else {
      // Optimize attributes buffering
      this.buffer('<');
      bufferName();
      this.visitAttributes(tag.attrs, tag.attributeBlocks);
      this.buffer('>');
      if (tag.code) this.visitCode(tag.code);
      this.visit(tag.block);

      // pretty print
      if (pp && !tag.isInline() && 'pre' != tag.name && !tag.canInline())
        this.prettyIndent(0, true);

      this.buffer('</');
      bufferName();
      this.buffer('>');
    }

    if ('pre' == tag.name) this.escape = false;

    this.indents--;
  },

  /**
   * Visit `filter`, throwing when the filter does not exist.
   *
   * @param {Filter} filter
   * @api public
   */

  visitFilter: function(filter){
    var text = filter.block.nodes.map(
      function(node){ return node.val; }
    ).join('\n');
    filter.attrs.filename = this.options.filename;
    try {
      this.buffer(filters(filter.name, text, filter.attrs), true);
    } catch (err) {
      throw errorAtNode(filter, err);
    }
  },

  /**
   * Visit `text` node.
   *
   * @param {Text} text
   * @api public
   */

  visitText: function(text){
    this.buffer(text.val, true);
  },

  /**
   * Visit a `comment`, only buffering when the buffer flag is set.
   *
   * @param {Comment} comment
   * @api public
   */

  visitComment: function(comment){
    if (!comment.buffer) return;
    if (this.pp) this.prettyIndent(1, true);
    this.buffer('<!--' + comment.val + '-->');
  },

  /**
   * Visit a `BlockComment`.
   *
   * @param {Comment} comment
   * @api public
   */

  visitBlockComment: function(comment){
    if (!comment.buffer) return;
    if (this.pp) this.prettyIndent(1, true);
    this.buffer('<!--' + comment.val);
    this.visit(comment.block);
    if (this.pp) this.prettyIndent(1, true);
    this.buffer('-->');
  },

  /**
   * Visit `code`, respecting buffer / escape flags.
   * If the code is followed by a block, wrap it in
   * a self-calling function.
   *
   * @param {Code} code
   * @api public
   */

  visitCode: function(code){
    // Wrap code blocks with {}.
    // we only wrap unbuffered code blocks ATM
    // since they are usually flow control

    // Buffer code
    if (code.buffer) {
      var val = code.val.trimLeft();
      val = 'null == (jade_interp = '+val+') ? "" : jade_interp';
      if (code.escape) val = 'jade.escape(' + val + ')';
      this.bufferExpression(val);
    } else {
      this.buf.push(code.val);
    }

    // Block support
    if (code.block) {
      if (!code.buffer) this.buf.push('{');
      this.visit(code.block);
      if (!code.buffer) this.buf.push('}');
    }
  },

  /**
   * Visit `each` block.
   *
   * @param {Each} each
   * @api public
   */

  visitEach: function(each){
    this.buf.push(''
      + '// iterate ' + each.obj + '\n'
      + ';(function(){\n'
      + '  var $$obj = ' + each.obj + ';\n'
      + '  if (\'number\' == typeof $$obj.length) {\n');

    if (each.alternative) {
      this.buf.push('  if ($$obj.length) {');
    }

    this.buf.push(''
      + '    for (var ' + each.key + ' = 0, $$l = $$obj.length; ' + each.key + ' < $$l; ' + each.key + '++) {\n'
      + '      var ' + each.val + ' = $$obj[' + each.key + '];\n');

    this.visit(each.block);

    this.buf.push('    }\n');

    if (each.alternative) {
      this.buf.push('  } else {');
      this.visit(each.alternative);
      this.buf.push('  }');
    }

    this.buf.push(''
      + '  } else {\n'
      + '    var $$l = 0;\n'
      + '    for (var ' + each.key + ' in $$obj) {\n'
      + '      $$l++;'
      + '      var ' + each.val + ' = $$obj[' + each.key + '];\n');

    this.visit(each.block);

    this.buf.push('    }\n');
    if (each.alternative) {
      this.buf.push('    if ($$l === 0) {');
      this.visit(each.alternative);
      this.buf.push('    }');
    }
    this.buf.push('  }\n}).call(this);\n');
  },

  /**
   * Visit `attrs`.
   *
   * @param {Array} attrs
   * @api public
   */

  visitAttributes: function(attrs, attributeBlocks){
    if (attributeBlocks.length) {
      if (attrs.length) {
        var val = this.attrs(attrs);
        attributeBlocks.unshift(val);
      }
      this.bufferExpression('jade.attrs(jade.merge([' + attributeBlocks.join(',') + ']), ' + JSON.stringify(this.terse) + ')');
    } else if (attrs.length) {
      this.attrs(attrs, true);
    }
  },

  /**
   * Compile attributes.
   */

  attrs: function(attrs, buffer){
    var buf = [];
    var classes = [];
    var classEscaping = [];

    attrs.forEach(function(attr){
      var key = attr.name;
      var escaped = attr.escaped;

      if (key === 'class') {
        classes.push(attr.val);
        classEscaping.push(attr.escaped);
      } else if (isConstant(attr.val)) {
        if (buffer) {
          this.buffer(runtime.attr(key, toConstant(attr.val), escaped, this.terse));
        } else {
          var val = toConstant(attr.val);
          if (escaped && !(key.indexOf('data') === 0 && typeof val !== 'string')) {
            val = runtime.escape(val);
          }
          buf.push(JSON.stringify(key) + ': ' + JSON.stringify(val));
        }
      } else {
        if (buffer) {
          this.bufferExpression('jade.attr("' + key + '", ' + attr.val + ', ' + JSON.stringify(escaped) + ', ' + JSON.stringify(this.terse) + ')');
        } else {
          var val = attr.val;
          if (escaped && !(key.indexOf('data') === 0)) {
            val = 'jade.escape(' + val + ')';
          } else if (escaped) {
            val = '(typeof (jade_interp = ' + val + ') == "string" ? jade.escape(jade_interp) : jade_interp)';
          }
          buf.push(JSON.stringify(key) + ': ' + val);
        }
      }
    }.bind(this));
    if (buffer) {
      if (classes.every(isConstant)) {
        this.buffer(runtime.cls(classes.map(toConstant), classEscaping));
      } else {
        this.bufferExpression('jade.cls([' + classes.join(',') + '], ' + JSON.stringify(classEscaping) + ')');
      }
    } else if (classes.length) {
      if (classes.every(isConstant)) {
        classes = JSON.stringify(runtime.joinClasses(classes.map(toConstant).map(runtime.joinClasses).map(function (cls, i) {
          return classEscaping[i] ? runtime.escape(cls) : cls;
        })));
      } else {
        classes = '(jade_interp = ' + JSON.stringify(classEscaping) + ',' +
          ' jade.joinClasses([' + classes.join(',') + '].map(jade.joinClasses).map(function (cls, i) {' +
          '   return jade_interp[i] ? jade.escape(cls) : cls' +
          ' }))' +
          ')';
      }
      if (classes.length)
        buf.push('"class": ' + classes);
    }
    return '{' + buf.join(',') + '}';
  }
};


/***/ },
/* 17 */
/***/ function(module, exports) {

"use strict";
'use strict';

module.exports = [
    'a'
  , 'abbr'
  , 'acronym'
  , 'b'
  , 'br'
  , 'code'
  , 'em'
  , 'font'
  , 'i'
  , 'img'
  , 'ins'
  , 'kbd'
  , 'map'
  , 'samp'
  , 'small'
  , 'span'
  , 'strong'
  , 'sub'
  , 'sup'
];

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

var Node = __webpack_require__(0);

/**
 * Initialize a `BlockComment` with the given `block`.
 *
 * @param {String} val
 * @param {Block} block
 * @param {Boolean} buffer
 * @api public
 */

var BlockComment = module.exports = function BlockComment(val, block, buffer) {
  this.block = block;
  this.val = val;
  this.buffer = buffer;
};

// Inherit from `Node`.
BlockComment.prototype = Object.create(Node.prototype);
BlockComment.prototype.constructor = BlockComment;

BlockComment.prototype.type = 'BlockComment';


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

var Node = __webpack_require__(0);

/**
 * Initialize a new `Case` with `expr`.
 *
 * @param {String} expr
 * @api public
 */

var Case = exports = module.exports = function Case(expr, block){
  this.expr = expr;
  this.block = block;
};

// Inherit from `Node`.
Case.prototype = Object.create(Node.prototype);
Case.prototype.constructor = Case;

Case.prototype.type = 'Case';

var When = exports.When = function When(expr, block){
  this.expr = expr;
  this.block = block;
  this.debug = false;
};

// Inherit from `Node`.
When.prototype = Object.create(Node.prototype);
When.prototype.constructor = When;

When.prototype.type = 'When';


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

var Node = __webpack_require__(0);

/**
 * Initialize a `Code` node with the given code `val`.
 * Code may also be optionally buffered and escaped.
 *
 * @param {String} val
 * @param {Boolean} buffer
 * @param {Boolean} escape
 * @api public
 */

var Code = module.exports = function Code(val, buffer, escape) {
  this.val = val;
  this.buffer = buffer;
  this.escape = escape;
  if (val.match(/^ *else/)) this.debug = false;
};

// Inherit from `Node`.
Code.prototype = Object.create(Node.prototype);
Code.prototype.constructor = Code;

Code.prototype.type = 'Code'; // prevent the minifiers removing this

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

var Node = __webpack_require__(0);

/**
 * Initialize a `Comment` with the given `val`, optionally `buffer`,
 * otherwise the comment may render in the output.
 *
 * @param {String} val
 * @param {Boolean} buffer
 * @api public
 */

var Comment = module.exports = function Comment(val, buffer) {
  this.val = val;
  this.buffer = buffer;
};

// Inherit from `Node`.
Comment.prototype = Object.create(Node.prototype);
Comment.prototype.constructor = Comment;

Comment.prototype.type = 'Comment';


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

var Node = __webpack_require__(0);

/**
 * Initialize a `Doctype` with the given `val`. 
 *
 * @param {String} val
 * @api public
 */

var Doctype = module.exports = function Doctype(val) {
  this.val = val;
};

// Inherit from `Node`.
Doctype.prototype = Object.create(Node.prototype);
Doctype.prototype.constructor = Doctype;

Doctype.prototype.type = 'Doctype';


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

var Node = __webpack_require__(0);

/**
 * Initialize an `Each` node, representing iteration
 *
 * @param {String} obj
 * @param {String} val
 * @param {String} key
 * @param {Block} block
 * @api public
 */

var Each = module.exports = function Each(obj, val, key, block) {
  this.obj = obj;
  this.val = val;
  this.key = key;
  this.block = block;
};

// Inherit from `Node`.
Each.prototype = Object.create(Node.prototype);
Each.prototype.constructor = Each;

Each.prototype.type = 'Each';


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

var Node = __webpack_require__(0);

/**
 * Initialize a `Filter` node with the given
 * filter `name` and `block`.
 *
 * @param {String} name
 * @param {Block|Node} block
 * @api public
 */

var Filter = module.exports = function Filter(name, block, attrs) {
  this.name = name;
  this.block = block;
  this.attrs = attrs;
};

// Inherit from `Node`.
Filter.prototype = Object.create(Node.prototype);
Filter.prototype.constructor = Filter;

Filter.prototype.type = 'Filter';


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

var Node = __webpack_require__(0);

/**
 * Initialize a `Literal` node with the given `str.
 *
 * @param {String} str
 * @api public
 */

var Literal = module.exports = function Literal(str) {
  this.str = str;
};

// Inherit from `Node`.
Literal.prototype = Object.create(Node.prototype);
Literal.prototype.constructor = Literal;

Literal.prototype.type = 'Literal';


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

var Node = __webpack_require__(0);

/**
 * Initialize a new `Block` with an optional `node`.
 *
 * @param {Node} node
 * @api public
 */

var MixinBlock = module.exports = function MixinBlock(){};

// Inherit from `Node`.
MixinBlock.prototype = Object.create(Node.prototype);
MixinBlock.prototype.constructor = MixinBlock;

MixinBlock.prototype.type = 'MixinBlock';


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

var Attrs = __webpack_require__(9);

/**
 * Initialize a new `Mixin` with `name` and `block`.
 *
 * @param {String} name
 * @param {String} args
 * @param {Block} block
 * @api public
 */

var Mixin = module.exports = function Mixin(name, args, block, call){
  Attrs.call(this);
  this.name = name;
  this.args = args;
  this.block = block;
  this.call = call;
};

// Inherit from `Attrs`.
Mixin.prototype = Object.create(Attrs.prototype);
Mixin.prototype.constructor = Mixin;

Mixin.prototype.type = 'Mixin';


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

var Attrs = __webpack_require__(9);
var Block = __webpack_require__(10);
var inlineTags = __webpack_require__(17);

/**
 * Initialize a `Tag` node with the given tag `name` and optional `block`.
 *
 * @param {String} name
 * @param {Block} block
 * @api public
 */

var Tag = module.exports = function Tag(name, block) {
  Attrs.call(this);
  this.name = name;
  this.block = block || new Block;
};

// Inherit from `Attrs`.
Tag.prototype = Object.create(Attrs.prototype);
Tag.prototype.constructor = Tag;

Tag.prototype.type = 'Tag';

/**
 * Clone this tag.
 *
 * @return {Tag}
 * @api private
 */

Tag.prototype.clone = function(){
  var err = new Error('tag.clone is deprecated and will be removed in v2.0.0');
  console.warn(err.stack);

  var clone = new Tag(this.name, this.block.clone());
  clone.line = this.line;
  clone.attrs = this.attrs;
  clone.textOnly = this.textOnly;
  return clone;
};

/**
 * Check if this tag is an inline tag.
 *
 * @return {Boolean}
 * @api private
 */

Tag.prototype.isInline = function(){
  return ~inlineTags.indexOf(this.name);
};

/**
 * Check if this tag's contents can be inlined.  Used for pretty printing.
 *
 * @return {Boolean}
 * @api private
 */

Tag.prototype.canInline = function(){
  var nodes = this.block.nodes;

  function isInline(node){
    // Recurse if the node is a block
    if (node.isBlock) return node.nodes.every(isInline);
    return node.isText || (node.isInline && node.isInline());
  }

  // Empty tag
  if (!nodes.length) return true;

  // Text-only or inline-only tag
  if (1 == nodes.length) return isInline(nodes[0]);

  // Multi-line inline-only tag
  if (this.block.nodes.every(isInline)) {
    for (var i = 1, len = nodes.length; i < len; ++i) {
      if (nodes[i-1].isText && nodes[i].isText)
        return false;
    }
    return true;
  }

  // Mixed tag
  return false;
};


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

var Node = __webpack_require__(0);

/**
 * Initialize a `Text` node with optional `line`.
 *
 * @param {String} line
 * @api public
 */

var Text = module.exports = function Text(line) {
  this.val = line;
};

// Inherit from `Node`.
Text.prototype = Object.create(Node.prototype);
Text.prototype.constructor = Text;

Text.prototype.type = 'Text';

/**
 * Flag as text.
 */

Text.prototype.isText = true;

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

var Lexer = __webpack_require__(8);
var nodes = __webpack_require__(4);
var utils = __webpack_require__(1);
var filters = __webpack_require__(3);
var path = __webpack_require__(14);
var constantinople = __webpack_require__(13);
var parseJSExpression = __webpack_require__(5).parseMax;
var extname = path.extname;

/**
 * Initialize `Parser` with the given input `str` and `filename`.
 *
 * @param {String} str
 * @param {String} filename
 * @param {Object} options
 * @api public
 */

var Parser = exports = module.exports = function Parser(str, filename, options){
  //Strip any UTF-8 BOM off of the start of `str`, if it exists.
  this.input = str.replace(/^\uFEFF/, '');
  this.lexer = new Lexer(this.input, filename);
  this.filename = filename;
  this.blocks = {};
  this.mixins = {};
  this.options = options;
  this.contexts = [this];
  this.inMixin = false;
  this.dependencies = [];
};

/**
 * Parser prototype.
 */

Parser.prototype = {

  /**
   * Save original constructor
   */

  constructor: Parser,

  /**
   * Push `parser` onto the context stack,
   * or pop and return a `Parser`.
   */

  context: function(parser){
    if (parser) {
      this.contexts.push(parser);
    } else {
      return this.contexts.pop();
    }
  },

  /**
   * Return the next token object.
   *
   * @return {Object}
   * @api private
   */

  advance: function(){
    return this.lexer.advance();
  },

  /**
   * Single token lookahead.
   *
   * @return {Object}
   * @api private
   */

  peek: function() {
    return this.lookahead(1);
  },

  /**
   * Return lexer lineno.
   *
   * @return {Number}
   * @api private
   */

  line: function() {
    return this.lexer.lineno;
  },

  /**
   * `n` token lookahead.
   *
   * @param {Number} n
   * @return {Object}
   * @api private
   */

  lookahead: function(n){
    return this.lexer.lookahead(n);
  },

  /**
   * Parse input returning a string of js for evaluation.
   *
   * @return {String}
   * @api public
   */

  parse: function(){
    var block = new nodes.Block, parser;
    block.line = 0;
    block.filename = this.filename;

    while ('eos' != this.peek().type) {
      if ('newline' == this.peek().type) {
        this.advance();
      } else {
        var next = this.peek();
        var expr = this.parseExpr();
        expr.filename = expr.filename || this.filename;
        expr.line = next.line;
        block.push(expr);
      }
    }

    if (parser = this.extending) {
      this.context(parser);
      var ast = parser.parse();
      this.context();

      // hoist mixins
      for (var name in this.mixins)
        ast.unshift(this.mixins[name]);
      return ast;
    }

    if (!this.extending && !this.included && Object.keys(this.blocks).length){
      var blocks = [];
      utils.walkAST(block, function (node) {
        if (node.type === 'Block' && node.name) {
          blocks.push(node.name);
        }
      });
      Object.keys(this.blocks).forEach(function (name) {
        if (blocks.indexOf(name) === -1) {
          console.warn('Warning: Unexpected block "'
                       + name
                       + '" '
                       + ' on line '
                       + this.blocks[name].line
                       + ' of '
                       + (this.blocks[name].filename)
                       + '. This block is never used. This warning will be an error in v2.0.0');
        }
      }.bind(this));
    }

    return block;
  },

  /**
   * Expect the given type, or throw an exception.
   *
   * @param {String} type
   * @api private
   */

  expect: function(type){
    if (this.peek().type === type) {
      return this.advance();
    } else {
      throw new Error('expected "' + type + '", but got "' + this.peek().type + '"');
    }
  },

  /**
   * Accept the given `type`.
   *
   * @param {String} type
   * @api private
   */

  accept: function(type){
    if (this.peek().type === type) {
      return this.advance();
    }
  },

  /**
   *   tag
   * | doctype
   * | mixin
   * | include
   * | filter
   * | comment
   * | text
   * | each
   * | code
   * | yield
   * | id
   * | class
   * | interpolation
   */

  parseExpr: function(){
    switch (this.peek().type) {
      case 'tag':
        return this.parseTag();
      case 'mixin':
        return this.parseMixin();
      case 'block':
        return this.parseBlock();
      case 'mixin-block':
        return this.parseMixinBlock();
      case 'case':
        return this.parseCase();
      case 'extends':
        return this.parseExtends();
      case 'include':
        return this.parseInclude();
      case 'doctype':
        return this.parseDoctype();
      case 'filter':
        return this.parseFilter();
      case 'comment':
        return this.parseComment();
      case 'text':
        return this.parseText();
      case 'each':
        return this.parseEach();
      case 'code':
        return this.parseCode();
      case 'call':
        return this.parseCall();
      case 'interpolation':
        return this.parseInterpolation();
      case 'yield':
        this.advance();
        var block = new nodes.Block;
        block.yield = true;
        return block;
      case 'id':
      case 'class':
        var tok = this.advance();
        this.lexer.defer(this.lexer.tok('tag', 'div'));
        this.lexer.defer(tok);
        return this.parseExpr();
      default:
        throw new Error('unexpected token "' + this.peek().type + '"');
    }
  },

  /**
   * Text
   */

  parseText: function(){
    var tok = this.expect('text');
    var tokens = this.parseInlineTagsInText(tok.val);
    if (tokens.length === 1) return tokens[0];
    var node = new nodes.Block;
    for (var i = 0; i < tokens.length; i++) {
      node.push(tokens[i]);
    };
    return node;
  },

  /**
   *   ':' expr
   * | block
   */

  parseBlockExpansion: function(){
    if (':' == this.peek().type) {
      this.advance();
      return new nodes.Block(this.parseExpr());
    } else {
      return this.block();
    }
  },

  /**
   * case
   */

  parseCase: function(){
    var val = this.expect('case').val;
    var node = new nodes.Case(val);
    node.line = this.line();

    var block = new nodes.Block;
    block.line = this.line();
    block.filename = this.filename;
    this.expect('indent');
    while ('outdent' != this.peek().type) {
      switch (this.peek().type) {
        case 'newline':
          this.advance();
          break;
        case 'when':
          block.push(this.parseWhen());
          break;
        case 'default':
          block.push(this.parseDefault());
          break;
        default:
          throw new Error('Unexpected token "' + this.peek().type
                          + '", expected "when", "default" or "newline"');
      }
    }
    this.expect('outdent');

    node.block = block;

    return node;
  },

  /**
   * when
   */

  parseWhen: function(){
    var val = this.expect('when').val;
    if (this.peek().type !== 'newline')
      return new nodes.Case.When(val, this.parseBlockExpansion());
    else
      return new nodes.Case.When(val);
  },

  /**
   * default
   */

  parseDefault: function(){
    this.expect('default');
    return new nodes.Case.When('default', this.parseBlockExpansion());
  },

  /**
   * code
   */

  parseCode: function(afterIf){
    var tok = this.expect('code');
    var node = new nodes.Code(tok.val, tok.buffer, tok.escape);
    var block;
    node.line = this.line();

    // throw an error if an else does not have an if
    if (tok.isElse && !tok.hasIf) {
      throw new Error('Unexpected else without if');
    }

    // handle block
    block = 'indent' == this.peek().type;
    if (block) {
      node.block = this.block();
    }

    // handle missing block
    if (tok.requiresBlock && !block) {
      node.block = new nodes.Block();
    }

    // mark presense of if for future elses
    if (tok.isIf && this.peek().isElse) {
      this.peek().hasIf = true;
    } else if (tok.isIf && this.peek().type === 'newline' && this.lookahead(2).isElse) {
      this.lookahead(2).hasIf = true;
    }

    return node;
  },

  /**
   * comment
   */

  parseComment: function(){
    var tok = this.expect('comment');
    var node;

    var block;
    if (block = this.parseTextBlock()) {
      node = new nodes.BlockComment(tok.val, block, tok.buffer);
    } else {
      node = new nodes.Comment(tok.val, tok.buffer);
    }

    node.line = this.line();
    return node;
  },

  /**
   * doctype
   */

  parseDoctype: function(){
    var tok = this.expect('doctype');
    var node = new nodes.Doctype(tok.val);
    node.line = this.line();
    return node;
  },

  /**
   * filter attrs? text-block
   */

  parseFilter: function(){
    var tok = this.expect('filter');
    var attrs = this.accept('attrs');
    var block;

    block = this.parseTextBlock() || new nodes.Block();

    var options = {};
    if (attrs) {
      attrs.attrs.forEach(function (attribute) {
        options[attribute.name] = constantinople.toConstant(attribute.val);
      });
    }

    var node = new nodes.Filter(tok.val, block, options);
    node.line = this.line();
    return node;
  },

  /**
   * each block
   */

  parseEach: function(){
    var tok = this.expect('each');
    var node = new nodes.Each(tok.code, tok.val, tok.key);
    node.line = this.line();
    node.block = this.block();
    if (this.peek().type == 'code' && this.peek().val == 'else') {
      this.advance();
      node.alternative = this.block();
    }
    return node;
  },

  /**
   * Resolves a path relative to the template for use in
   * includes and extends
   *
   * @param {String}  path
   * @param {String}  purpose  Used in error messages.
   * @return {String}
   * @api private
   */

  resolvePath: function (path, purpose) {
    var p = __webpack_require__(14);
    var dirname = p.dirname;
    var basename = p.basename;
    var join = p.join;

    if (path[0] !== '/' && !this.filename)
      throw new Error('the "filename" option is required to use "' + purpose + '" with "relative" paths');

    if (path[0] === '/' && !this.options.basedir)
      throw new Error('the "basedir" option is required to use "' + purpose + '" with "absolute" paths');

    path = join(path[0] === '/' ? this.options.basedir : dirname(this.filename), path);

    if (basename(path).indexOf('.') === -1) path += '.jade';

    return path;
  },

  /**
   * 'extends' name
   */

  parseExtends: function(){
    var fs = __webpack_require__(2);

    var path = this.resolvePath(this.expect('extends').val.trim(), 'extends');
    if ('.jade' != path.substr(-5)) path += '.jade';

    this.dependencies.push(path);
    var str = fs.readFileSync(path, 'utf8');
    var parser = new this.constructor(str, path, this.options);
    parser.dependencies = this.dependencies;

    parser.blocks = this.blocks;
    parser.contexts = this.contexts;
    this.extending = parser;

    // TODO: null node
    return new nodes.Literal('');
  },

  /**
   * 'block' name block
   */

  parseBlock: function(){
    var block = this.expect('block');
    var mode = block.mode;
    var name = block.val.trim();

    block = 'indent' == this.peek().type
      ? this.block()
      : new nodes.Block(new nodes.Literal(''));
    block.name = name;

    var prev = this.blocks[name] || {prepended: [], appended: []}
    if (prev.mode === 'replace') return this.blocks[name] = prev;

    var allNodes = prev.prepended.concat(block.nodes).concat(prev.appended);

    switch (mode) {
      case 'append':
        prev.appended = prev.parser === this ?
                        prev.appended.concat(block.nodes) :
                        block.nodes.concat(prev.appended);
        break;
      case 'prepend':
        prev.prepended = prev.parser === this ?
                         block.nodes.concat(prev.prepended) :
                         prev.prepended.concat(block.nodes);
        break;
    }
    block.nodes = allNodes;
    block.appended = prev.appended;
    block.prepended = prev.prepended;
    block.mode = mode;
    block.parser = this;

    return this.blocks[name] = block;
  },

  parseMixinBlock: function () {
    var block = this.expect('mixin-block');
    if (!this.inMixin) {
      throw new Error('Anonymous blocks are not allowed unless they are part of a mixin.');
    }
    return new nodes.MixinBlock();
  },

  /**
   * include block?
   */

  parseInclude: function(){
    var fs = __webpack_require__(2);
    var tok = this.expect('include');

    var path = this.resolvePath(tok.val.trim(), 'include');
    this.dependencies.push(path);
    // has-filter
    if (tok.filter) {
      var str = fs.readFileSync(path, 'utf8').replace(/\r/g, '');
      var options = {filename: path};
      if (tok.attrs) {
        tok.attrs.attrs.forEach(function (attribute) {
          options[attribute.name] = constantinople.toConstant(attribute.val);
        });
      }
      str = filters(tok.filter, str, options);
      return new nodes.Literal(str);
    }

    // non-jade
    if ('.jade' != path.substr(-5)) {
      var str = fs.readFileSync(path, 'utf8').replace(/\r/g, '');
      return new nodes.Literal(str);
    }

    var str = fs.readFileSync(path, 'utf8');
    var parser = new this.constructor(str, path, this.options);
    parser.dependencies = this.dependencies;

    parser.blocks = utils.merge({}, this.blocks);
    parser.included = true;

    parser.mixins = this.mixins;

    this.context(parser);
    var ast = parser.parse();
    this.context();
    ast.filename = path;

    if ('indent' == this.peek().type) {
      ast.includeBlock().push(this.block());
    }

    return ast;
  },

  /**
   * call ident block
   */

  parseCall: function(){
    var tok = this.expect('call');
    var name = tok.val;
    var args = tok.args;
    var mixin = new nodes.Mixin(name, args, new nodes.Block, true);

    this.tag(mixin);
    if (mixin.code) {
      mixin.block.push(mixin.code);
      mixin.code = null;
    }
    if (mixin.block.isEmpty()) mixin.block = null;
    return mixin;
  },

  /**
   * mixin block
   */

  parseMixin: function(){
    var tok = this.expect('mixin');
    var name = tok.val;
    var args = tok.args;
    var mixin;

    // definition
    if ('indent' == this.peek().type) {
      this.inMixin = true;
      mixin = new nodes.Mixin(name, args, this.block(), false);
      this.mixins[name] = mixin;
      this.inMixin = false;
      return mixin;
    // call
    } else {
      return new nodes.Mixin(name, args, null, true);
    }
  },

  parseInlineTagsInText: function (str) {
    var line = this.line();

    var match = /(\\)?#\[((?:.|\n)*)$/.exec(str);
    if (match) {
      if (match[1]) { // escape
        var text = new nodes.Text(str.substr(0, match.index) + '#[');
        text.line = line;
        var rest = this.parseInlineTagsInText(match[2]);
        if (rest[0].type === 'Text') {
          text.val += rest[0].val;
          rest.shift();
        }
        return [text].concat(rest);
      } else {
        var text = new nodes.Text(str.substr(0, match.index));
        text.line = line;
        var buffer = [text];
        var rest = match[2];
        var range = parseJSExpression(rest);
        var inner = new Parser(range.src, this.filename, this.options);
        buffer.push(inner.parse());
        return buffer.concat(this.parseInlineTagsInText(rest.substr(range.end + 1)));
      }
    } else {
      var text = new nodes.Text(str);
      text.line = line;
      return [text];
    }
  },

  /**
   * indent (text | newline)* outdent
   */

  parseTextBlock: function(){
    var block = new nodes.Block;
    block.line = this.line();
    var body = this.peek();
    if (body.type !== 'pipeless-text') return;
    this.advance();
    block.nodes = body.val.reduce(function (accumulator, text) {
      return accumulator.concat(this.parseInlineTagsInText(text));
    }.bind(this), []);
    return block;
  },

  /**
   * indent expr* outdent
   */

  block: function(){
    var block = new nodes.Block;
    block.line = this.line();
    block.filename = this.filename;
    this.expect('indent');
    while ('outdent' != this.peek().type) {
      if ('newline' == this.peek().type) {
        this.advance();
      } else {
        var expr = this.parseExpr();
        expr.filename = this.filename;
        block.push(expr);
      }
    }
    this.expect('outdent');
    return block;
  },

  /**
   * interpolation (attrs | class | id)* (text | code | ':')? newline* block?
   */

  parseInterpolation: function(){
    var tok = this.advance();
    var tag = new nodes.Tag(tok.val);
    tag.buffer = true;
    return this.tag(tag);
  },

  /**
   * tag (attrs | class | id)* (text | code | ':')? newline* block?
   */

  parseTag: function(){
    var tok = this.advance();
    var tag = new nodes.Tag(tok.val);

    tag.selfClosing = tok.selfClosing;

    return this.tag(tag);
  },

  /**
   * Parse tag.
   */

  tag: function(tag){
    tag.line = this.line();

    var seenAttrs = false;
    // (attrs | class | id)*
    out:
      while (true) {
        switch (this.peek().type) {
          case 'id':
          case 'class':
            var tok = this.advance();
            tag.setAttribute(tok.type, "'" + tok.val + "'");
            continue;
          case 'attrs':
            if (seenAttrs) {
              console.warn(this.filename + ', line ' + this.peek().line + ':\nYou should not have jade tags with multiple attributes.');
            }
            seenAttrs = true;
            var tok = this.advance();
            var attrs = tok.attrs;

            if (tok.selfClosing) tag.selfClosing = true;

            for (var i = 0; i < attrs.length; i++) {
              tag.setAttribute(attrs[i].name, attrs[i].val, attrs[i].escaped);
            }
            continue;
          case '&attributes':
            var tok = this.advance();
            tag.addAttributes(tok.val);
            break;
          default:
            break out;
        }
      }

    // check immediate '.'
    if ('dot' == this.peek().type) {
      tag.textOnly = true;
      this.advance();
    }

    // (text | code | ':')?
    switch (this.peek().type) {
      case 'text':
        tag.block.push(this.parseText());
        break;
      case 'code':
        tag.code = this.parseCode();
        break;
      case ':':
        this.advance();
        tag.block = new nodes.Block;
        tag.block.push(this.parseExpr());
        break;
      case 'newline':
      case 'indent':
      case 'outdent':
      case 'eos':
      case 'pipeless-text':
        break;
      default:
        throw new Error('Unexpected token `' + this.peek().type + '` expected `text`, `code`, `:`, `newline` or `eos`')
    }

    // newline*
    while ('newline' == this.peek().type) this.advance();

    // block?
    if (tag.textOnly) {
      tag.block = this.parseTextBlock();
    } else if ('indent' == this.peek().type) {
      var block = this.block();
      for (var i = 0, len = block.nodes.length; i < len; ++i) {
        tag.block.push(block.nodes[i]);
      }
    }

    return tag;
  }
};


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

var uglify = __webpack_require__(6)

module.exports = addWith

/**
 * Mimic `with` as far as possible but at compile time
 *
 * @param {String} obj The object part of a with expression
 * @param {String} src The body of the with expression
 * @param {Array.<String>} exclude A list of variable names to explicitly exclude
 */
function addWith(obj, src, exclude) {
  obj = obj + ''
  src = src + ''
  exclude = exclude || []
  exclude = exclude.concat(detect(obj))
  var vars = detect(src)
    .filter(function (v) {
      return exclude.indexOf(v) === -1
    })

  if (vars.length === 0) return src

  var declareLocal = ''
  var local = 'locals_for_with'
  var result = 'result_of_with'
  if (/^[a-zA-Z0-9$_]+$/.test(obj)) {
    local = obj
  } else {
    while (vars.indexOf(local) != -1 || exclude.indexOf(local) != -1) {
      local += '_'
    }
    declareLocal = 'var ' + local + ' = (' + obj + ')'
  }
  while (vars.indexOf(result) != -1 || exclude.indexOf(result) != -1) {
    result += '_'
  }

  var inputVars = vars.map(function (v) {
    return JSON.stringify(v) + ' in ' + local + '?' +
      local + '.' + v + ':' +
      'typeof ' + v + '!=="undefined"?' + v + ':undefined'
  })

  src = '(function (' + vars.join(', ') + ') {' +
    src +
    '}.call(this' + inputVars.map(function (v) { return ',' + v; }).join('') + '))'

  return ';' + declareLocal + ';' + unwrapReturns(src, result) + ';'
}

/**
 * Detect, and return a list of, any global variables in a function
 *
 * @param {String} src Some JavaScript code
 */
function detect(src) {
    var ast = uglify.parse('(function () {' + src + '}())') // allow return keyword
    ast.figure_out_scope()
    var globals = ast.globals
        .map(function (node, name) {
            return name
        })
    return globals
}

/**
 * Take a self calling function, and unwrap it such that return inside the function
 * results in return outside the function
 *
 * @param {String} src    Some JavaScript code representing a self-calling function
 * @param {String} result A temporary variable to store the result in
 */
function unwrapReturns(src, result) {
  var originalSource = src
  var hasReturn = false
  var ast = uglify.parse(src)
  var ref
  src = src.split('')

  // get a reference to the function that was inserted to add an inner context
  if ((ref = ast.body).length !== 1
   || (ref = ref[0]).TYPE !== 'SimpleStatement'
   || (ref = ref.body).TYPE !== 'Call'
   || (ref = ref.expression).TYPE !== 'Dot' || ref.property !== 'call'
   || (ref = ref.expression).TYPE !== 'Function')
    throw new Error('AST does not seem to represent a self-calling function')
  var fn = ref

  var walker = new uglify.TreeWalker(visitor)
  function visitor(node, descend) {
    if (node !== fn && (node.TYPE === 'Defun' || node.TYPE === 'Function')) {
      return true //don't descend into functions
    }
    if (node.TYPE === 'Return') {
      descend()
      hasReturn = true
      replace(node, 'return {value: ' + source(node.value) + '};')
      return true //don't descend again
    }
  }
  function source(node) {
    return src.slice(node.start.pos, node.end.endpos).join('')
  }
  function replace(node, str) {
    for (var i = node.start.pos; i < node.end.endpos; i++) {
      src[i] = ''
    }
    src[node.start.pos] = str
  }
  ast.walk(walker)
  if (!hasReturn) return originalSource
  else return 'var ' + result + '=' + src.join('') + ';if (' + result + ') return ' + result + '.value'
}


/***/ },
/* 32 */
/***/ function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

self.Jade  = __webpack_require__(15);

self.onmessage = function(ev) {
  var data = JSON.parse(ev.data);
  var html = data.html;
  var opts = data.options || {};

  self.Jade.render(html, opts, function(err, result) {
    self.postMessage(JSON.stringify({err: err, html: result}))
  })
};


/***/ }
/******/ ]);
//# sourceMappingURL=jade-1.4.0.min.js.map